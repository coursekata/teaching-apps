<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tutorial Player</title>

<!--
  LOADING TUTORIALS - THREE METHODS:
  
  METHOD 1 (RECOMMENDED): Load from URL parameter
  =====================================================
  Upload your tutorial JSON to GitHub (or any static host), then link to the player with:
  
  player.html?tutorial=https://username.github.io/tutorials/lesson1.json
  
  This is the cleanest approach:
  - One player file for all tutorials
  - Update tutorials without touching the player
  - Easy to share and maintain
  
  
  METHOD 2: Embed tutorial in HTML
  =====================================================
  For a completely self-contained single file, add a script tag before the other
  scripts that sets window.TUTORIAL_DATA:
  
  <script>
  window.TUTORIAL_DATA = {
    "version": "9.32",
    "appUrl": "https://your-app-url.com",
    "initialState": { ... },
    "snapshots": [ ... ],
    "annotations": [ ... ],
    "pauses": [ ... ],
    "duration": 12345
  };
  </script>
  
  Just copy your exported JSON and paste it as the value of TUTORIAL_DATA.
  
  
  METHOD 3: File upload
  =====================================================
  The player shows a file picker by default if no tutorial is provided.
  Good for local testing.
-->

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font: 14px/1.4 system-ui, -apple-system, sans-serif;
    background: #f5f5f5;
  }
  
  .player-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
  }
  
  .controls {
    background: #fff;
    padding: 16px;
    border-radius: 8px;
    margin-bottom: 16px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }
  
  button {
    padding: 10px 16px;
    border-radius: 6px;
    border: 1px solid #ddd;
    background: #fff;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
  }
  
  button:hover:not(:disabled) {
    background: #f9f9f9;
  }
  
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  button.primary {
    background: #2563eb;
    color: #fff;
    border-color: #2563eb;
  }
  
  button.primary:hover:not(:disabled) {
    background: #1d4ed8;
  }
  
  button.flash {
    animation: flashButton 1s ease-in-out infinite;
  }
  
  @keyframes flashButton {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }
  
  .scrubber {
    flex: 1;
    min-width: 200px;
    height: 8px;
    background: #e5e7eb;
    border-radius: 4px;
    position: relative;
    cursor: pointer;
  }
  
  .scrubber-progress {
    height: 100%;
    background: #2563eb;
    border-radius: 4px;
    transition: width 0.1s linear;
  }
  
  .time-display {
    font-variant-numeric: tabular-nums;
    color: #666;
    font-size: 13px;
    min-width: 80px;
    text-align: right;
  }
  
  .app-frame-container {
    position: relative;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    overflow: hidden;
  }
  
  iframe {
    width: 100%;
    height: 700px;
    border: none;
    display: block;
  }
  
  .annotation-box {
    position: absolute;
    width: 250px;
    max-width: 500px;
    background: rgba(255,255,255,0.98);
    border: 3px solid #2563eb;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    z-index: 100;
    display: none;
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  .annotation-box.visible {
    display: block;
    animation: fadeIn 0.3s ease-out;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .annotation-box h3 {
    margin: 0 0 12px;
    color: #2563eb;
    font-size: 18px;
  }
  
  .annotation-box p {
    margin: 0;
    line-height: 1.6;
    font-size: 15px;
  }
  
  .load-tutorial {
    background: #fff;
    padding: 32px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
  }
  
  .load-tutorial h2 {
    margin: 0 0 20px;
    color: #111;
  }
  
  .load-tutorial input[type="file"] {
    display: none;
  }
  
  .load-tutorial label {
    display: inline-block;
    padding: 12px 24px;
    background: #2563eb;
    color: #fff;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
  }
  
  .load-tutorial label:hover {
    background: #1d4ed8;
  }
  
  .error {
    background: #fee;
    border: 1px solid #fcc;
    color: #c00;
    padding: 12px;
    border-radius: 6px;
    margin-top: 16px;
  }
</style>
</head>
<body>

<div class="player-container">
  <div id="loadSection" class="load-tutorial">
    <h2>Load Tutorial</h2>
    <p style="color: #666; margin-bottom: 20px;">Select a tutorial JSON file to begin</p>
    <input type="file" id="tutorialFile" accept=".json" />
    <label for="tutorialFile">Choose Tutorial File</label>
    <div id="errorMsg" class="error" style="display:none;"></div>
  </div>
  
  <div id="playerSection" style="display:none;">
    <div class="controls">
      <button id="playPauseBtn" class="primary">▶ Play</button>
      <div class="scrubber" id="scrubber">
        <div class="scrubber-progress" id="scrubberProgress"></div>
      </div>
      <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
    </div>
    
    <div class="app-frame-container">
      <iframe id="appFrame"></iframe>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';
  
  // Elements
  const loadSection = document.getElementById('loadSection');
  const playerSection = document.getElementById('playerSection');
  const tutorialFile = document.getElementById('tutorialFile');
  const errorMsg = document.getElementById('errorMsg');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const scrubber = document.getElementById('scrubber');
  const scrubberProgress = document.getElementById('scrubberProgress');
  const timeDisplay = document.getElementById('timeDisplay');
  const appFrame = document.getElementById('appFrame');
  
  // State
  let tutorial = null;
  let isPlaying = false;
  let playbackStartTime = 0;
  let currentTime = 0;
  let animationFrame = null;
  let annotationBox = null;
  let annotationTitle = null;
  let annotationText = null;
  let currentAnnotationIndex = -1;
  let annotationTimeout = null;
  let triggeredPauses = new Set(); // Track which pauses we've already triggered
  
  // Check for embedded tutorial
  const embeddedTutorial = window.TUTORIAL_DATA || null;
  
  // Check for tutorial URL parameter
  const urlParams = new URLSearchParams(window.location.search);
  const tutorialUrl = urlParams.get('tutorial') || urlParams.get('json');
  
  // Auto-load tutorial from URL parameter if present
  if (tutorialUrl) {
    loadSection.style.display = 'none';
    const loadingMsg = document.createElement('div');
    loadingMsg.style.cssText = 'text-align:center;padding:40px;color:#666;';
    loadingMsg.textContent = 'Loading tutorial...';
    document.querySelector('.player-container').insertBefore(loadingMsg, playerSection);
    
    fetch(tutorialUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to load tutorial: ' + response.statusText);
        }
        return response.json();
      })
      .then(data => {
        tutorial = data;
        
        // Validate tutorial
        if (!tutorial.initialState || !tutorial.snapshots || !tutorial.annotations) {
          throw new Error('Invalid tutorial format');
        }
        
        // Check for app URL
        if (!tutorial.appUrl) {
          throw new Error('This tutorial does not contain an app URL. Please use a tutorial created with v12.31 or later.');
        }
        
        loadingMsg.remove();
        loadApp();
      })
      .catch(err => {
        loadingMsg.remove();
        loadSection.style.display = 'block';
        showError('Error loading tutorial from URL: ' + err.message);
      });
  }
  // Auto-load embedded tutorial if present
  else if (embeddedTutorial) {
    try {
      tutorial = embeddedTutorial;
      
      // Validate tutorial
      if (!tutorial.initialState || !tutorial.snapshots || !tutorial.annotations) {
        throw new Error('Invalid tutorial format');
      }
      
      // Check for app URL
      if (!tutorial.appUrl) {
        showError('This tutorial does not contain an app URL. Please use a tutorial created with v12.31 or later.');
      } else {
        // Load the app
        loadApp();
      }
    } catch (err) {
      showError('Error loading embedded tutorial: ' + err.message);
    }
  }
  
  // Load tutorial from file
  tutorialFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        tutorial = JSON.parse(event.target.result);
        
        // Validate tutorial
        if (!tutorial.initialState || !tutorial.snapshots || !tutorial.annotations) {
          throw new Error('Invalid tutorial format');
        }
        
        // Check for app URL
        if (!tutorial.appUrl) {
          showError('This tutorial does not contain an app URL. Please use a tutorial created with v12.31 or later.');
          return;
        }
        
        // Load the app
        loadApp();
        
      } catch (err) {
        showError('Error loading tutorial: ' + err.message);
      }
    };
    reader.readAsText(file);
  });
  
  function showError(msg) {
    errorMsg.textContent = msg;
    errorMsg.style.display = 'block';
  }
  
  function loadApp() {
    loadSection.style.display = 'none';
    playerSection.style.display = 'block';
    
    appFrame.src = tutorial.appUrl;
    
    // Wait for iframe to load
    appFrame.addEventListener('load', () => {
      // Poll for API
      const checkAPI = setInterval(() => {
        const api = getAPI();
        if (api) {
          clearInterval(checkAPI);
          console.log('✓ API ready');
          
          // Set initial state
          api.setState(tutorial.initialState);
          
          // Inject annotation box
          injectAnnotationBox();
          
          // Enable controls
          playPauseBtn.disabled = false;
          
          console.log('Tutorial loaded:', tutorial.snapshots.length, 'snapshots,', tutorial.annotations.length, 'annotations');
        }
      }, 100);
      
      setTimeout(() => {
        clearInterval(checkAPI);
      }, 5000);
    });
  }
  
  function getAPI() {
    try {
      return appFrame.contentWindow.tutorialAPI;
    } catch (e) {
      return null;
    }
  }
  
  function injectAnnotationBox() {
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    if (!iframeDoc) return;
    
    annotationBox = iframeDoc.createElement('div');
    annotationBox.className = 'annotation-box';
    annotationBox.innerHTML = '<h3 id="annotationTitle"></h3><p id="annotationText"></p>';
    
    annotationTitle = annotationBox.querySelector('#annotationTitle');
    annotationText = annotationBox.querySelector('#annotationText');
    
    // Inject styles
    const style = iframeDoc.createElement('style');
    style.textContent = `
      .annotation-box {
        position: absolute;
        width: 250px;
        max-width: 500px;
        background: rgba(255,255,255,0.98);
        border: 3px solid #2563eb;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        z-index: 100;
        display: none;
        overflow-y: auto;
        overflow-x: hidden;
        box-sizing: border-box;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        font-size: 15px;
        line-height: 1.6;
      }
      .annotation-box.custom-position {
        max-width: none;
      }
      .annotation-box.visible {
        display: block;
        animation: fadeIn 0.3s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .annotation-box h3 {
        margin: 0 0 12px;
        color: #2563eb;
        font-size: 18px;
        line-height: 1.3;
      }
      .annotation-box p {
        margin: 0;
        line-height: inherit;
        font-size: inherit;
      }
    `;
    iframeDoc.head.appendChild(style);
    iframeDoc.body.appendChild(annotationBox);
  }
  
  // Play/Pause
  playPauseBtn.addEventListener('click', () => {
    if (isPlaying) {
      pause();
    } else {
      play();
    }
  });
  
  function play() {
    if (!tutorial) return;
    
    // If we're at the end, reset to beginning (replay)
    if (currentTime >= tutorial.duration) {
      currentTime = 0;
      currentAnnotationIndex = -1;
      triggeredPauses.clear();
      hideAnnotation();
      
      const api = getAPI();
      if (api) {
        api.setState(tutorial.initialState);
      }
      
      scrubberProgress.style.width = '0%';
      updateTimeDisplay();
    }
    
    isPlaying = true;
    playbackStartTime = Date.now() - currentTime;
    playPauseBtn.textContent = '⏸ Pause';
    playPauseBtn.classList.remove('flash'); // Stop flashing when user clicks play
    
    animationFrame = requestAnimationFrame(playbackLoop);
  }
  
  function pause() {
    isPlaying = false;
    playPauseBtn.textContent = '▶ Play';
    
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
      animationFrame = null;
    }
  }
  
  function playbackLoop() {
    if (!isPlaying) return;
    
    currentTime = Date.now() - playbackStartTime;
    
    // Update scrubber
    const progress = Math.min(100, (currentTime / tutorial.duration) * 100);
    scrubberProgress.style.width = progress + '%';
    
    // Update time display
    updateTimeDisplay();
    
    // Apply snapshots
    const api = getAPI();
    if (api) {
      for (const snapshot of tutorial.snapshots) {
        if (snapshot.timestamp <= currentTime && snapshot.timestamp > currentTime - 100) {
          api.setState(snapshot.state);
        }
      }
    }
    
    // Handle annotations
    handleAnnotations();
    
    // Handle pauses
    if (tutorial.pauses) {
      for (let i = 0; i < tutorial.pauses.length; i++) {
        const pauseEvent = tutorial.pauses[i];
        
        // Only trigger if we haven't triggered this pause yet
        if (!triggeredPauses.has(i) && pauseEvent.timestamp <= currentTime) {
          triggeredPauses.add(i);
          pause();
          playPauseBtn.classList.add('flash'); // Flash the button to signal user needs to click
          console.log('⏸ Paused at', (pauseEvent.timestamp / 1000).toFixed(2) + 's');
          return;
        }
      }
    }
    
    // Check if finished
    if (currentTime >= tutorial.duration) {
      pause();
      playPauseBtn.textContent = '⟲ Replay';
      return;
    }
    
    animationFrame = requestAnimationFrame(playbackLoop);
  }
  
  function handleAnnotations() {
    if (!tutorial.annotations || tutorial.annotations.length === 0) return;
    
    for (let i = 0; i < tutorial.annotations.length; i++) {
      const ann = tutorial.annotations[i];
      const annStart = ann.timestamp;
      const annEnd = ann.timestamp + ann.duration;
      
      // Show annotation if we're in its time range
      if (currentTime >= annStart && currentTime < annEnd) {
        if (currentAnnotationIndex !== i) {
          showAnnotation(ann);
          currentAnnotationIndex = i;
        }
        return;
      }
    }
    
    // Hide annotation if we're not in any range
    if (currentAnnotationIndex !== -1) {
      hideAnnotation();
      currentAnnotationIndex = -1;
    }
  }
  
  function showAnnotation(ann) {
    if (!annotationBox) return;
    
    annotationTitle.textContent = ann.title;
    annotationText.innerHTML = ann.text;
    
    // Reset transform and size constraints
    annotationBox.style.transform = '';
    
    // Position annotation
    if (ann.position) {
      // Custom positioned annotation
      annotationBox.classList.add('custom-position');
      annotationBox.style.left = ann.position.x + 'px';
      annotationBox.style.top = ann.position.y + 'px';
      if (ann.position.width) {
        annotationBox.style.width = ann.position.width + 'px';
      } else {
        annotationBox.style.width = '250px'; // Reset to default
      }
      if (ann.position.height) {
        annotationBox.style.height = ann.position.height + 'px';
      } else {
        annotationBox.style.height = 'auto'; // Reset to default
      }
    } else {
      // Default center position
      annotationBox.classList.remove('custom-position');
      annotationBox.style.left = '50%';
      annotationBox.style.top = '50%';
      annotationBox.style.transform = 'translate(-50%, -50%)';
      annotationBox.style.width = '250px';
      annotationBox.style.height = 'auto';
    }
    
    annotationBox.classList.add('visible');
    
    // Typeset math if present
    if (window.MathJax && ann.text.includes('$')) {
      MathJax.typesetPromise([annotationText]).catch(err => console.log('MathJax error:', err));
    }
  }
  
  function hideAnnotation() {
    if (annotationBox) {
      annotationBox.classList.remove('visible');
      annotationBox.classList.remove('custom-position');
    }
  }
  
  function updateTimeDisplay() {
    const current = Math.floor(currentTime / 1000);
    const total = Math.floor(tutorial.duration / 1000);
    
    const currentMin = Math.floor(current / 60);
    const currentSec = current % 60;
    const totalMin = Math.floor(total / 60);
    const totalSec = total % 60;
    
    timeDisplay.textContent = 
      `${currentMin}:${currentSec.toString().padStart(2, '0')} / ` +
      `${totalMin}:${totalSec.toString().padStart(2, '0')}`;
  }
  
  // Scrubber
  scrubber.addEventListener('click', (e) => {
    if (!tutorial) return;
    
    const rect = scrubber.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const percent = clickX / rect.width;
    
    currentTime = percent * tutorial.duration;
    
    // Mark any pauses before current time as triggered
    if (tutorial.pauses) {
      for (let i = 0; i < tutorial.pauses.length; i++) {
        if (tutorial.pauses[i].timestamp <= currentTime) {
          triggeredPauses.add(i);
        } else {
          triggeredPauses.delete(i); // Remove if we scrubbed backward past it
        }
      }
    }
    
    if (isPlaying) {
      playbackStartTime = Date.now() - currentTime;
    }
    
    // Apply state at new time
    const api = getAPI();
    if (api) {
      // Find the most recent snapshot before this time
      let targetState = tutorial.initialState;
      for (const snapshot of tutorial.snapshots) {
        if (snapshot.timestamp <= currentTime) {
          targetState = snapshot.state;
        } else {
          break;
        }
      }
      api.setState(targetState);
    }
    
    // Update display
    scrubberProgress.style.width = (percent * 100) + '%';
    updateTimeDisplay();
    handleAnnotations();
  });
  
  console.log('Tutorial Player initialized');
})();
</script>
</body>
</html>
