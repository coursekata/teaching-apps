<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Tutorial Creator - v12.61</title>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    },
    startup: {
      ready: () => {
        MathJax.startup.defaultReady();
      }
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  :root{
    --accent:#2563eb;
    --record:#ef4444;
    --success:#10b981;
    --warning:#f59e0b;
    --teal:#06b6d4;
  }
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#111;
    background:#f5f5f5;
  }
  
  .tutorial-header{
    position: sticky;
    top: 0;
    background:#fff;
    border-bottom:2px solid #ddd;
    padding:12px 20px;
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .version-number{
    color: #666;
    font-size: 12px;
    font-weight: 500;
  }
  
  .tutorial-controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  button{
    padding:8px 14px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:13px;
  }
  
  button:hover:not(:disabled):not(.primary):not(.record):not(.success):not(.warning):not(.teal){
    background:#f9f9f9;
  }
  
  button:disabled{
    opacity:0.5;
    cursor:not-allowed;
  }
  
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button.record{
    background:var(--record);
    color:#fff;
    border-color:var(--record);
  }
  
  button.success{
    background:var(--success);
    color:#fff;
    border-color:var(--success);
  }
  
  button.warning{
    background:var(--warning);
    color:#fff;
    border-color:var(--warning);
  }
  
  button.teal{
    background:var(--teal);
    color:#fff;
    border-color:var(--teal);
  }
  
  button.record.recording{
    animation:pulse 1.5s infinite;
  }
  
  button.primary.playing{
    animation:pulse 1.5s infinite;
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.6}
  }
  
  .recording-active{
    animation:pulse 1.5s infinite;
  }
  
  .recording-indicator{
    background:var(--record);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
    animation:pulse 1.5s infinite;
  }
  
  .paused-indicator{
    background:var(--warning);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
  }
  
  .app-container{
    position:relative;
    width:100%;
    height:800px;
    overflow:hidden;
    margin-bottom:40px;
  }
  
  iframe{
    width:100%;
    height:100%;
    border:none;
  }
  
  iframe.playback-mode{
    pointer-events:none;
  }
  
  .annotation-box{
    position:absolute;
    width:250px;
    max-width:500px;
    background:rgba(255,255,255,0.98);
    border:3px solid var(--accent);
    border-radius:12px;
    padding:20px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15);
    z-index:100;
    display:none;
    overflow-y:auto;
    overflow-x:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    font-size:15px;
    line-height:1.6;
  }
  
  .annotation-box.custom-position{
    max-width:none;
  }
  
  .annotation-box.draggable{
    cursor:move;
    box-shadow:0 8px 24px rgba(0,0,0,0.2);
    z-index:10001;
  }
  
  .annotation-box.visible{
    display:block;
    animation:slideIn 0.3s ease-out;
  }
  
  .annotation-box.draggable .resize-handle{
    position:absolute;
    bottom:0;
    right:0;
    width:16px;
    height:16px;
    background:rgba(37, 99, 235, 0.3);
    cursor:nwse-resize;
    border-top-left-radius:4px;
    border-bottom-right-radius:12px;
  }
  
  .annotation-box.draggable .resize-handle::after{
    content:'‚ã∞';
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    color:rgba(37, 99, 235, 0.7);
    font-size:12px;
    line-height:1;
  }
  
  @keyframes slideIn{
    from{opacity:0;}
    to{opacity:1;}
  }
  
  .annotation-box h3{
    margin:0 0 12px;
    color:var(--accent);
    font-size:18px;
    line-height:1.3;
  }
  
  .annotation-box p{
    margin:0;
    line-height:inherit;
    font-size:inherit;
  }
  
  /* Timeline Editor */
  .timeline-container{
    background:#fff;
    border-top:2px solid #ddd;
    border-bottom:2px solid #ddd;
    padding:4px 20px 6px 20px;
    display:none;
    position:relative;
    margin-bottom:8px;
  }
  
  .timeline-container.visible{
    display:block;
  }
  
  .timeline-ruler{
    height:14px;
    position:relative;
    margin-bottom:0px;
    margin-left:60px;
    overflow:hidden;
  }
  
  .timeline-tick{
    position:absolute;
    top:0;
    font-size:8px;
    color:#999;
  }
  
  .timeline-track{
    height:26px;
    background:#fafafa;
    border:1px solid #ddd;
    border-radius:4px;
    position:relative;
    margin-bottom:2px;
    overflow:hidden;
    padding-left:60px;
  }
  
  .timeline-track-label{
    position:absolute;
    left:4px;
    top:50%;
    transform:translateY(-50%);
    font-size:11px;
    font-weight:600;
    color:#666;
    z-index:1;
  }
  
  .timeline-event{
    position:absolute;
    height:20px;
    top:3px;
    border-radius:3px;
    cursor:move;
    display:flex;
    align-items:center;
    padding:0 6px;
    font-size:10px;
    color:#fff;
    font-weight:600;
    white-space:nowrap;
    overflow:hidden;
    user-select:none;
  }
  
  .timeline-event.click{
    background:var(--accent);
    width:16px;
    min-width:16px;
    padding:0;
    justify-content:center;
  }
  
  .timeline-event.drag{
    background:var(--teal);
  }
  
  .timeline-event.annotation{
    background:var(--success);
    height:16px;
    top:5px;
  }
  
  .timeline-event.pause{
    background:var(--warning);
    width:16px;
    min-width:16px;
    padding:0;
    justify-content:center;
  }
  
  .timeline-event:hover{
    opacity:0.85;
    box-shadow:0 2px 4px rgba(0,0,0,0.2);
  }
  
  .timeline-event.dragging{
    opacity:0.7;
    z-index:1000;
  }
  
  .timeline-playhead{
    position:absolute;
    top:0;
    width:2px;
    height:100%;
    background:var(--record);
    pointer-events:none;
    z-index:10;
    display:none;
  }
  
  .timeline-playhead::before{
    content:'';
    position:absolute;
    top:-4px;
    left:-4px;
    width:10px;
    height:10px;
    background:var(--record);
    border-radius:50%;
  }
  
  /* Modals */
  .modal-overlay{
    display:none;
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.5);
    z-index:10000;
    align-items:center;
    justify-content:center;
  }
  
  .modal-overlay.visible{
    display:flex;
  }
  
  .modal-content{
    background:#fff;
    border-radius:12px;
    padding:24px;
    max-width:600px;
    width:90%;
    max-height:80vh;
    overflow-y:auto;
    box-shadow:0 20px 60px rgba(0,0,0,0.3);
  }
  
  .modal-content h2{
    margin:0 0 16px;
    color:var(--accent);
  }
  
  .modal-content h3{
    margin:20px 0 8px;
    color:#333;
    font-size:16px;
  }
  
  .modal-content p{
    margin:8px 0;
    line-height:1.6;
  }
  
  .modal-content ul{
    margin:8px 0;
    padding-left:24px;
  }
  
  .modal-content li{
    margin:4px 0;
    line-height:1.6;
  }
  
  .modal-actions{
    display:flex;
    gap:12px;
    margin-top:20px;
    justify-content:flex-end;
  }
  
  textarea{
    width:100%;
    min-height:300px;
    font-family:monospace;
    font-size:12px;
    padding:12px;
    border:1px solid #ddd;
    border-radius:6px;
    resize:vertical;
  }
  
  .stats{
    display:flex;
    gap:20px;
    margin:12px 0;
    padding:12px;
    background:#f9f9f9;
    border-radius:6px;
  }
  
  .stat{
    display:flex;
    flex-direction:column;
  }
  
  .stat-label{
    font-size:11px;
    color:#666;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }
  
  .stat-value{
    font-size:24px;
    font-weight:700;
    color:var(--accent);
  }
  
  .form-group{
    margin-bottom:16px;
  }
  
  .form-group label{
    display:block;
    margin-bottom:6px;
    font-weight:600;
    color:#333;
  }
  
  .form-group input[type="text"],
  .form-group input[type="number"],
  .form-group textarea{
    width:100%;
    padding:8px 12px;
    border:1px solid #ddd;
    border-radius:6px;
    font-size:14px;
    font-family:inherit;
  }
  
  .form-group textarea{
    min-height:100px;
    resize:vertical;
    font-family:inherit;
  }
  
  .form-group input[type="number"]{
    width:120px;
  }
  
  .inline-inputs{
    display:flex;
    gap:12px;
    align-items:center;
  }
  
  .inline-inputs .form-group{
    margin-bottom:0;
  }
  
  input[type="file"]{
    display:none;
  }
</style>
</head>
<body>

<div class="tutorial-header">
  <div>
    <span class="version-number">v12.61 - Annotation positioning fixed</span>
  </div>
  <div class="tutorial-controls">
    <input type="text" id="appUrl" placeholder="App URL" style="width:300px;padding:8px;border-radius:6px;border:1px solid #ddd;">
    <button id="loadApp" class="primary">Load App</button>
    <button id="startRecording" class="record" style="display:none">‚è∫ Start Recording</button>
    <button id="playPauseRecording" style="display:none">‚è∏ Pause</button>
    <span id="recordingIndicator" class="recording-indicator" style="display:none">‚óè REC</span>
    <span id="pausedIndicator" class="paused-indicator" style="display:none">‚è∏ PAUSED</span>
    <button id="addAnnotation" style="display:none" disabled>üí¨ Add Annotation</button>
    <button id="addAnnotationAtPause" style="display:none">üí¨ Add Annotation at Pause</button>
    <button id="addPause" style="display:none" disabled>‚è∏ Add Pause</button>
    <button id="previewRecording" style="display:none" disabled>‚ñ∂ Preview</button>
    <button id="recordAgain" style="display:none" disabled>üîÑ Record Again</button>
    <button id="exportRecording" style="display:none" disabled>üíæ Export</button>
    <button id="loadJSON" style="display:none">üìÇ Load JSON</button>
    <input type="file" id="jsonFileInput" accept=".json">
    <button id="helpBtn">‚ùì Help</button>
  </div>
</div>

<div class="app-container" id="appContainer">
  <iframe id="appFrame"></iframe>
  <div class="annotation-box" id="annotationBox"></div>
</div>

<div class="timeline-container" id="timelineContainer">
  <div class="timeline-ruler" id="timelineRuler"></div>
  <div class="timeline-playhead" id="timelinePlayhead"></div>
  <div class="timeline-track">
    <div class="timeline-track-label">Clicks</div>
  </div>
  <div class="timeline-track">
    <div class="timeline-track-label">Drags</div>
  </div>
  <div class="timeline-track">
    <div class="timeline-track-label">Annotations</div>
  </div>
  <div class="timeline-track">
    <div class="timeline-track-label">Pauses</div>
  </div>
</div>

<!-- Export Modal -->
<div class="modal-overlay" id="exportModal">
  <div class="modal-content">
    <h2>üì§ Export Tutorial</h2>
    <div class="stats">
      <div class="stat">
        <span class="stat-label">Snapshots</span>
        <span class="stat-value" id="snapshotCount">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Annotations</span>
        <span class="stat-value" id="annotationCount">0</span>
      </div>
    </div>
    <textarea id="exportTextarea" readonly></textarea>
    <div class="modal-actions">
      <button id="copyExport" class="success">üìã Copy to Clipboard</button>
      <button id="downloadExport" class="primary">üíæ Download JSON</button>
      <button id="closeExportModal">Close</button>
    </div>
  </div>
</div>

<!-- Annotation Editor Modal -->
<div class="modal-overlay" id="annotationEditorModal">
  <div class="modal-content">
    <h2>‚úèÔ∏è Edit Annotation</h2>
    <p style="margin-bottom:16px;color:#666;">Drag the blue box over the app to position it, then edit the content below.</p>
    
    <div class="form-group">
      <label>Title</label>
      <input type="text" id="annotationTitle" placeholder="Annotation title">
    </div>
    
    <div class="form-group">
      <label>Content (supports LaTeX: $x^2$ for inline, $$x^2$$ for display)</label>
      <textarea id="annotationContent" placeholder="Annotation content with optional $LaTeX$ math"></textarea>
    </div>
    
    <div class="inline-inputs">
      <div class="form-group">
        <label>Duration (seconds)</label>
        <input type="number" id="annotationDuration" value="5" min="0.5" step="0.5">
      </div>
    </div>
    
    <div class="modal-actions">
      <button id="saveAnnotationEdit" class="success">üíæ Save</button>
      <button id="deleteAnnotationEdit" class="record">üóëÔ∏è Delete</button>
      <button id="cancelAnnotationEdit">Cancel</button>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div class="modal-overlay" id="helpModal">
  <div class="modal-content">
    <h2>‚ùì Tutorial Creator Help</h2>
    
    <h3>üé¨ Recording a Tutorial</h3>
    <ol>
      <li>Enter your app's URL and click "Load App"</li>
      <li>Click "Start Recording" (red button)</li>
      <li>Interact with your app - all clicks and drags are captured</li>
      <li>Click "Pause" to pause recording</li>
      <li>Add annotations or pauses while paused</li>
      <li>Click "Record" again to resume</li>
      <li>When done, click "Export" to save your tutorial</li>
    </ol>
    
    <h3>üí¨ Adding Annotations</h3>
    <ul>
      <li>While paused, click "Add Annotation"</li>
      <li>Drag the blue box to position it over your app</li>
      <li>Enter title and content (supports LaTeX math)</li>
      <li>Set how long it should display (in seconds)</li>
      <li>Click "Save"</li>
    </ul>
    
    <h3>‚è∏ Adding Pauses</h3>
    <ul>
      <li>While paused, click "Add Pause"</li>
      <li>Pauses allow students to stop and read before continuing</li>
      <li>Tutorial will pause at that moment during playback</li>
    </ul>
    
    <h3>‚úèÔ∏è Editing in Timeline</h3>
    <ul>
      <li>Drag any event left/right to change its timing</li>
      <li>Drag annotation right edge to change duration</li>
      <li>Click annotation to edit its content and position</li>
      <li>Click pause or snapshot to delete it</li>
    </ul>
    
    <h3>‚ñ∂Ô∏è Preview & Export</h3>
    <ul>
      <li>Click "Preview" to watch your tutorial</li>
      <li>Use Play/Pause to control playback</li>
      <li>Click "Export" to save as JSON</li>
      <li>Load JSON later to continue editing</li>
    </ul>
    
    <div class="modal-actions">
      <button id="closeHelpModal" class="primary">Got it!</button>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';
  
  // ========== DOM ELEMENTS ==========
  
  const appUrl = document.getElementById('appUrl');
  const loadApp = document.getElementById('loadApp');
  const appFrame = document.getElementById('appFrame');
  const appContainer = document.getElementById('appContainer');
  const startRecording = document.getElementById('startRecording');
  const playPauseRecording = document.getElementById('playPauseRecording');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const pausedIndicator = document.getElementById('pausedIndicator');
  const addAnnotation = document.getElementById('addAnnotation');
  const addAnnotationAtPause = document.getElementById('addAnnotationAtPause');
  const addPause = document.getElementById('addPause');
  const previewRecording = document.getElementById('previewRecording');
  const recordAgain = document.getElementById('recordAgain');
  const exportRecording = document.getElementById('exportRecording');
  const loadJSON = document.getElementById('loadJSON');
  const jsonFileInput = document.getElementById('jsonFileInput');
  const helpBtn = document.getElementById('helpBtn');
  
  const annotationBox = document.getElementById('annotationBox');
  
  const exportModal = document.getElementById('exportModal');
  const exportTextarea = document.getElementById('exportTextarea');
  const snapshotCount = document.getElementById('snapshotCount');
  const annotationCount = document.getElementById('annotationCount');
  const copyExport = document.getElementById('copyExport');
  const downloadExport = document.getElementById('downloadExport');
  const closeExportModal = document.getElementById('closeExportModal');
  
  const annotationEditorModal = document.getElementById('annotationEditorModal');
  const annotationTitle = document.getElementById('annotationTitle');
  const annotationContent = document.getElementById('annotationContent');
  const annotationDuration = document.getElementById('annotationDuration');
  const saveAnnotationEdit = document.getElementById('saveAnnotationEdit');
  const deleteAnnotationEdit = document.getElementById('deleteAnnotationEdit');
  const cancelAnnotationEdit = document.getElementById('cancelAnnotationEdit');
  
  const helpModal = document.getElementById('helpModal');
  const closeHelpModal = document.getElementById('closeHelpModal');
  
  const timelineContainer = document.getElementById('timelineContainer');
  const timelineRuler = document.getElementById('timelineRuler');
  const timelinePlayhead = document.getElementById('timelinePlayhead');
  const timelineTracks = document.querySelectorAll('.timeline-track');
  
  // ========== STATE ==========
  
  let isAppLoaded = false;
  let isRecording = false;
  let isPaused = false;
  let recordingStartTime = 0;
  let pauseStartTime = 0;
  let totalPausedTime = 0;
  let importedDurationOffset = 0;
  
  let currentTutorial = null;
  let eventListener = null;
  
  let isPlaying = false;
  let playbackStartTime = 0;
  let playbackPosition = 0;
  let playbackTimer = null;
  let currentAnnotationTimeout = null;
  let currentPauseTimeout = null;
  
  let editingAnnotation = null;
  let isDraggingAnnotation = false;
  let isResizingAnnotation = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let resizeStartX = 0;
  let resizeStartY = 0;
  let resizeStartWidth = 0;
  let resizeStartHeight = 0;
  
  let isDraggingTimelineEvent = false;
  let draggedTimelineEvent = null;
  let draggedEventType = null;
  let draggedEventIndex = null;
  let timelineScale = 50;
  
  // ========== IFRAME API ==========
  
  function getAPI() {
    try {
      return appFrame.contentWindow.tutorialAPI;
    } catch (e) {
      return null;
    }
  }
  
  // ========== APP LOADING ==========
  
  loadApp.addEventListener('click', () => {
    const url = appUrl.value.trim();
    if (!url) {
      alert('Please enter an app URL');
      return;
    }
    
    appFrame.src = url;
    
    appFrame.onload = () => {
      console.log('üì± App loaded');
      
      setTimeout(() => {
        const api = getAPI();
        if (api) {
          console.log('‚úì Tutorial API detected');
          isAppLoaded = true;
          startRecording.style.display = 'inline-block';
          loadJSON.style.display = 'inline-block';
        } else {
          console.log('‚ö† No tutorial API found');
          alert('Warning: App does not have tutorial API.\nMake sure the app includes the tutorial API code.');
        }
      }, 500);
    };
  });
  
  // ========== RECORDING ==========
  
  startRecording.addEventListener('click', () => {
    if (!isAppLoaded) return;
    
    const api = getAPI();
    if (!api) {
      alert('Tutorial API not available');
      return;
    }
    
    if (!isRecording) {
      // Start new recording
      currentTutorial = {
        initialState: api.getState(),
        snapshots: [],
        annotations: [],
        pauses: [],
        duration: 0
      };
      
      isRecording = true;
      isPaused = false;
      recordingStartTime = Date.now();
      totalPausedTime = 0;
      importedDurationOffset = 0;
      
      eventListener = (event) => {
        const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
        const snapshot = {
          timestamp: timestamp,
          event: event,
          state: api.getState()
        };
        currentTutorial.snapshots.push(snapshot);
        renderTimeline();
      };
      
      api.onAction(eventListener);
      
      startRecording.textContent = '‚è∫ Recording...';
      startRecording.classList.add('recording-active');
      playPauseRecording.style.display = 'inline-block';
      playPauseRecording.textContent = '‚è∏ Pause';
      recordingIndicator.style.display = 'inline-block';
      pausedIndicator.style.display = 'none';
      loadJSON.style.display = 'none';
      
      renderTimeline();
      
      console.log('üé¨ Recording started');
    } else if (isPaused) {
      // Resume recording
      isPaused = false;
      const pauseDuration = Date.now() - pauseStartTime;
      totalPausedTime += pauseDuration;
      
      startRecording.textContent = '‚è∫ Recording...';
      startRecording.classList.add('recording-active');
      playPauseRecording.style.display = 'inline-block';
      playPauseRecording.textContent = '‚è∏ Pause';
      recordingIndicator.style.display = 'inline-block';
      pausedIndicator.style.display = 'none';
      addAnnotation.style.display = 'none';
      addAnnotationAtPause.style.display = 'none';
      addPause.style.display = 'none';
      previewRecording.style.display = 'none';
      recordAgain.style.display = 'none';
      exportRecording.style.display = 'none';
      
      console.log('‚ñ∂Ô∏è Recording resumed');
    }
  });
  
  playPauseRecording.addEventListener('click', () => {
    if (!isRecording || isPaused) return;
    
    // Pause recording
    isPaused = true;
    pauseStartTime = Date.now();
    
    startRecording.textContent = '‚è∫ Record';
    startRecording.classList.remove('recording-active');
    startRecording.className = 'record';
    playPauseRecording.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    addAnnotation.style.display = 'inline-block';
    addAnnotation.disabled = false;
    addAnnotationAtPause.style.display = 'none';
    addPause.style.display = 'inline-block';
    addPause.disabled = false;
    previewRecording.style.display = 'inline-block';
    previewRecording.disabled = false;
    recordAgain.style.display = 'inline-block';
    recordAgain.disabled = false;
    exportRecording.style.display = 'inline-block';
    exportRecording.disabled = false;
    
    recalculateDuration();
    renderTimeline();
    
    console.log('‚è∏ Recording paused');
  });
  
  recordAgain.addEventListener('click', () => {
    if (!confirm('This will discard the current recording. Continue?')) {
      return;
    }
    
    const api = getAPI();
    if (api && eventListener) {
      api.offAction(eventListener);
    }
    
    isRecording = false;
    isPaused = false;
    currentTutorial = null;
    
    startRecording.style.display = 'inline-block';
    startRecording.textContent = '‚è∫ Start Recording';
    startRecording.className = 'record';
    playPauseRecording.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    addAnnotation.style.display = 'none';
    addAnnotationAtPause.style.display = 'none';
    addPause.style.display = 'none';
    previewRecording.style.display = 'none';
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
    loadJSON.style.display = 'inline-block';
    timelineContainer.classList.remove('visible');
    
    console.log('üîÑ Ready for new recording');
  });
  
  // ========== ANNOTATION SYSTEM ==========
  
  addAnnotation.addEventListener('click', () => {
    if (!currentTutorial || !isPaused) return;
    
    const currentTime = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
    
    const annotation = {
      timestamp: currentTime,
      duration: 5000,
      title: 'New Annotation',
      content: 'Enter your annotation text here. You can use $LaTeX$ math notation.',
      position: null
    };
    
    currentTutorial.annotations.push(annotation);
    editingAnnotation = annotation;
    
    openAnnotationEditor(annotation);
    renderTimeline();
  });
  
  addAnnotationAtPause.addEventListener('click', () => {
    if (!currentTutorial || !isPlaying) return;
    
    const annotation = {
      timestamp: playbackPosition,
      duration: 5000,
      title: 'New Annotation',
      content: 'Enter your annotation text here. You can use $LaTeX$ math notation.',
      position: null
    };
    
    currentTutorial.annotations.push(annotation);
    editingAnnotation = annotation;
    
    openAnnotationEditor(annotation);
    renderTimeline();
  });
  
  function openAnnotationEditor(annotation) {
    annotationTitle.value = annotation.title || '';
    annotationContent.value = annotation.content || '';
    annotationDuration.value = (annotation.duration || 5000) / 1000;
    
    // Show annotation box in draggable mode
    annotationBox.innerHTML = `
      <h3>${annotation.title || 'New Annotation'}</h3>
      <p>${annotation.content || 'Content'}</p>
      <div class="resize-handle"></div>
    `;
    
    // Position annotation - use stored position relative to app container
    const containerRect = appContainer.getBoundingClientRect();
    
    if (annotation.position) {
      // Convert relative position to absolute viewport position
      annotationBox.style.left = (containerRect.left + annotation.position.left) + 'px';
      annotationBox.style.top = (containerRect.top + annotation.position.top) + 'px';
      annotationBox.style.width = annotation.position.width + 'px';
      annotationBox.style.height = annotation.position.height + 'px';
    } else {
      // Default position (centered in app container)
      annotationBox.style.left = (containerRect.left + 50) + 'px';
      annotationBox.style.top = (containerRect.top + 50) + 'px';
      annotationBox.style.width = '250px';
      annotationBox.style.height = 'auto';
    }
    
    annotationBox.classList.add('visible', 'draggable', 'custom-position');
    
    // Set up drag and resize handlers
    setupAnnotationDragAndResize();
    
    annotationEditorModal.classList.add('visible');
    
    console.log('‚úèÔ∏è Editing annotation at', annotation.timestamp + 'ms');
  }
  
  function setupAnnotationDragAndResize() {
    const resizeHandle = annotationBox.querySelector('.resize-handle');
    
    function startAnnotationDrag(e) {
      if (e.target === resizeHandle) return;
      e.preventDefault();
      isDraggingAnnotation = true;
      const rect = annotationBox.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      annotationBox.style.cursor = 'grabbing';
    }
    
    function startAnnotationResize(e) {
      e.preventDefault();
      e.stopPropagation();
      isResizingAnnotation = true;
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      resizeStartWidth = annotationBox.offsetWidth;
      resizeStartHeight = annotationBox.offsetHeight;
    }
    
    function dragAnnotation(e) {
      if (!isDraggingAnnotation) return;
      
      const newLeft = e.clientX - dragOffsetX;
      const newTop = e.clientY - dragOffsetY;
      
      annotationBox.style.left = newLeft + 'px';
      annotationBox.style.top = newTop + 'px';
    }
    
    function resizeAnnotation(e) {
      if (!isResizingAnnotation) return;
      
      const deltaX = e.clientX - resizeStartX;
      const deltaY = e.clientY - resizeStartY;
      
      const newWidth = Math.max(200, resizeStartWidth + deltaX);
      const newHeight = Math.max(100, resizeStartHeight + deltaY);
      
      annotationBox.style.width = newWidth + 'px';
      annotationBox.style.height = newHeight + 'px';
    }
    
    function stopDragAndResize() {
      isDraggingAnnotation = false;
      isResizingAnnotation = false;
      annotationBox.style.cursor = 'move';
    }
    
    annotationBox.addEventListener('mousedown', startAnnotationDrag);
    if (resizeHandle) {
      resizeHandle.addEventListener('mousedown', startAnnotationResize);
    }
    document.addEventListener('mousemove', dragAnnotation);
    document.addEventListener('mousemove', resizeAnnotation);
    document.addEventListener('mouseup', stopDragAndResize);
  }
  
  saveAnnotationEdit.addEventListener('click', () => {
    if (!editingAnnotation) return;
    
    editingAnnotation.title = annotationTitle.value || 'Annotation';
    editingAnnotation.content = annotationContent.value || '';
    editingAnnotation.duration = parseFloat(annotationDuration.value) * 1000;
    
    // Save position RELATIVE to app container
    const containerRect = appContainer.getBoundingClientRect();
    const boxRect = annotationBox.getBoundingClientRect();
    
    const position = {
      left: boxRect.left - containerRect.left,
      top: boxRect.top - containerRect.top,
      width: annotationBox.offsetWidth,
      height: annotationBox.offsetHeight
    };
    
    editingAnnotation.position = position;
    
    console.log('üíæ Saved annotation position relative to container:', position);
    
    closeAnnotationEditor();
    recalculateDuration();
    renderTimeline();
  });
  
  deleteAnnotationEdit.addEventListener('click', () => {
    if (!editingAnnotation || !currentTutorial) return;
    
    if (!confirm('Delete this annotation?')) return;
    
    const index = currentTutorial.annotations.indexOf(editingAnnotation);
    if (index > -1) {
      currentTutorial.annotations.splice(index, 1);
    }
    
    closeAnnotationEditor();
    recalculateDuration();
    renderTimeline();
  });
  
  cancelAnnotationEdit.addEventListener('click', () => {
    // If this is a new annotation with no position, remove it
    if (editingAnnotation && !editingAnnotation.position) {
      const index = currentTutorial.annotations.indexOf(editingAnnotation);
      if (index > -1) {
        currentTutorial.annotations.splice(index, 1);
      }
    }
    
    closeAnnotationEditor();
    renderTimeline();
  });
  
  function closeAnnotationEditor() {
    annotationBox.classList.remove('visible', 'draggable', 'custom-position');
    annotationEditorModal.classList.remove('visible');
    editingAnnotation = null;
  }
  
  function showAnnotation(annotation) {
    // Position annotation using stored position RELATIVE to app container
    const containerRect = appContainer.getBoundingClientRect();
    
    annotationBox.innerHTML = `
      <h3>${annotation.title}</h3>
      <p>${annotation.content}</p>
    `;
    
    if (annotation.position) {
      // Convert relative position to absolute viewport position
      annotationBox.style.left = (containerRect.left + annotation.position.left) + 'px';
      annotationBox.style.top = (containerRect.top + annotation.position.top) + 'px';
      annotationBox.style.width = annotation.position.width + 'px';
      annotationBox.style.height = annotation.position.height + 'px';
      annotationBox.classList.add('custom-position');
    } else {
      // Default position (centered in app container)
      annotationBox.style.left = (containerRect.left + 50) + 'px';
      annotationBox.style.top = (containerRect.top + 50) + 'px';
      annotationBox.style.width = '250px';
      annotationBox.style.height = 'auto';
      annotationBox.classList.remove('custom-position');
    }
    
    annotationBox.classList.add('visible');
    annotationBox.classList.remove('draggable');
    
    if (window.MathJax && window.MathJax.typesetPromise) {
      window.MathJax.typesetPromise([annotationBox]).catch((err) => {
        console.warn('MathJax typeset error:', err);
      });
    }
  }
  
  function hideAnnotation() {
    annotationBox.classList.remove('visible');
  }
  
  // ========== PAUSE SYSTEM ==========
  
  addPause.addEventListener('click', () => {
    if (!currentTutorial || !isPaused) return;
    
    const currentTime = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
    
    currentTutorial.pauses.push({
      timestamp: currentTime
    });
    
    recalculateDuration();
    renderTimeline();
    
    console.log('‚è∏ Pause added at', currentTime + 'ms');
  });
  
  // ========== PLAYBACK ==========
  
  previewRecording.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    if (!isPlaying) {
      startPlayback();
    } else {
      pausePlayback();
    }
  });
  
  function startPlayback() {
    const api = getAPI();
    if (!api) return;
    
    if (playbackPosition === 0) {
      api.setState(currentTutorial.initialState);
    }
    
    isPlaying = true;
    playbackStartTime = Date.now() - playbackPosition;
    
    appFrame.classList.add('playback-mode');
    previewRecording.textContent = '‚è∏ Pause';
    previewRecording.classList.add('playing');
    addAnnotation.disabled = true;
    addAnnotationAtPause.style.display = 'none';
    addPause.disabled = true;
    recordAgain.disabled = true;
    exportRecording.disabled = true;
    startRecording.disabled = true;
    
    timelinePlayhead.style.display = 'block';
    
    scheduleNextEvents();
    updatePlayback();
    
    console.log('‚ñ∂Ô∏è Playback started from', playbackPosition + 'ms');
  }
  
  function pausePlayback() {
    isPlaying = false;
    playbackPosition = Date.now() - playbackStartTime;
    
    if (playbackTimer) {
      cancelAnimationFrame(playbackTimer);
      playbackTimer = null;
    }
    
    if (currentAnnotationTimeout) {
      clearTimeout(currentAnnotationTimeout);
      currentAnnotationTimeout = null;
    }
    
    if (currentPauseTimeout) {
      clearTimeout(currentPauseTimeout);
      currentPauseTimeout = null;
    }
    
    appFrame.classList.remove('playback-mode');
    previewRecording.textContent = '‚ñ∂ Resume';
    previewRecording.classList.remove('playing');
    addAnnotation.disabled = false;
    addAnnotationAtPause.style.display = 'inline-block';
    addPause.disabled = false;
    recordAgain.disabled = false;
    exportRecording.disabled = false;
    startRecording.disabled = false;
    
    console.log('‚è∏ Playback paused at', playbackPosition + 'ms');
  }
  
  function stopPlayback() {
    isPlaying = false;
    playbackPosition = 0;
    
    if (playbackTimer) {
      cancelAnimationFrame(playbackTimer);
      playbackTimer = null;
    }
    
    if (currentAnnotationTimeout) {
      clearTimeout(currentAnnotationTimeout);
      currentAnnotationTimeout = null;
    }
    
    if (currentPauseTimeout) {
      clearTimeout(currentPauseTimeout);
      currentPauseTimeout = null;
    }
    
    hideAnnotation();
    
    appFrame.classList.remove('playback-mode');
    previewRecording.textContent = '‚ñ∂ Preview';
    previewRecording.classList.remove('playing');
    addAnnotation.disabled = false;
    addAnnotationAtPause.style.display = 'none';
    addPause.disabled = false;
    recordAgain.disabled = false;
    exportRecording.disabled = false;
    startRecording.disabled = false;
    
    const timelineStartOffset = getTimelineStartOffset();
    timelinePlayhead.style.left = (60 - (timelineStartOffset / 1000) * timelineScale) + 'px';
    
    console.log('‚èπ Playback stopped');
  }
  
  function scheduleNextEvents() {
    if (!isPlaying) return;
    
    const currentTime = Date.now() - playbackStartTime;
    
    // Schedule next snapshot
    const nextSnapshot = currentTutorial.snapshots.find(s => s.timestamp > currentTime);
    if (nextSnapshot) {
      const delay = nextSnapshot.timestamp - currentTime;
      setTimeout(() => {
        if (!isPlaying) return;
        const api = getAPI();
        if (api) {
          api.setState(nextSnapshot.state);
        }
        scheduleNextEvents();
      }, delay);
    }
    
    // Schedule next annotation
    const nextAnnotation = currentTutorial.annotations.find(a => 
      a.timestamp > currentTime && a.timestamp <= currentTime + 100
    );
    if (nextAnnotation) {
      const delay = nextAnnotation.timestamp - currentTime;
      currentAnnotationTimeout = setTimeout(() => {
        if (!isPlaying) return;
        showAnnotation(nextAnnotation);
        
        // Hide after duration
        setTimeout(() => {
          if (!isPlaying) return;
          hideAnnotation();
        }, nextAnnotation.duration);
      }, delay);
    }
    
    // Schedule next pause
    const nextPause = currentTutorial.pauses?.find(p => 
      p.timestamp > currentTime && p.timestamp <= currentTime + 100
    );
    if (nextPause) {
      const delay = nextPause.timestamp - currentTime;
      currentPauseTimeout = setTimeout(() => {
        if (!isPlaying) return;
        pausePlayback();
        console.log('‚è∏ Auto-paused at', nextPause.timestamp + 'ms');
      }, delay);
    }
    
    // Check if playback complete
    if (currentTime >= currentTutorial.duration) {
      stopPlayback();
    }
  }
  
  function updatePlayback() {
    if (!isPlaying) return;
    
    playbackPosition = Date.now() - playbackStartTime;
    
    // Update playhead position
    const timelineStartOffset = getTimelineStartOffset();
    const playheadPosition = ((playbackPosition - timelineStartOffset) / 1000) * timelineScale + 60;
    timelinePlayhead.style.left = playheadPosition + 'px';
    
    if (playbackPosition >= currentTutorial.duration) {
      stopPlayback();
      return;
    }
    
    playbackTimer = requestAnimationFrame(updatePlayback);
  }
  
  // ========== TIMELINE RENDERING ==========
  
  function getTimelineStartOffset() {
    if (!currentTutorial) return 0;
    
    let minTime = Infinity;
    
    if (currentTutorial.snapshots.length > 0) {
      minTime = Math.min(minTime, currentTutorial.snapshots[0].timestamp);
    }
    
    if (currentTutorial.annotations.length > 0) {
      minTime = Math.min(minTime, ...currentTutorial.annotations.map(a => a.timestamp));
    }
    
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      minTime = Math.min(minTime, ...currentTutorial.pauses.map(p => p.timestamp));
    }
    
    return minTime === Infinity ? 0 : minTime;
  }
  
  function renderTimeline() {
    if (!currentTutorial) {
      timelineContainer.classList.remove('visible');
      return;
    }
    
    timelineContainer.classList.add('visible');
    
    const timelineStartOffset = getTimelineStartOffset();
    const durationSeconds = (currentTutorial.duration - timelineStartOffset) / 1000;
    
    // Calculate scale
    const containerWidth = timelineContainer.offsetWidth || 1200;
    const availableWidth = containerWidth - 80;
    const minScale = 20;
    const maxScale = 100;
    
    if (durationSeconds > 0) {
      const calculatedScale = availableWidth / durationSeconds;
      timelineScale = Math.max(minScale, Math.min(maxScale, calculatedScale));
    } else {
      timelineScale = 50;
    }
    
    // Render ruler
    renderTimelineRuler(timelineStartOffset, durationSeconds);
    
    // Render events
    renderTimelineEvents(timelineStartOffset);
  }
  
  function renderTimelineRuler(startOffset, durationSeconds) {
    timelineRuler.innerHTML = '';
    
    const tickInterval = durationSeconds > 30 ? 5 : durationSeconds > 10 ? 2 : 1;
    
    for (let i = 0; i <= Math.ceil(durationSeconds); i += tickInterval) {
      const tick = document.createElement('div');
      tick.className = 'timeline-tick';
      tick.style.left = (i * timelineScale) + 'px';
      tick.textContent = i + 's';
      timelineRuler.appendChild(tick);
    }
  }
  
  function renderTimelineEvents(timelineStartOffset) {
    const tracks = timelineContainer.querySelectorAll('.timeline-track');
    const [clickTrack, dragTrack, annotationTrack, pauseTrack] = tracks;
    
    // Clear existing events
    tracks.forEach(track => {
      Array.from(track.children).forEach(child => {
        if (child.classList.contains('timeline-event')) {
          child.remove();
        }
      });
    });
    
    // Render snapshots
    currentTutorial.snapshots.forEach((snapshot, index) => {
      const relativeTime = snapshot.timestamp - timelineStartOffset;
      const position = (relativeTime / 1000) * timelineScale;
      
      const event = document.createElement('div');
      event.className = 'timeline-event';
      event.style.left = position + 'px';
      
      if (snapshot.event.type === 'click') {
        event.classList.add('click');
        event.textContent = '‚óè';
        event.title = 'Click at ' + (snapshot.timestamp / 1000).toFixed(2) + 's';
        clickTrack.appendChild(event);
      } else if (snapshot.event.type === 'dragStart' || snapshot.event.type === 'dragMove' || snapshot.event.type === 'dragEnd') {
        // Find drag sequence
        if (snapshot.event.type === 'dragStart') {
          let dragEnd = currentTutorial.snapshots.slice(index + 1).find(s => s.event.type === 'dragEnd');
          if (!dragEnd) {
            dragEnd = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          }
          
          const dragEndTime = dragEnd.timestamp - timelineStartOffset;
          const dragEndPosition = (dragEndTime / 1000) * timelineScale;
          const width = Math.max(20, dragEndPosition - position);
          
          event.classList.add('drag');
          event.style.width = width + 'px';
          event.textContent = 'Drag';
          event.title = 'Drag from ' + (snapshot.timestamp / 1000).toFixed(2) + 's';
          dragTrack.appendChild(event);
        }
      }
      
      // Click handler for deletion
      event.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm('Delete this event?')) {
          currentTutorial.snapshots.splice(index, 1);
          recalculateDuration();
          renderTimeline();
        }
      });
      
      // Drag handler
      event.addEventListener('mousedown', (e) => startTimelineDrag(e, 'snapshot', index));
    });
    
    // Render annotations
    currentTutorial.annotations.forEach((annotation, index) => {
      const relativeTime = annotation.timestamp - timelineStartOffset;
      const position = (relativeTime / 1000) * timelineScale;
      const width = Math.max(20, (annotation.duration / 1000) * timelineScale);
      
      const event = document.createElement('div');
      event.className = 'timeline-event annotation';
      event.style.left = position + 'px';
      event.style.width = width + 'px';
      event.textContent = annotation.title || 'Note';
      event.title = annotation.title + ' at ' + (annotation.timestamp / 1000).toFixed(2) + 's';
      annotationTrack.appendChild(event);
      
      // Click handler for editing
      event.addEventListener('click', (e) => {
        e.stopPropagation();
        editingAnnotation = annotation;
        openAnnotationEditor(annotation);
      });
      
      // Drag handler
      event.addEventListener('mousedown', (e) => startTimelineDrag(e, 'annotation', index));
    });
    
    // Render pauses
    if (currentTutorial.pauses) {
      currentTutorial.pauses.forEach((pause, index) => {
        const relativeTime = pause.timestamp - timelineStartOffset;
        const position = (relativeTime / 1000) * timelineScale;
        
        const event = document.createElement('div');
        event.className = 'timeline-event pause';
        event.style.left = position + 'px';
        event.textContent = '‚è∏';
        event.title = 'Pause at ' + (pause.timestamp / 1000).toFixed(2) + 's';
        pauseTrack.appendChild(event);
        
        // Click handler for deletion
        event.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('Delete this pause?')) {
            currentTutorial.pauses.splice(index, 1);
            recalculateDuration();
            renderTimeline();
          }
        });
        
        // Drag handler
        event.addEventListener('mousedown', (e) => startTimelineDrag(e, 'pause', index));
      });
    }
  }
  
  // ========== TIMELINE DRAGGING ==========
  
  function startTimelineDrag(e, eventType, eventIndex) {
    e.preventDefault();
    e.stopPropagation();
    
    isDraggingTimelineEvent = true;
    draggedEventType = eventType;
    draggedEventIndex = eventIndex;
    draggedTimelineEvent = e.target;
    
    draggedTimelineEvent.classList.add('dragging');
    
    document.addEventListener('mousemove', dragTimelineEvent);
    document.addEventListener('mouseup', stopTimelineDrag);
  }
  
  function dragTimelineEvent(e) {
    if (!isDraggingTimelineEvent) return;
    
    const trackRect = draggedTimelineEvent.parentElement.getBoundingClientRect();
    const relativeX = e.clientX - trackRect.left - 60;
    const newPosition = Math.max(0, relativeX);
    
    draggedTimelineEvent.style.left = newPosition + 'px';
  }
  
  function stopTimelineDrag(e) {
    if (!isDraggingTimelineEvent) return;
    
    const trackRect = draggedTimelineEvent.parentElement.getBoundingClientRect();
    const relativeX = e.clientX - trackRect.left - 60;
    const newTimeSeconds = Math.max(0, relativeX / timelineScale);
    const timelineStartOffset = getTimelineStartOffset();
    const newTimestamp = (newTimeSeconds * 1000) + timelineStartOffset;
    
    // Update the event timestamp
    if (draggedEventType === 'snapshot') {
      currentTutorial.snapshots[draggedEventIndex].timestamp = newTimestamp;
    } else if (draggedEventType === 'annotation') {
      currentTutorial.annotations[draggedEventIndex].timestamp = newTimestamp;
    } else if (draggedEventType === 'pause') {
      currentTutorial.pauses[draggedEventIndex].timestamp = newTimestamp;
    }
    
    draggedTimelineEvent.classList.remove('dragging');
    
    isDraggingTimelineEvent = false;
    draggedTimelineEvent = null;
    draggedEventType = null;
    draggedEventIndex = null;
    
    document.removeEventListener('mousemove', dragTimelineEvent);
    document.removeEventListener('mouseup', stopTimelineDrag);
    
    recalculateDuration();
    renderTimeline();
  }
  
  // ========== DURATION CALCULATION ==========
  
  function recalculateDuration() {
    if (!currentTutorial) return;
    
    // Get last snapshot time
    let lastSnapshotTime = 0;
    let lastSnapshotIsSingleEvent = false;
    if (currentTutorial.snapshots.length > 0) {
      const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
      lastSnapshotTime = lastSnapshot.timestamp;
      lastSnapshotIsSingleEvent = (lastSnapshot.event.type === 'click');
    }
    
    // Get last annotation end time
    let lastAnnotationEnd = 0;
    if (currentTutorial.annotations.length > 0) {
      lastAnnotationEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
    }
    
    // Get last pause time
    let lastPauseTime = 0;
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      lastPauseTime = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
    }
    
    // Determine which element is chronologically last
    let calculatedDuration = 0;
    let durationSource = 'none';
    let lastElementType = 'none';
    
    const maxTime = Math.max(lastSnapshotTime, lastAnnotationEnd, lastPauseTime);
    
    if (maxTime === 0) {
      calculatedDuration = 0;
      durationSource = 'none';
      lastElementType = 'none';
    } else if (maxTime === lastPauseTime && lastPauseTime > 0) {
      // Pause is chronologically last
      calculatedDuration = lastPauseTime;
      durationSource = 'pause';
      lastElementType = 'pause';
    } else if (maxTime === lastAnnotationEnd) {
      // Annotation extends furthest
      calculatedDuration = lastAnnotationEnd;
      durationSource = 'annotation';
      lastElementType = 'annotation';
    } else {
      // Snapshot is last
      calculatedDuration = lastSnapshotTime;
      durationSource = 'snapshot';
      lastElementType = lastSnapshotIsSingleEvent ? 'singleEvent' : 'dragEvent';
    }
    
    // Add pixel-based buffers for visual alignment
    // Must iterate because adding buffer changes scale, which changes buffer amount
    // Only add buffer for click events (single events), NOT for pauses
    if (lastElementType === 'singleEvent') {
      const containerWidth = timelineContainer.offsetWidth || 1200;
      const availableWidth = containerWidth - 80;
      const minScale = 20;
      const maxScale = 100;
      
      // Iterate to find stable buffer (scale depends on duration, buffer depends on scale)
      let iterDuration = calculatedDuration;
      let iterScale = 50; // Initial guess
      for (let iteration = 0; iteration < 5; iteration++) {
        // Calculate what scale will be for this duration
        const durationSeconds = (iterDuration - getTimelineStartOffset()) / 1000;
        if (durationSeconds > 0) {
          const calculatedScale = availableWidth / durationSeconds;
          iterScale = Math.max(minScale, Math.min(maxScale, calculatedScale));
        }
        
        // Calculate buffer using this scale
        let bufferPixels = 26; // Click events only - empirically calibrated
        
        const bufferMs = (bufferPixels / iterScale) * 1000;
        const newDuration = calculatedDuration + bufferMs;
        
        // Check convergence
        if (Math.abs(newDuration - iterDuration) < 1) {
          iterDuration = newDuration;
          break;
        }
        
        iterDuration = newDuration;
      }
      
      calculatedDuration = iterDuration;
      console.log('üìä Added buffer for', lastElementType, ':', ((calculatedDuration - lastSnapshotTime) / 1000).toFixed(3) + 's');
    }
    
    currentTutorial.duration = calculatedDuration;
    console.log('üìä Duration recalculated:', (calculatedDuration / 1000).toFixed(2) + 's');
    console.log('  Last snapshot:', (lastSnapshotTime / 1000).toFixed(2) + 's');
    console.log('  Last annotation end:', (lastAnnotationEnd / 1000).toFixed(2) + 's');
    console.log('  Last pause:', (lastPauseTime / 1000).toFixed(2) + 's');
    console.log('  Duration determined by:', durationSource);
  }
  
  // ========== ANNOTATION EDITING ==========
  
  // ========== EXPORT/IMPORT ==========
  
  exportRecording.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Don't finalize - just export the current state
    // User can continue recording after exporting
    
    snapshotCount.textContent = currentTutorial.snapshots.length;
    annotationCount.textContent = currentTutorial.annotations.length;
    exportTextarea.value = JSON.stringify(currentTutorial, null, 2);
    exportModal.classList.add('visible');
  });
  
  downloadExport.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    const jsonStr = JSON.stringify(currentTutorial, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tutorial-' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    downloadExport.textContent = '‚úì Downloaded!';
    setTimeout(() => {
      downloadExport.textContent = 'üíæ Download JSON';
    }, 2000);
  });
  
  copyExport.addEventListener('click', () => {
    exportTextarea.select();
    document.execCommand('copy');
    copyExport.textContent = '‚úì Copied!';
    setTimeout(() => {
      copyExport.textContent = 'üìã Copy to Clipboard';
    }, 2000);
  });
  
  closeExportModal.addEventListener('click', () => {
    exportModal.classList.remove('visible');
  });
  
  loadJSON.addEventListener('click', () => {
    jsonFileInput.click();
  });
  
  jsonFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const imported = JSON.parse(event.target.result);
        
        if (!imported.initialState || !imported.snapshots || !imported.annotations) {
          throw new Error('Invalid tutorial format');
        }
        
        // Backward compatibility: add pauses array if it doesn't exist
        if (!imported.pauses) {
          imported.pauses = [];
        }
        
        currentTutorial = imported;
        
        console.log('üì§ Tutorial imported successfully');
        console.log('  Snapshots:', currentTutorial.snapshots.length);
        console.log('  Annotations:', currentTutorial.annotations.length);
        console.log('  Pauses:', currentTutorial.pauses ? currentTutorial.pauses.length : 0);
        if (currentTutorial.annotations.length > 0) {
          console.log('  Annotation details:', currentTutorial.annotations.map(a => 
            `"${a.title}" at ${a.timestamp}ms for ${a.duration}ms`
          ));
        }
        
        // Load the app if not already loaded
        if (!isAppLoaded && imported.initialState) {
          // We can't auto-load without a URL, so just inform user
          alert('Tutorial loaded! Please load the app first using "Load App", then the tutorial will be ready to edit.');
        } else if (isAppLoaded) {
          const api = getAPI();
          if (api) {
            // Apply the last snapshot's state instead of initial state
            // This shows the final state with all settings that were active at the end
            if (currentTutorial.snapshots.length > 0) {
              const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
              api.setState(lastSnapshot.state);
            } else {
              api.setState(currentTutorial.initialState);
            }
          }
          
          // Set up recording state as if we just paused
          isRecording = true;
          isPaused = true;
          recordingStartTime = Date.now(); // Start recording from NOW
          pauseStartTime = Date.now(); // Set pause start time for correct resume calculation
          totalPausedTime = 0;
          importedDurationOffset = currentTutorial.duration || 0; // Offset new events by imported duration
          
          // Set up event listener (so we can continue recording)
          eventListener = (event) => {
            const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
            const snapshot = {
              timestamp: timestamp,
              event: event,
              state: api.getState()
            };
            currentTutorial.snapshots.push(snapshot);
            renderTimeline();
          };
          api.onAction(eventListener);
          
          // Show paused recording UI
          startRecording.style.display = 'inline-block';
          startRecording.textContent = '‚è∫ Record';
          startRecording.classList.remove('recording-active');
          startRecording.className = 'record';
          loadJSON.style.display = 'none';
          playPauseRecording.style.display = 'none';
          recordingIndicator.style.display = 'none';
          pausedIndicator.style.display = 'none';
          addAnnotation.style.display = 'inline-block';
          addAnnotation.disabled = false;
          addAnnotationAtPause.style.display = 'none';
          addPause.style.display = 'inline-block';
          addPause.disabled = false;
          previewRecording.style.display = 'inline-block';
          previewRecording.disabled = false;
          recordAgain.style.display = 'inline-block';
          recordAgain.disabled = false;
          exportRecording.style.display = 'inline-block';
          exportRecording.disabled = false;
          
          renderTimeline();
          
          // Position playhead at the end of the imported tutorial
          const timelineStartOffset = getTimelineStartOffset();
          const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
          timelinePlayhead.style.left = timelineEndPosition + 'px';
          timelinePlayhead.style.display = 'block';
          
          alert('‚úì Tutorial loaded!\n\nYou can now:\n‚Ä¢ Preview it\n‚Ä¢ Resume recording to add more\n‚Ä¢ Add/edit annotations\n‚Ä¢ Export when done');
        }
        
        console.log('üì§ Tutorial imported');
      } catch (err) {
        alert('Error importing tutorial: ' + err.message);
        console.error('Import error:', err);
      }
    };
    
    reader.readAsText(file);
    jsonFileInput.value = '';
  });
  
  // ========== HELP ==========
  
  helpBtn.addEventListener('click', () => {
    helpModal.classList.add('visible');
  });
  
  closeHelpModal.addEventListener('click', () => {
    helpModal.classList.remove('visible');
  });
  
  helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
      helpModal.classList.remove('visible');
    }
  });
  
  exportModal.addEventListener('click', (e) => {
    if (e.target === exportModal) {
      exportModal.classList.remove('visible');
    }
  });
  
  annotationEditorModal.addEventListener('click', (e) => {
    if (e.target === annotationEditorModal) {
      annotationEditorModal.classList.remove('visible');
    }
  });
  
  console.log('Tutorial Creator v12.61 initialized');
})();
</script>
</body>
</html>
