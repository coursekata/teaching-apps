<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Tutorial Creator - v12.69</title>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    },
    startup: {
      ready: () => {
        MathJax.startup.defaultReady();
      }
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  :root{
    --accent:#2563eb;
    --record:#ef4444;
    --success:#10b981;
    --warning:#f59e0b;
    --teal:#06b6d4;
  }
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#111;
    background:#f5f5f5;
  }
  
  .tutorial-header{
    position: sticky;
    top: 0;
    background:#fff;
    border-bottom:2px solid #ddd;
    padding:12px 20px;
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .version-number{
    color: #666;
    font-size: 12px;
    font-weight: 500;
  }
  
  .tutorial-controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  button{
    padding:8px 14px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:13px;
  }
  
  button:hover:not(:disabled):not(.primary):not(.record):not(.success):not(.warning):not(.teal){
    background:#f9f9f9;
  }
  
  button:disabled{
    opacity:0.5;
    cursor:not-allowed;
  }
  
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button.record{
    background:var(--record);
    color:#fff;
    border-color:var(--record);
  }
  
  button.success{
    background:var(--success);
    color:#fff;
    border-color:var(--success);
  }
  
  button.warning{
    background:var(--warning);
    color:#fff;
    border-color:var(--warning);
  }
  
  button.teal{
    background:var(--teal);
    color:#fff;
    border-color:var(--teal);
  }
  
  button.record.recording{
    animation:pulse 1.5s infinite;
  }
  
  button.primary.playing{
    animation:pulse 1.5s infinite;
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.6}
  }
  
  .recording-active{
    animation:pulse 1.5s infinite;
  }
  
  .recording-indicator{
    background:var(--record);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
    animation:pulse 1.5s infinite;
  }
  
  .paused-indicator{
    background:var(--warning);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
  }
  
  .app-container{
    position:relative;
    width:100%;
    height:800px;
    overflow:hidden;
    margin-bottom:40px;
  }
  
  iframe{
    width:100%;
    height:100%;
    border:none;
  }
  
  iframe.playback-mode{
    pointer-events:none;
  }
  
  .annotation-box{
    position:absolute;
    width:250px;
    max-width:500px;
    background:rgba(255,255,255,0.98);
    border:3px solid var(--accent);
    border-radius:12px;
    padding:20px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15);
    z-index:100;
    display:none;
    overflow-y:auto;
    overflow-x:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    font-size:15px;
    line-height:1.6;
  }
  
  .annotation-box.custom-position{
    max-width:none;
  }
  
  .annotation-box.draggable{
    cursor:move;
    box-shadow:0 8px 24px rgba(0,0,0,0.2);
    z-index:10001;
  }
  
  .annotation-box.visible{
    display:block;
    animation:slideIn 0.3s ease-out;
  }
  
  .annotation-box.draggable .resize-handle{
    position:absolute;
    bottom:0;
    right:0;
    width:16px;
    height:16px;
    background:rgba(37, 99, 235, 0.3);
    cursor:nwse-resize;
    border-top-left-radius:4px;
    border-bottom-right-radius:12px;
  }
  
  .annotation-box.draggable .resize-handle::after{
    content:'‚ã∞';
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    color:rgba(37, 99, 235, 0.7);
    font-size:12px;
    line-height:1;
  }
  
  @keyframes slideIn{
    from{opacity:0;}
    to{opacity:1;}
  }
  
  .annotation-box h3{
    margin:0 0 12px;
    color:var(--accent);
    font-size:18px;
    line-height:1.3;
  }
  
  .annotation-box p{
    margin:0;
    line-height:inherit;
    font-size:inherit;
  }
  
  /* Timeline Editor */
  .timeline-container{
    background:#fff;
    border-top:2px solid #ddd;
    border-bottom:2px solid #ddd;
    padding:4px 20px 6px 20px;
    display:none;
    position:relative;
    margin-bottom:8px;
  }
  
  .timeline-container.visible{
    display:block;
  }
  
  .timeline-ruler{
    height:14px;
    position:relative;
    margin-bottom:0px;
    margin-left:60px;
    overflow:hidden;
  }
  
  .timeline-tick{
    position:absolute;
    top:0;
    font-size:8px;
    color:#999;
  }
  
  .timeline-track{
    height:26px;
    background:#fafafa;
    border:1px solid #ddd;
    border-radius:4px;
    position:relative;
    margin-bottom:2px;
    overflow:hidden;
    padding-left:60px;
  }
  
  .timeline-track-label{
    position:absolute;
    left:4px;
    top:50%;
    transform:translateY(-50%);
    font-size:10px;
    color:#666;
    font-weight:500;
    width:50px;
    overflow:hidden;
    text-align:left;
  }
  
  .timeline-event{
    position:absolute;
    top:2px;
    height:20px;
    border-radius:8px;
    cursor:pointer;
    border:1px solid rgba(0,0,0,0.1);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    font-weight:500;
    overflow:hidden;
    user-select:none;
  }
  
  .timeline-event.click{
    background:#e3f2fd;
    color:#1976d2;
    border-color:#1976d2;
    width:20px;
    border-radius:50%;
  }
  
  .timeline-event.mousedown{
    background:#fff3e0;
    color:#f57c00;
    border-color:#f57c00;
    width:8px;
    border-radius:2px;
  }
  
  .timeline-event.mouseup{
    background:#fff3e0;
    color:#f57c00;
    border-color:#f57c00;
    width:8px;
    border-radius:2px;
  }
  
  .timeline-event.mousemove{
    background:#fce4ec;
    color:#c2185b;
    border-color:#c2185b;
    width:4px;
    border-radius:1px;
  }
  
  .timeline-event.annotation{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
    min-width:30px;
    padding:0 6px;
    cursor:pointer;
  }
  
  .timeline-event.pause{
    background:var(--warning);
    color:#fff;
    border-color:var(--warning);
    width:20px;
    border-radius:50%;
    cursor:pointer;
  }
  
  .timeline-event.pause::before{
    content:'‚è∏';
    font-size:10px;
  }
  
  .timeline-event.drag{
    background:linear-gradient(to right, #fff3e0, #fce4ec);
    color:#d32f2f;
    border-color:#d32f2f;
    min-width:20px;
    padding:0 4px;
    border-radius:6px;
  }
  
  .timeline-event.selected{
    outline:2px solid var(--accent);
    outline-offset:1px;
    z-index:10;
  }
  
  .timeline-event.dragging{
    z-index:20;
    opacity:0.8;
    cursor:grabbing;
  }
  
  .timeline-playhead{
    position:absolute;
    top:0;
    bottom:0;
    width:2px;
    background:var(--record);
    z-index:50;
    pointer-events:none;
    display:none;
  }
  
  .timeline-playhead::before{
    content:'';
    position:absolute;
    top:-4px;
    left:-4px;
    width:10px;
    height:10px;
    background:var(--record);
    border-radius:50%;
  }
  
  .timeline-container .playhead-time{
    position:absolute;
    top:-18px;
    transform:translateX(-50%);
    background:var(--record);
    color:#fff;
    padding:2px 6px;
    border-radius:4px;
    font-size:10px;
    font-weight:600;
    white-space:nowrap;
    z-index:51;
  }
  
  .modal{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.5);
    display:none;
    z-index:1000;
    justify-content:center;
    align-items:center;
  }
  
  .modal.visible{
    display:flex;
  }
  
  .modal-content{
    background:#fff;
    border-radius:12px;
    padding:24px;
    box-shadow:0 20px 40px rgba(0,0,0,0.2);
    max-width:800px;
    width:90%;
    max-height:90%;
    overflow-y:auto;
    position:relative;
  }
  
  .modal-content h2{
    margin:0 0 16px;
    color:var(--accent);
    font-size:24px;
  }
  
  .modal-content h3{
    margin:20px 0 10px;
    color:#333;
    font-size:18px;
  }
  
  .modal-content p{
    margin:0 0 12px;
    line-height:1.6;
  }
  
  .modal-content textarea{
    width:100%;
    height:300px;
    padding:12px;
    border:1px solid #ddd;
    border-radius:6px;
    font-family:monospace;
    font-size:12px;
    resize:vertical;
  }
  
  .form-group{
    margin-bottom:16px;
  }
  
  .form-group label{
    display:block;
    margin-bottom:6px;
    font-weight:500;
    color:#333;
  }
  
  .form-group input{
    width:100%;
    padding:8px 12px;
    border:1px solid #ddd;
    border-radius:6px;
    font-size:14px;
  }
  
  .form-group textarea{
    width:100%;
    min-height:100px;
    padding:8px 12px;
    border:1px solid #ddd;
    border-radius:6px;
    font-size:14px;
    resize:vertical;
    font-family:inherit;
  }
  
  .form-row{
    display:flex;
    gap:12px;
  }
  
  .form-row .form-group{
    flex:1;
  }
  
  .checkbox-group{
    display:flex;
    align-items:center;
    gap:8px;
    margin-bottom:12px;
  }
  
  .checkbox-group input[type="checkbox"]{
    width:auto;
  }
  
  .modal-actions{
    display:flex;
    gap:12px;
    justify-content:flex-end;
    margin-top:20px;
    padding-top:16px;
    border-top:1px solid #eee;
  }
  
  input[type="file"]{
    display:none;
  }
  
  .status-indicators{
    display:flex;
    gap:12px;
    align-items:center;
  }
</style>
</head>
<body>

<div class="tutorial-header">
  <div style="display: flex; align-items: center; gap: 16px;">
    <h1 style="margin: 0; font-size: 20px; color: #333;">Interactive Tutorial Creator</h1>
    <span class="version-number">v12.69</span>
  </div>
  
  <div class="tutorial-controls">
    <div id="recordingControls" class="control-group">
      <div class="status-indicators">
        <div id="recordingIndicator" class="recording-indicator" style="display: none;">üî¥ RECORDING</div>
        <div id="pausedIndicator" class="paused-indicator" style="display: none;">‚è∏ PAUSED</div>
      </div>
      
      <label>
        App URL:
        <input type="text" id="appUrl" placeholder="Enter your app URL" value=""/>
      </label>
      <button id="loadApp" class="primary">Load App</button>
      
      <button id="startRecording" class="record" style="display: none;">‚è∫ Record</button>
      <button id="playPauseRecording" class="primary" style="display: none;">‚è∏ Pause</button>
      
      <button id="addAnnotation" class="primary" style="display: none;" disabled>üìù Annotate</button>
      <button id="addAnnotationAtPause" class="teal" style="display: none;">üìù Annotate</button>
      <button id="addPause" class="warning" style="display: none;" disabled>‚è∏ Add Pause</button>
      
      <button id="previewRecording" class="success" style="display: none;" disabled>‚ñ∂ Preview</button>
      <button id="recordAgain" class="warning" style="display: none;" disabled>üîÑ Record Again</button>
      <button id="exportRecording" class="primary" style="display: none;" disabled>üíæ Export</button>
      
      <button id="loadJSON" class="success" style="display:none;" title="Import existing tutorial JSON">Import</button>
      <input type="file" id="jsonFileInput" accept=".json" style="display:none;">
    </div>
    
    <button id="helpBtn" style="margin-left:auto;" title="Show help">‚ùì</button>
  </div>
</div>

<div id="appContainer" class="app-container">
  <iframe id="appFrame" sandbox="allow-scripts allow-same-origin allow-forms allow-pointer-lock"></iframe>
</div>

<div id="timelineContainer" class="timeline-container">
  <div class="timeline-ruler" id="timelineRuler"></div>
  <div class="timeline-track">
    <div class="timeline-track-label">Events</div>
    <div id="timelinePlayhead" class="timeline-playhead">
      <div class="playhead-time" id="playheadTime">0.0s</div>
    </div>
  </div>
  <div class="timeline-track">
    <div class="timeline-track-label">Annotations</div>
  </div>
  <div class="timeline-track">
    <div class="timeline-track-label">Pauses</div>
  </div>
</div>

<!-- Export Modal -->
<div id="exportModal" class="modal">
  <div class="modal-content">
    <h2>Export Tutorial</h2>
    <p><strong>Snapshots:</strong> <span id="snapshotCount">0</span> | <strong>Annotations:</strong> <span id="annotationCount">0</span></p>
    <textarea id="exportTextarea" readonly placeholder="Tutorial JSON will appear here..."></textarea>
    <div class="modal-actions">
      <button id="copyExport" class="primary">üìã Copy to Clipboard</button>
      <button id="downloadExport" class="success">üíæ Download JSON</button>
      <button id="closeExportModal">‚ùå Close</button>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
  <div class="modal-content">
    <h2>How to Use Tutorial Creator</h2>
    
    <h3>1. Load Your App</h3>
    <p>Enter the URL of your interactive web application and click "Load App". The app will load in the iframe below.</p>
    
    <h3>2. Start Recording</h3>
    <p>Click "Record" to begin capturing user interactions. The system will record:</p>
    <ul>
      <li>Mouse clicks and movements</li>
      <li>Form inputs and selections</li>
      <li>App state changes</li>
    </ul>
    
    <h3>3. Add Annotations</h3>
    <p>While recording (or paused), click "Annotate" to add explanatory text that appears at specific moments.</p>
    
    <h3>4. Add Pauses</h3>
    <p>Click "Add Pause" to insert strategic stops in your tutorial for learner reflection.</p>
    
    <h3>5. Preview & Export</h3>
    <p>Use "Preview" to test your tutorial, then "Export" to save it as JSON for use in other applications.</p>
    
    <h3>Timeline Editor</h3>
    <p>The timeline shows all recorded events, annotations, and pauses. You can:</p>
    <ul>
      <li>Click events to jump to that moment</li>
      <li>Drag annotations and pauses to reposition them</li>
      <li>Click annotations to edit their content</li>
    </ul>
    
    <div class="modal-actions">
      <button id="closeHelpModal" class="primary">‚úì Got it!</button>
    </div>
  </div>
</div>

<!-- Annotation Editor Modal -->
<div id="annotationEditorModal" class="modal">
  <div class="modal-content">
    <h2 id="annotationEditorTitle">Edit Annotation</h2>
    
    <div class="form-group">
      <label for="annotationTitle">Title:</label>
      <input type="text" id="annotationTitle" placeholder="Enter annotation title...">
    </div>
    
    <div class="form-group">
      <label for="annotationContent">Content:</label>
      <textarea id="annotationContent" placeholder="Enter annotation content (supports basic HTML and LaTeX with $ delimiters)..."></textarea>
    </div>
    
    <div class="form-row">
      <div class="form-group">
        <label for="annotationTimestamp">Start Time (seconds):</label>
        <input type="number" id="annotationTimestamp" step="0.1" min="0">
      </div>
      
      <div class="form-group">
        <label for="annotationDuration">Duration (seconds):</label>
        <input type="number" id="annotationDuration" step="0.1" min="0.1" value="5">
      </div>
    </div>
    
    <div class="form-row">
      <div class="form-group">
        <label for="annotationX">X Position (pixels from left):</label>
        <input type="number" id="annotationX" min="0">
      </div>
      
      <div class="form-group">
        <label for="annotationY">Y Position (pixels from top):</label>
        <input type="number" id="annotationY" min="0">
      </div>
    </div>
    
    <div class="form-row">
      <div class="form-group">
        <label for="annotationWidth">Width (pixels, optional):</label>
        <input type="number" id="annotationWidth" min="100">
      </div>
      
      <div class="form-group">
        <label for="annotationHeight">Height (pixels, optional):</label>
        <input type="number" id="annotationHeight" min="50">
      </div>
    </div>
    
    <div class="checkbox-group">
      <input type="checkbox" id="annotationCustomSize">
      <label for="annotationCustomSize">Use custom size (otherwise auto-sizes to content)</label>
    </div>
    
    <div class="modal-actions">
      <button id="saveAnnotation" class="success">‚úì Save</button>
      <button id="deleteAnnotation" class="warning">üóë Delete</button>
      <button id="cancelAnnotation">‚ùå Cancel</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ========== TUTORIAL CREATOR v12.68 ==========
  
  // State variables
  let isAppLoaded = false;
  let isRecording = false;
  let isPaused = false;
  let recordingStartTime = null;
  let pauseStartTime = null;
  let totalPausedTime = 0;
  let importedDurationOffset = 0; // For continuing imported tutorials
  let currentTutorial = null;
  let eventListener = null;
  let isPlayingBack = false;
  let playbackTimeouts = [];
  let timelineScale = 50; // pixels per second
  let selectedElement = null;
  let dragState = null;
  let currentAnnotationBox = null;
  let isDraggingAnnotation = false;
  let isResizingAnnotation = false;
  let initialMousePos = { x: 0, y: 0 };
  let initialElementPos = { x: 0, y: 0 };
  let initialElementSize = { width: 0, height: 0 };
  
  // DOM elements
  const appUrl = document.getElementById('appUrl');
  const loadApp = document.getElementById('loadApp');
  const appFrame = document.getElementById('appFrame');
  const startRecording = document.getElementById('startRecording');
  const playPauseRecording = document.getElementById('playPauseRecording');
  const addAnnotation = document.getElementById('addAnnotation');
  const addAnnotationAtPause = document.getElementById('addAnnotationAtPause');
  const addPause = document.getElementById('addPause');
  const previewRecording = document.getElementById('previewRecording');
  const recordAgain = document.getElementById('recordAgain');
  const exportRecording = document.getElementById('exportRecording');
  const loadJSON = document.getElementById('loadJSON');
  const jsonFileInput = document.getElementById('jsonFileInput');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const pausedIndicator = document.getElementById('pausedIndicator');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('helpModal');
  const closeHelpModal = document.getElementById('closeHelpModal');
  const exportModal = document.getElementById('exportModal');
  const exportTextarea = document.getElementById('exportTextarea');
  const snapshotCount = document.getElementById('snapshotCount');
  const annotationCount = document.getElementById('annotationCount');
  const copyExport = document.getElementById('copyExport');
  const downloadExport = document.getElementById('downloadExport');
  const closeExportModal = document.getElementById('closeExportModal');
  const timelineContainer = document.getElementById('timelineContainer');
  const timelineRuler = document.getElementById('timelineRuler');
  const timelinePlayhead = document.getElementById('timelinePlayhead');
  const playheadTime = document.getElementById('playheadTime');
  const annotationEditorModal = document.getElementById('annotationEditorModal');
  const annotationEditorTitle = document.getElementById('annotationEditorTitle');
  const annotationTitle = document.getElementById('annotationTitle');
  const annotationContent = document.getElementById('annotationContent');
  const annotationTimestamp = document.getElementById('annotationTimestamp');
  const annotationDuration = document.getElementById('annotationDuration');
  const annotationX = document.getElementById('annotationX');
  const annotationY = document.getElementById('annotationY');
  const annotationWidth = document.getElementById('annotationWidth');
  const annotationHeight = document.getElementById('annotationHeight');
  const annotationCustomSize = document.getElementById('annotationCustomSize');
  const saveAnnotation = document.getElementById('saveAnnotation');
  const deleteAnnotation = document.getElementById('deleteAnnotation');
  const cancelAnnotation = document.getElementById('cancelAnnotation');
  
  let editingAnnotationIndex = -1;
  
  // ========== IFRAME APP API ==========
  
  function getAPI() {
    if (!isAppLoaded) return null;
    try {
      return appFrame.contentWindow.TutorialAPI;
    } catch(e) {
      console.warn('Cannot access iframe API (likely cross-origin):', e.message);
      return null;
    }
  }
  
  // ========== APP LOADING ==========
  
  loadApp.addEventListener('click', () => {
    const url = appUrl.value.trim();
    if (!url) {
      alert('Please enter an app URL');
      return;
    }
    
    console.log('üöÄ Loading app:', url);
    appFrame.src = url;
    
    appFrame.onload = () => {
      console.log('üì± App loaded in iframe');
      
      // Try to access the API after a short delay to ensure the app is fully initialized
      setTimeout(() => {
        const api = getAPI();
        if (api) {
          console.log('‚úÖ Tutorial API detected');
          isAppLoaded = true;
          startRecording.style.display = 'inline-block';
          loadApp.textContent = '‚úì Loaded!';
          setTimeout(() => {
            loadApp.textContent = 'üì± Load App';
          }, 2000);
        } else {
          console.warn('‚ö†Ô∏è Tutorial API not found - app may not support recording');
          alert('App loaded, but Tutorial API not detected.\n\nThe app needs to include Tutorial API support for recording to work.');
          isAppLoaded = false;
        }
      }, 500);
    };
    
    appFrame.onerror = () => {
      console.error('‚ùå Failed to load app');
      alert('Failed to load app. Check the URL and ensure it allows iframe embedding.');
    };
  });
  
  // ========== RECORDING ==========
  
  startRecording.addEventListener('click', () => {
    const api = getAPI();
    if (!api) {
      alert('App not loaded or API not available');
      return;
    }
    
    if (!isRecording) {
      // Start fresh recording
      console.log('üî¥ Starting recording');
      
      currentTutorial = {
        initialState: api.getState(),
        snapshots: [],
        annotations: [],
        pauses: [],
        duration: 0
      };
      
      isRecording = true;
      isPaused = false;
      recordingStartTime = Date.now();
      totalPausedTime = 0;
      importedDurationOffset = 0;
      
      // Set up event listener
      eventListener = (event) => {
        const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
        const snapshot = {
          timestamp: timestamp,
          event: event,
          state: api.getState()
        };
        currentTutorial.snapshots.push(snapshot);
        renderTimeline();
      };
      api.onAction(eventListener);
      
      // Update UI
      startRecording.style.display = 'none';
      playPauseRecording.style.display = 'inline-block';
      playPauseRecording.textContent = '‚è∏ Pause';
      playPauseRecording.className = 'primary';
      recordingIndicator.style.display = 'inline-block';
      pausedIndicator.style.display = 'none';
      addAnnotation.style.display = 'inline-block';
      addAnnotation.disabled = false;
      addPause.style.display = 'inline-block';
      addPause.disabled = false;
      loadJSON.style.display = 'none';
      
      renderTimeline();
      
    } else if (isPaused) {
      // Resume recording
      console.log('‚ñ∂ Resuming recording');
      
      isPaused = false;
      totalPausedTime += Date.now() - pauseStartTime;
      
      // Update UI
      playPauseRecording.textContent = '‚è∏ Pause';
      playPauseRecording.className = 'primary';
      recordingIndicator.style.display = 'inline-block';
      pausedIndicator.style.display = 'none';
      addAnnotation.style.display = 'inline-block';
      addAnnotation.disabled = false;
      addAnnotationAtPause.style.display = 'none';
      startRecording.style.display = 'none';
    }
  });
  
  playPauseRecording.addEventListener('click', () => {
    if (isRecording && !isPaused) {
      // Pause recording
      console.log('‚è∏ Pausing recording');
      
      isPaused = true;
      pauseStartTime = Date.now();
      
      // Update UI
      playPauseRecording.textContent = '‚ñ∂ Resume';
      playPauseRecording.className = 'success';
      recordingIndicator.style.display = 'none';
      pausedIndicator.style.display = 'inline-block';
      addAnnotation.style.display = 'none';
      addAnnotationAtPause.style.display = 'inline-block';
      startRecording.style.display = 'inline-block';
      startRecording.textContent = '‚ñ∂ Resume';
      startRecording.className = 'success';
      
      // Enable additional controls
      previewRecording.style.display = 'inline-block';
      previewRecording.disabled = false;
      recordAgain.style.display = 'inline-block';
      recordAgain.disabled = false;
      exportRecording.style.display = 'inline-block';
      exportRecording.disabled = false;
      
      renderTimeline();
      recalculateDuration();
    }
  });
  
  recordAgain.addEventListener('click', () => {
    if (!confirm('Start a new recording? This will discard the current tutorial.')) {
      return;
    }
    
    console.log('üîÑ Starting new recording');
    
    // Stop current recording
    if (eventListener) {
      const api = getAPI();
      if (api) {
        api.removeListener(eventListener);
      }
    }
    
    // Reset state
    isRecording = false;
    isPaused = false;
    currentTutorial = null;
    eventListener = null;
    recordingStartTime = null;
    pauseStartTime = null;
    totalPausedTime = 0;
    importedDurationOffset = 0;
    
    // Clear timeline
    timelineContainer.classList.remove('visible');
    
    // Reset UI
    startRecording.style.display = 'inline-block';
    startRecording.textContent = '‚è∫ Record';
    startRecording.className = 'record';
    playPauseRecording.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    addAnnotation.style.display = 'none';
    addAnnotationAtPause.style.display = 'none';
    addPause.style.display = 'none';
    previewRecording.style.display = 'none';
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
    loadJSON.style.display = 'inline-block';
    
    // Clear any annotation boxes
    if (currentAnnotationBox) {
      currentAnnotationBox.remove();
      currentAnnotationBox = null;
    }
    
    // Reset app state
    const api = getAPI();
    if (api && currentTutorial && currentTutorial.initialState) {
      api.setState(currentTutorial.initialState);
    }
  });
  
  // ========== PLAYBACK ==========
  
  previewRecording.addEventListener('click', () => {
    if (!currentTutorial || currentTutorial.snapshots.length === 0) {
      alert('No recording to preview');
      return;
    }
    
    if (isPlayingBack) {
      stopPlayback();
      return;
    }
    
    console.log('‚ñ∂ Starting playback preview');
    startPlayback();
  });
  
  function startPlayback() {
    const api = getAPI();
    if (!api) return;
    
    isPlayingBack = true;
    previewRecording.textContent = '‚èπ Stop Preview';
    previewRecording.className = 'warning playing';
    appFrame.classList.add('playback-mode');
    
    // Clear any existing timeouts
    playbackTimeouts.forEach(timeout => clearTimeout(timeout));
    playbackTimeouts = [];
    
    // Clear any annotation box
    if (currentAnnotationBox) {
      currentAnnotationBox.style.display = 'none';
    }
    
    // Reset to initial state
    api.setState(currentTutorial.initialState);
    
    // Show timeline and start playhead at beginning
    timelineContainer.classList.add('visible');
    timelinePlayhead.style.display = 'block';
    const timelineStartOffset = getTimelineStartOffset();
    timelinePlayhead.style.left = '60px'; // Start at left edge
    
    let playbackStartTime = Date.now();
    let lastPlayheadUpdate = 0;
    
    // Schedule all snapshots
    currentTutorial.snapshots.forEach((snapshot, index) => {
      const timeout = setTimeout(() => {
        if (!isPlayingBack) return;
        
        console.log(`üì∏ Applying snapshot ${index + 1}/${currentTutorial.snapshots.length} at ${snapshot.timestamp}ms`);
        api.setState(snapshot.state);
        
        // Update playhead position
        const timelinePosition = ((snapshot.timestamp - timelineStartOffset) / 1000) * timelineScale + 60;
        timelinePlayhead.style.left = timelinePosition + 'px';
        playheadTime.textContent = (snapshot.timestamp / 1000).toFixed(1) + 's';
        lastPlayheadUpdate = snapshot.timestamp;
      }, snapshot.timestamp);
      
      playbackTimeouts.push(timeout);
    });
    
    // Schedule annotations
    currentTutorial.annotations.forEach((annotation, index) => {
      console.log('üîç PLAYBACK SCHEDULING - Annotation', index, ':', JSON.stringify(annotation, null, 2));
      
      // Show annotation
      const showTimeout = setTimeout(() => {
        if (!isPlayingBack) return;
        console.log('üîç PLAYBACK SHOW - Showing annotation during playback:', annotation.title);
        showAnnotation(annotation);
      }, annotation.timestamp);
      playbackTimeouts.push(showTimeout);
      
      // Hide annotation
      const hideTimeout = setTimeout(() => {
        if (!isPlayingBack) return;
        console.log('üîç PLAYBACK HIDE - Hiding annotation during playback:', annotation.title);
        hideAnnotation();
      }, annotation.timestamp + annotation.duration);
      playbackTimeouts.push(hideTimeout);
    });
    
    // Schedule pauses
    currentTutorial.pauses.forEach((pause, index) => {
      const pauseTimeout = setTimeout(() => {
        if (!isPlayingBack) return;
        
        console.log(`‚è∏ Pausing playback at ${pause.timestamp}ms`);
        
        // Calculate how long to pause
        const pauseDuration = 2000; // 2 second pause
        
        // Show pause UI
        const pauseIndicator = document.createElement('div');
        pauseIndicator.textContent = '‚è∏ Tutorial Paused';
        pauseIndicator.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: var(--warning);
          color: white;
          padding: 12px 24px;
          border-radius: 8px;
          font-weight: 600;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(pauseIndicator);
        
        // Remove pause indicator after pause duration
        const resumeTimeout = setTimeout(() => {
          if (!isPlayingBack) return;
          pauseIndicator.remove();
          console.log(`‚ñ∂ Resuming playback after ${pauseDuration}ms pause`);
        }, pauseDuration);
        playbackTimeouts.push(resumeTimeout);
        
      }, pause.timestamp);
      playbackTimeouts.push(pauseTimeout);
    });
    
    // Schedule end of playback
    const endTimeout = setTimeout(() => {
      if (!isPlayingBack) return;
      console.log('‚úÖ Playback completed');
      stopPlayback();
    }, currentTutorial.duration + 500); // Small buffer
    
    playbackTimeouts.push(endTimeout);
    
    // Update playhead continuously during playback
    const playheadInterval = setInterval(() => {
      if (!isPlayingBack) {
        clearInterval(playheadInterval);
        return;
      }
      
      const elapsed = Date.now() - playbackStartTime;
      if (elapsed > lastPlayheadUpdate) {
        const timelinePosition = ((elapsed - timelineStartOffset) / 1000) * timelineScale + 60;
        timelinePlayhead.style.left = timelinePosition + 'px';
        playheadTime.textContent = (elapsed / 1000).toFixed(1) + 's';
      }
    }, 50); // Update every 50ms for smooth movement
  }
  
  function stopPlayback() {
    console.log('‚èπ Stopping playback');
    
    isPlayingBack = false;
    previewRecording.textContent = '‚ñ∂ Preview';
    previewRecording.classList.remove('playing');
    previewRecording.className = 'success';
    appFrame.classList.remove('playback-mode');
    
    // Clear all timeouts
    playbackTimeouts.forEach(timeout => clearTimeout(timeout));
    playbackTimeouts = [];
    
    // Hide annotation
    hideAnnotation();
    
    // Remove any pause indicators
    document.querySelectorAll('[style*="Tutorial Paused"]').forEach(el => el.remove());
    
    // Reset to final state
    const api = getAPI();
    if (api && currentTutorial) {
      if (currentTutorial.snapshots.length > 0) {
        const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
        api.setState(lastSnapshot.state);
      } else {
        api.setState(currentTutorial.initialState);
      }
    }
    
    // Position playhead at end
    if (currentTutorial) {
      const timelineStartOffset = getTimelineStartOffset();
      const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
      timelinePlayhead.style.left = timelineEndPosition + 'px';
      playheadTime.textContent = (currentTutorial.duration / 1000).toFixed(1) + 's';
    }
  }
  
  // ========== ANNOTATIONS ==========
  
  addAnnotation.addEventListener('click', () => {
    openAnnotationEditor();
  });
  
  addAnnotationAtPause.addEventListener('click', () => {
    openAnnotationEditor();
  });
  
  function openAnnotationEditor(existingAnnotation = null) {
    console.log('üîç OPEN ANNOTATION EDITOR - Called with:', existingAnnotation ? 'existing annotation' : 'new annotation');
    
    editingAnnotationIndex = existingAnnotation ? 
      currentTutorial.annotations.indexOf(existingAnnotation) : -1;
    
    if (existingAnnotation) {
      console.log('üîç OPEN ANNOTATION EDITOR - Loading existing annotation data:');
      console.log('  Full annotation object:', JSON.stringify(existingAnnotation, null, 2));
      console.log('  Editing index:', editingAnnotationIndex);
      
      annotationEditorTitle.textContent = 'Edit Annotation';
      annotationTitle.value = existingAnnotation.title || '';
      annotationContent.value = existingAnnotation.content || '';
      annotationTimestamp.value = (existingAnnotation.timestamp / 1000).toFixed(1);
      annotationDuration.value = (existingAnnotation.duration / 1000).toFixed(1);
      annotationX.value = existingAnnotation.x || 0;
      annotationY.value = existingAnnotation.y || 0;
      annotationWidth.value = existingAnnotation.width || '';
      annotationHeight.value = existingAnnotation.height || '';
      annotationCustomSize.checked = !!(existingAnnotation.width || existingAnnotation.height);
      
      console.log('üîç OPEN ANNOTATION EDITOR - Form populated with values:');
      console.log('  X input value:', annotationX.value);
      console.log('  Y input value:', annotationY.value);
      console.log('  Width input value:', annotationWidth.value);
      console.log('  Height input value:', annotationHeight.value);
      console.log('  Custom size checked:', annotationCustomSize.checked);
      
      deleteAnnotation.style.display = 'inline-block';
    } else {
      console.log('üîç OPEN ANNOTATION EDITOR - Creating new annotation');
      annotationEditorTitle.textContent = 'Add Annotation';
      annotationTitle.value = '';
      annotationContent.value = '';
      
      // Set timestamp to current recording time or 0
      let timestamp = 0;
      if (isRecording && !isPaused) {
        timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
      } else if (isRecording && isPaused) {
        timestamp = pauseStartTime - recordingStartTime - totalPausedTime + importedDurationOffset;
      }
      
      annotationTimestamp.value = (timestamp / 1000).toFixed(1);
      annotationDuration.value = '5.0';
      annotationX.value = '100';
      annotationY.value = '100';
      annotationWidth.value = '';
      annotationHeight.value = '';
      annotationCustomSize.checked = false;
      
      console.log('üîç OPEN ANNOTATION EDITOR - New annotation defaults:');
      console.log('  Timestamp:', annotationTimestamp.value, 's');
      console.log('  X:', annotationX.value);
      console.log('  Y:', annotationY.value);
      
      deleteAnnotation.style.display = 'none';
    }
    
    annotationEditorModal.classList.add('visible');
  }
  
  saveAnnotation.addEventListener('click', () => {
    const title = annotationTitle.value.trim();
    const content = annotationContent.value.trim();
    const timestamp = parseFloat(annotationTimestamp.value) * 1000;
    const duration = parseFloat(annotationDuration.value) * 1000;
    const x = parseInt(annotationX.value) || 0;
    const y = parseInt(annotationY.value) || 0;
    const width = annotationCustomSize.checked ? (parseInt(annotationWidth.value) || null) : null;
    const height = annotationCustomSize.checked ? (parseInt(annotationHeight.value) || null) : null;
    
    console.log('üîç SAVE ANNOTATION - Input values:');
    console.log('  Title:', title);
    console.log('  X coordinate:', x, '(from input:', annotationX.value, ')');
    console.log('  Y coordinate:', y, '(from input:', annotationY.value, ')');
    console.log('  Custom size checked:', annotationCustomSize.checked);
    console.log('  Width:', width, '(from input:', annotationWidth.value, ')');
    console.log('  Height:', height, '(from input:', annotationHeight.value, ')');
    console.log('  Timestamp:', timestamp, 'ms');
    console.log('  Duration:', duration, 'ms');
    
    if (!title || !content) {
      alert('Please enter both title and content');
      return;
    }
    
    if (isNaN(timestamp) || isNaN(duration)) {
      alert('Please enter valid timestamp and duration');
      return;
    }
    
    const annotation = {
      title: title,
      content: content,
      timestamp: timestamp,
      duration: duration,
      x: x,
      y: y
    };
    
    if (width) annotation.width = width;
    if (height) annotation.height = height;
    
    console.log('üîç SAVE ANNOTATION - Final annotation object:', JSON.stringify(annotation, null, 2));
    
    if (editingAnnotationIndex >= 0) {
      // Edit existing
      currentTutorial.annotations[editingAnnotationIndex] = annotation;
      console.log('üìù Annotation updated at index', editingAnnotationIndex);
    } else {
      // Add new
      currentTutorial.annotations.push(annotation);
      console.log('üìù Annotation added at index', currentTutorial.annotations.length - 1);
    }
    
    // Sort annotations by timestamp to maintain order
    currentTutorial.annotations.sort((a, b) => a.timestamp - b.timestamp);
    
    renderTimeline();
    recalculateDuration();
    annotationEditorModal.classList.remove('visible');
    editingAnnotationIndex = -1;
  });
  
  deleteAnnotation.addEventListener('click', () => {
    if (editingAnnotationIndex >= 0) {
      if (confirm('Delete this annotation?')) {
        currentTutorial.annotations.splice(editingAnnotationIndex, 1);
        console.log('üóë Annotation deleted');
        renderTimeline();
        recalculateDuration();
        annotationEditorModal.classList.remove('visible');
        editingAnnotationIndex = -1;
      }
    }
  });
  
  cancelAnnotation.addEventListener('click', () => {
    annotationEditorModal.classList.remove('visible');
    editingAnnotationIndex = -1;
  });
  
  function showAnnotation(annotation) {
    console.log('üîç SHOW ANNOTATION - Called with annotation:', JSON.stringify(annotation, null, 2));
    
    hideAnnotation(); // Hide any existing annotation
    
    // Create annotation box inside the iframe (like the previous working version)
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      console.log('üîç SHOW ANNOTATION - Creating annotation inside iframe');
      console.log('  Iframe dimensions:', {
        width: appFrame.offsetWidth,
        height: appFrame.offsetHeight,
        clientWidth: appFrame.clientWidth,
        clientHeight: appFrame.clientHeight
      });
      
      const annotationBox = iframeDoc.createElement('div');
      annotationBox.className = 'annotation-box visible';
      
      console.log('üîç SHOW ANNOTATION - Before positioning:');
      console.log('  annotation.x:', annotation.x);
      console.log('  annotation.y:', annotation.y);
      console.log('  annotation.width:', annotation.width);
      console.log('  annotation.height:', annotation.height);
      
      // Set position and size
      annotationBox.style.left = annotation.x + 'px';
      annotationBox.style.top = annotation.y + 'px';
      
      console.log('üîç SHOW ANNOTATION - Applied basic positioning:');
      console.log('  style.left:', annotationBox.style.left);
      console.log('  style.top:', annotationBox.style.top);
      
      if (annotation.width) {
        annotationBox.style.width = annotation.width + 'px';
        annotationBox.classList.add('custom-position');
        console.log('üîç SHOW ANNOTATION - Applied custom width:', annotationBox.style.width);
      }
      if (annotation.height) {
        annotationBox.style.height = annotation.height + 'px';
        annotationBox.classList.add('custom-position');
        console.log('üîç SHOW ANNOTATION - Applied custom height:', annotationBox.style.height);
      }
      
      // Create content with proper HTML structure
      const title = iframeDoc.createElement('h3');
      title.textContent = annotation.title;
      
      const content = iframeDoc.createElement('div');
      content.innerHTML = annotation.content;
      
      annotationBox.appendChild(title);
      annotationBox.appendChild(content);
      
      // Add to iframe document
      iframeDoc.body.appendChild(annotationBox);
      currentAnnotationBox = annotationBox;
      
      // Log the actual computed styles after adding to DOM
      console.log('üîç SHOW ANNOTATION - After adding to DOM:');
      const computedStyles = iframeDoc.defaultView.getComputedStyle(annotationBox);
      console.log('  Computed position:', computedStyles.position);
      console.log('  Computed left:', computedStyles.left);
      console.log('  Computed top:', computedStyles.top);
      console.log('  Computed width:', computedStyles.width);
      console.log('  Computed height:', computedStyles.height);
      console.log('  getBoundingClientRect():', annotationBox.getBoundingClientRect());
      
      // Process LaTeX if MathJax is available
      if (appFrame.contentWindow.MathJax && appFrame.contentWindow.MathJax.typesetPromise) {
        appFrame.contentWindow.MathJax.typesetPromise([annotationBox]).catch((err) => {
          console.warn('MathJax processing error:', err);
        });
      }
      
      console.log('üí¨ Annotation shown successfully inside iframe:', annotation.title);
    } catch(e) {
      console.warn('Cannot create annotation in iframe (cross-origin):', e.message);
      console.log('üîç SHOW ANNOTATION - Falling back to main document overlay');
      
      // Fallback: create annotation box in main document (over the iframe)
      const annotationBox = document.createElement('div');
      annotationBox.className = 'annotation-box visible';
      annotationBox.style.position = 'absolute';
      annotationBox.style.left = annotation.x + 'px';
      annotationBox.style.top = annotation.y + 'px';
      annotationBox.style.zIndex = '10000';
      
      console.log('üîç SHOW ANNOTATION - Fallback positioning:');
      console.log('  style.left:', annotationBox.style.left);
      console.log('  style.top:', annotationBox.style.top);
      
      if (annotation.width) {
        annotationBox.style.width = annotation.width + 'px';
        annotationBox.classList.add('custom-position');
        console.log('üîç SHOW ANNOTATION - Fallback custom width:', annotationBox.style.width);
      }
      if (annotation.height) {
        annotationBox.style.height = annotation.height + 'px';
        annotationBox.classList.add('custom-position');
        console.log('üîç SHOW ANNOTATION - Fallback custom height:', annotationBox.style.height);
      }
      
      const title = document.createElement('h3');
      title.textContent = annotation.title;
      
      const content = document.createElement('div');
      content.innerHTML = annotation.content;
      
      annotationBox.appendChild(title);
      annotationBox.appendChild(content);
      
      document.getElementById('appContainer').appendChild(annotationBox);
      currentAnnotationBox = annotationBox;
      
      console.log('üîç SHOW ANNOTATION - Fallback after adding to DOM:');
      const computedStyles = window.getComputedStyle(annotationBox);
      console.log('  Computed position:', computedStyles.position);
      console.log('  Computed left:', computedStyles.left);
      console.log('  Computed top:', computedStyles.top);
      console.log('  Computed width:', computedStyles.width);
      console.log('  Computed height:', computedStyles.height);
      console.log('  getBoundingClientRect():', annotationBox.getBoundingClientRect());
      
      console.log('üí¨ Annotation shown (fallback):', annotation.title);
    }
  }
  
  function hideAnnotation() {
    if (currentAnnotationBox) {
      currentAnnotationBox.remove();
      currentAnnotationBox = null;
    }
  }
  
  // ========== PAUSES ==========
  
  addPause.addEventListener('click', () => {
    if (!currentTutorial) {
      alert('No active recording');
      return;
    }
    
    // Calculate current timestamp
    let timestamp = 0;
    if (isRecording && !isPaused) {
      timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
    } else if (isRecording && isPaused) {
      timestamp = pauseStartTime - recordingStartTime - totalPausedTime + importedDurationOffset;
    }
    
    const pause = {
      timestamp: timestamp
    };
    
    currentTutorial.pauses.push(pause);
    currentTutorial.pauses.sort((a, b) => a.timestamp - b.timestamp);
    
    console.log('‚è∏ Pause added at:', (timestamp / 1000).toFixed(2) + 's');
    renderTimeline();
    recalculateDuration();
  });
  
  // ========== TIMELINE ==========
  
  function getTimelineStartOffset() {
    // Always start timeline at 0 for consistency
    return 0;
  }
  
  function renderTimeline() {
    if (!currentTutorial) {
      timelineContainer.classList.remove('visible');
      return;
    }
    
    timelineContainer.classList.add('visible');
    
    // Calculate timeline duration and scale
    recalculateDuration();
    const timelineStartOffset = getTimelineStartOffset();
    const durationSeconds = (currentTutorial.duration - timelineStartOffset) / 1000;
    
    // Calculate scale to fit in available width
    const containerWidth = timelineContainer.offsetWidth || 1200;
    const availableWidth = containerWidth - 80; // Account for label space
    const minScale = 20; // Minimum pixels per second
    const maxScale = 100; // Maximum pixels per second
    
    if (durationSeconds > 0) {
      const calculatedScale = availableWidth / durationSeconds;
      timelineScale = Math.max(minScale, Math.min(maxScale, calculatedScale));
    } else {
      timelineScale = 50; // Default scale
    }
    
    // Clear existing timeline content
    timelineRuler.innerHTML = '';
    const tracks = timelineContainer.querySelectorAll('.timeline-track');
    tracks.forEach(track => {
      // Keep the label, clear events
      const events = track.querySelectorAll('.timeline-event');
      events.forEach(event => event.remove());
    });
    
    // Generate ruler ticks
    if (durationSeconds > 0) {
      const tickInterval = durationSeconds > 30 ? 5 : (durationSeconds > 10 ? 2 : 1); // seconds
      for (let i = 0; i <= durationSeconds; i += tickInterval) {
        const tick = document.createElement('div');
        tick.className = 'timeline-tick';
        tick.textContent = i + 's';
        tick.style.left = (i * timelineScale) + 'px';
        timelineRuler.appendChild(tick);
      }
    }
    
    // Add events to first track
    const eventTrack = tracks[0];
    if (currentTutorial.snapshots) {
      currentTutorial.snapshots.forEach((snapshot, index) => {
        const event = document.createElement('div');
        event.className = 'timeline-event ' + snapshot.event.type;
        event.style.left = ((snapshot.timestamp - timelineStartOffset) / 1000 * timelineScale) + 'px';
        event.title = `${snapshot.event.type} at ${(snapshot.timestamp / 1000).toFixed(2)}s`;
        
        // Group consecutive mouse events into drag events
        if (snapshot.event.type === 'mousemove' && index > 0) {
          const prevSnapshot = currentTutorial.snapshots[index - 1];
          if (prevSnapshot.event.type === 'mousedown' || prevSnapshot.event.type === 'mousemove') {
            // This is part of a drag sequence
            event.className = 'timeline-event drag';
            event.title = `Drag at ${(snapshot.timestamp / 1000).toFixed(2)}s`;
          }
        }
        
        // Click to jump to this event
        event.addEventListener('click', () => {
          if (isPlayingBack) return;
          jumpToTimestamp(snapshot.timestamp);
        });
        
        eventTrack.appendChild(event);
      });
    }
    
    // Add annotations to second track
    const annotationTrack = tracks[1];
    if (currentTutorial.annotations) {
      currentTutorial.annotations.forEach((annotation, index) => {
        const event = document.createElement('div');
        event.className = 'timeline-event annotation';
        event.style.left = ((annotation.timestamp - timelineStartOffset) / 1000 * timelineScale) + 'px';
        event.style.width = ((annotation.duration / 1000) * timelineScale) + 'px';
        event.textContent = annotation.title;
        event.title = `"${annotation.title}" at ${(annotation.timestamp / 1000).toFixed(2)}s for ${(annotation.duration / 1000).toFixed(1)}s`;
        
        // Click to edit annotation
        event.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isPlayingBack) return;
          openAnnotationEditor(annotation);
        });
        
        // Make draggable
        let isDragging = false;
        event.addEventListener('mousedown', (e) => {
          if (isPlayingBack) return;
          isDragging = true;
          event.classList.add('dragging');
          selectedElement = { type: 'annotation', index: index, element: event };
          
          const startX = e.clientX;
          const startLeft = parseFloat(event.style.left);
          
          const onMouseMove = (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - startX;
            const newLeft = Math.max(0, startLeft + deltaX);
            event.style.left = newLeft + 'px';
          };
          
          const onMouseUp = () => {
            if (!isDragging) return;
            isDragging = false;
            event.classList.remove('dragging');
            
            // Update annotation timestamp
            const newTimestamp = (parseFloat(event.style.left) / timelineScale * 1000) + timelineStartOffset;
            annotation.timestamp = Math.max(0, newTimestamp);
            
            // Re-sort annotations
            currentTutorial.annotations.sort((a, b) => a.timestamp - b.timestamp);
            
            console.log('üìù Annotation moved to:', (annotation.timestamp / 1000).toFixed(2) + 's');
            renderTimeline(); // Re-render to update order
            recalculateDuration();
            
            selectedElement = null;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          };
          
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });
        
        annotationTrack.appendChild(event);
      });
    }
    
    // Add pauses to third track
    const pauseTrack = tracks[2];
    if (currentTutorial.pauses) {
      currentTutorial.pauses.forEach((pause, index) => {
        const event = document.createElement('div');
        event.className = 'timeline-event pause';
        event.style.left = ((pause.timestamp - timelineStartOffset) / 1000 * timelineScale) + 'px';
        event.title = `Pause at ${(pause.timestamp / 1000).toFixed(2)}s`;
        
        // Click to delete pause
        event.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isPlayingBack) return;
          if (confirm('Delete this pause?')) {
            currentTutorial.pauses.splice(index, 1);
            console.log('üóë Pause deleted');
            renderTimeline();
            recalculateDuration();
          }
        });
        
        // Make draggable
        let isDragging = false;
        event.addEventListener('mousedown', (e) => {
          if (isPlayingBack) return;
          isDragging = true;
          event.classList.add('dragging');
          selectedElement = { type: 'pause', index: index, element: event };
          
          const startX = e.clientX;
          const startLeft = parseFloat(event.style.left);
          
          const onMouseMove = (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - startX;
            const newLeft = Math.max(0, startLeft + deltaX);
            event.style.left = newLeft + 'px';
          };
          
          const onMouseUp = () => {
            if (!isDragging) return;
            isDragging = false;
            event.classList.remove('dragging');
            
            // Update pause timestamp
            const newTimestamp = (parseFloat(event.style.left) / timelineScale * 1000) + timelineStartOffset;
            pause.timestamp = Math.max(0, newTimestamp);
            
            // Re-sort pauses
            currentTutorial.pauses.sort((a, b) => a.timestamp - b.timestamp);
            
            console.log('‚è∏ Pause moved to:', (pause.timestamp / 1000).toFixed(2) + 's');
            renderTimeline(); // Re-render to update order
            recalculateDuration();
            
            selectedElement = null;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          };
          
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });
        
        pauseTrack.appendChild(event);
      });
    }
    
    console.log('üìä Timeline rendered:', {
      duration: (currentTutorial.duration / 1000).toFixed(2) + 's',
      scale: timelineScale.toFixed(1) + 'px/s',
      snapshots: currentTutorial.snapshots?.length || 0,
      annotations: currentTutorial.annotations?.length || 0,
      pauses: currentTutorial.pauses?.length || 0
    });
  }
  
  function jumpToTimestamp(timestamp) {
    if (!currentTutorial) return;
    
    const api = getAPI();
    if (!api) return;
    
    console.log('üîç JUMP TO TIMESTAMP - Called with:', (timestamp / 1000).toFixed(2) + 's');
    
    // Find the snapshot at or before this timestamp
    let targetSnapshot = null;
    for (let i = currentTutorial.snapshots.length - 1; i >= 0; i--) {
      if (currentTutorial.snapshots[i].timestamp <= timestamp) {
        targetSnapshot = currentTutorial.snapshots[i];
        break;
      }
    }
    
    if (targetSnapshot) {
      api.setState(targetSnapshot.state);
      console.log('üîç JUMP TO TIMESTAMP - Applied snapshot from:', (targetSnapshot.timestamp / 1000).toFixed(2) + 's');
    } else {
      api.setState(currentTutorial.initialState);
      console.log('üîç JUMP TO TIMESTAMP - Applied initial state');
    }
    
    // Update playhead position
    const timelineStartOffset = getTimelineStartOffset();
    const timelinePosition = ((timestamp - timelineStartOffset) / 1000) * timelineScale + 60;
    timelinePlayhead.style.left = timelinePosition + 'px';
    timelinePlayhead.style.display = 'block';
    playheadTime.textContent = (timestamp / 1000).toFixed(1) + 's';
    
    // Check if any annotation should be shown at this timestamp
    hideAnnotation();
    const activeAnnotation = currentTutorial.annotations.find(ann => 
      timestamp >= ann.timestamp && timestamp < ann.timestamp + ann.duration
    );
    if (activeAnnotation) {
      console.log('üîç JUMP TO TIMESTAMP - Active annotation found:', activeAnnotation.title);
      console.log('  Annotation time range:', (activeAnnotation.timestamp / 1000).toFixed(2) + 's to', ((activeAnnotation.timestamp + activeAnnotation.duration) / 1000).toFixed(2) + 's');
      showAnnotation(activeAnnotation);
    } else {
      console.log('üîç JUMP TO TIMESTAMP - No active annotation at this time');
    }
  }
  
  function recalculateDuration() {
    if (!currentTutorial) return;
    
    // Find the latest timestamp among all elements
    let lastSnapshotTime = 0;
    let lastSnapshotIsSingleEvent = false;
    if (currentTutorial.snapshots.length > 0) {
      const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
      lastSnapshotTime = lastSnapshot.timestamp;
      // Check if it's a single-click event (not part of a drag sequence)
      lastSnapshotIsSingleEvent = lastSnapshot.event.type === 'click' || 
                                  (lastSnapshot.event.type !== 'mousemove' && lastSnapshot.event.type !== 'mouseup');
    }
    
    let lastAnnotationEnd = 0;
    if (currentTutorial.annotations.length > 0) {
      lastAnnotationEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
    }
    
    let lastPauseTime = 0;
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      lastPauseTime = Math.max(...currentTutorial.pauses.map(pause => pause.timestamp));
    }
    
    // Determine which element is chronologically last
    let calculatedDuration = 0;
    let durationSource = 'none';
    let lastElementType = 'none';
    
    const maxTime = Math.max(lastSnapshotTime, lastAnnotationEnd, lastPauseTime);
    
    if (maxTime === 0) {
      calculatedDuration = 0;
      durationSource = 'none';
      lastElementType = 'none';
    } else if (maxTime === lastPauseTime && lastPauseTime > 0) {
      // Pause is chronologically last
      calculatedDuration = lastPauseTime;
      durationSource = 'pause';
      lastElementType = 'pause';
    } else if (maxTime === lastAnnotationEnd) {
      // Annotation extends furthest
      calculatedDuration = lastAnnotationEnd;
      durationSource = 'annotation';
      lastElementType = 'annotation';
    } else {
      // Snapshot is last
      calculatedDuration = lastSnapshotTime;
      durationSource = 'snapshot';
      lastElementType = lastSnapshotIsSingleEvent ? 'singleEvent' : 'dragEvent';
    }
    
    // Add pixel-based buffers for visual alignment
    // Must iterate because adding buffer changes scale, which changes buffer amount
    // Only add buffer for click events (single events), NOT for pauses
    if (lastElementType === 'singleEvent') {
      const containerWidth = timelineContainer.offsetWidth || 1200;
      const availableWidth = containerWidth - 80;
      const minScale = 20;
      const maxScale = 100;
      
      // Iterate to find stable buffer (scale depends on duration, buffer depends on scale)
      let iterDuration = calculatedDuration;
      let iterScale = 50; // Initial guess
      for (let iteration = 0; iteration < 5; iteration++) {
        // Calculate what scale will be for this duration
        const durationSeconds = (iterDuration - getTimelineStartOffset()) / 1000;
        if (durationSeconds > 0) {
          const calculatedScale = availableWidth / durationSeconds;
          iterScale = Math.max(minScale, Math.min(maxScale, calculatedScale));
        }
        
        // Calculate buffer using this scale
        let bufferPixels = 26; // Click events only - empirically calibrated
        
        const bufferMs = (bufferPixels / iterScale) * 1000;
        const newDuration = calculatedDuration + bufferMs;
        
        // Check convergence
        if (Math.abs(newDuration - iterDuration) < 1) {
          iterDuration = newDuration;
          break;
        }
        
        iterDuration = newDuration;
      }
      
      calculatedDuration = iterDuration;
      console.log('üìä Added buffer for', lastElementType, ':', ((calculatedDuration - lastSnapshotTime) / 1000).toFixed(3) + 's');
    }
    
    currentTutorial.duration = calculatedDuration;
    console.log('üìä Duration recalculated:', (calculatedDuration / 1000).toFixed(2) + 's');
    console.log('  Last snapshot:', (lastSnapshotTime / 1000).toFixed(2) + 's');
    console.log('  Last annotation end:', (lastAnnotationEnd / 1000).toFixed(2) + 's');
    console.log('  Last pause:', (lastPauseTime / 1000).toFixed(2) + 's');
    console.log('  Duration determined by:', durationSource);
  }
  
  // ========== ANNOTATION EDITING ==========
  
  // ========== EXPORT/IMPORT ==========
  
  exportRecording.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Don't finalize - just export the current state
    // User can continue recording after exporting
    
    snapshotCount.textContent = currentTutorial.snapshots.length;
    annotationCount.textContent = currentTutorial.annotations.length;
    exportTextarea.value = JSON.stringify(currentTutorial, null, 2);
    exportModal.classList.add('visible');
  });
  
  downloadExport.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    const jsonStr = JSON.stringify(currentTutorial, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tutorial-' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    downloadExport.textContent = '‚úì Downloaded!';
    setTimeout(() => {
      downloadExport.textContent = 'üíæ Download JSON';
    }, 2000);
  });
  
  copyExport.addEventListener('click', () => {
    exportTextarea.select();
    document.execCommand('copy');
    copyExport.textContent = '‚úì Copied!';
    setTimeout(() => {
      copyExport.textContent = 'üìã Copy to Clipboard';
    }, 2000);
  });
  
  closeExportModal.addEventListener('click', () => {
    exportModal.classList.remove('visible');
  });
  
  loadJSON.addEventListener('click', () => {
    jsonFileInput.click();
  });
  
  jsonFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const imported = JSON.parse(event.target.result);
        
        if (!imported.initialState || !imported.snapshots || !imported.annotations) {
          throw new Error('Invalid tutorial format');
        }
        
        // Backward compatibility: add pauses array if it doesn't exist
        if (!imported.pauses) {
          imported.pauses = [];
        }
        
        currentTutorial = imported;
        
        console.log('üì§ Tutorial imported successfully');
        console.log('  Snapshots:', currentTutorial.snapshots.length);
        console.log('  Annotations:', currentTutorial.annotations.length);
        console.log('  Pauses:', currentTutorial.pauses ? currentTutorial.pauses.length : 0);
        if (currentTutorial.annotations.length > 0) {
          console.log('  Annotation details:', currentTutorial.annotations.map(a => 
            `"${a.title}" at ${a.timestamp}ms for ${a.duration}ms`
          ));
        }
        
        // Load the app if not already loaded
        if (!isAppLoaded && imported.initialState) {
          // We can't auto-load without a URL, so just inform user
          alert('Tutorial loaded! Please load the app first using "Load App", then the tutorial will be ready to edit.');
        } else if (isAppLoaded) {
          const api = getAPI();
          if (api) {
            // Apply the last snapshot's state instead of initial state
            // This shows the final state with all settings that were active at the end
            if (currentTutorial.snapshots.length > 0) {
              const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
              api.setState(lastSnapshot.state);
            } else {
              api.setState(currentTutorial.initialState);
            }
          }
          
          // Set up recording state as if we just paused
          isRecording = true;
          isPaused = true;
          recordingStartTime = Date.now(); // Start recording from NOW
          pauseStartTime = Date.now(); // Set pause start time for correct resume calculation
          totalPausedTime = 0;
          importedDurationOffset = currentTutorial.duration || 0; // Offset new events by imported duration
          
          // Set up event listener (so we can continue recording)
          eventListener = (event) => {
            const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
            const snapshot = {
              timestamp: timestamp,
              event: event,
              state: api.getState()
            };
            currentTutorial.snapshots.push(snapshot);
            renderTimeline();
          };
          api.onAction(eventListener);
          
          // Show paused recording UI
          startRecording.style.display = 'inline-block';
          startRecording.textContent = '‚è∫ Record';
          startRecording.classList.remove('recording-active');
          startRecording.className = 'record';
          loadJSON.style.display = 'none';
          playPauseRecording.style.display = 'none';
          recordingIndicator.style.display = 'none';
          pausedIndicator.style.display = 'none';
          addAnnotation.style.display = 'inline-block';
          addAnnotation.disabled = false;
          addAnnotationAtPause.style.display = 'none';
          addPause.style.display = 'inline-block';
          addPause.disabled = false;
          previewRecording.style.display = 'inline-block';
          previewRecording.disabled = false;
          recordAgain.style.display = 'inline-block';
          recordAgain.disabled = false;
          exportRecording.style.display = 'inline-block';
          exportRecording.disabled = false;
          
          renderTimeline();
          
          // Position playhead at the end of the imported tutorial
          const timelineStartOffset = getTimelineStartOffset();
          const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
          timelinePlayhead.style.left = timelineEndPosition + 'px';
          timelinePlayhead.style.display = 'block';
          
          alert('‚úì Tutorial loaded!\n\nYou can now:\n‚Ä¢ Preview it\n‚Ä¢ Resume recording to add more\n‚Ä¢ Add/edit annotations\n‚Ä¢ Export when done');
        }
        
        console.log('üì§ Tutorial imported');
      } catch (err) {
        alert('Error importing tutorial: ' + err.message);
        console.error('Import error:', err);
      }
    };
    
    reader.readAsText(file);
    jsonFileInput.value = '';
  });
  
  // ========== HELP ==========
  
  helpBtn.addEventListener('click', () => {
    helpModal.classList.add('visible');
  });
  
  closeHelpModal.addEventListener('click', () => {
    helpModal.classList.remove('visible');
  });
  
  helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
      helpModal.classList.remove('visible');
    }
  });
  
  exportModal.addEventListener('click', (e) => {
    if (e.target === exportModal) {
      exportModal.classList.remove('visible');
    }
  });
  
  annotationEditorModal.addEventListener('click', (e) => {
    if (e.target === annotationEditorModal) {
      annotationEditorModal.classList.remove('visible');
    }
  });
  
  // Window resize handler - adding logging to debug annotation positioning issues
  window.addEventListener('resize', () => {
    console.log('üîç WINDOW RESIZE - Event triggered');
    console.log('  New window dimensions:', {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    });
    console.log('  Iframe dimensions after resize:', {
      offsetWidth: appFrame.offsetWidth,
      offsetHeight: appFrame.offsetHeight,
      clientWidth: appFrame.clientWidth,
      clientHeight: appFrame.clientHeight
    });
    
    if (currentAnnotationBox) {
      console.log('üîç WINDOW RESIZE - Current annotation box exists');
      try {
        const isInIframe = appFrame.contentDocument && appFrame.contentDocument.contains(currentAnnotationBox);
        console.log('  Annotation box is inside iframe:', isInIframe);
        
        if (isInIframe) {
          const iframeDoc = appFrame.contentDocument;
          const computedStyles = iframeDoc.defaultView.getComputedStyle(currentAnnotationBox);
          console.log('  Iframe annotation position after resize:', {
            left: computedStyles.left,
            top: computedStyles.top,
            width: computedStyles.width,
            height: computedStyles.height
          });
          console.log('  Iframe annotation getBoundingClientRect():', currentAnnotationBox.getBoundingClientRect());
        } else {
          console.log('  Main document annotation position after resize:', {
            left: currentAnnotationBox.style.left,
            top: currentAnnotationBox.style.top,
            width: currentAnnotationBox.style.width,
            height: currentAnnotationBox.style.height
          });
          console.log('  Main document annotation getBoundingClientRect():', currentAnnotationBox.getBoundingClientRect());
        }
      } catch (e) {
        console.log('  Error checking annotation box during resize:', e.message);
      }
    } else {
      console.log('üîç WINDOW RESIZE - No current annotation box');
    }
  });
  
  console.log('Tutorial Creator v12.69 initialized - Debug logging added for annotation positioning issues');
})();
</script>
</body>
</html>
