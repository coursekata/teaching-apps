<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tutorial Player - v2.3</title>

<!--
  LOADING TUTORIALS - THREE METHODS:
  
  METHOD 1 (RECOMMENDED): Load from URL parameter
  =====================================================
  Upload your tutorial JSON to GitHub (or any static host), then link to the player with:
  
  player.html?tutorial=https://username.github.io/tutorials/lesson1.json
  
  This is the cleanest approach:
  - One player file for all tutorials
  - Update tutorials without touching the player
  - Easy to share and maintain
  
  
  METHOD 2: Embed tutorial in HTML
  =====================================================
  For a completely self-contained single file, add a script tag before the other
  scripts that sets window.TUTORIAL_DATA:
  
  <script>
  window.TUTORIAL_DATA = {
    "version": "9.32",
    "appUrl": "https://your-app-url.com",
    "initialState": { ... },
    "snapshots": [ ... ],
    "annotations": [ ... ],
    "pauses": [ ... ],
    "duration": 12345
  };
  </script>
  
  Just copy your exported JSON and paste it as the value of TUTORIAL_DATA.
  
  
  METHOD 3: File upload
  =====================================================
  The player shows a file picker by default if no tutorial is provided.
  Good for local testing.
-->

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font: 14px/1.4 system-ui, -apple-system, sans-serif;
    background: #f5f5f5;
  }
  
  .player-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
  }
  
  .version-number {
    color: #666;
    font-size: 12px;
    font-weight: 500;
  }
  
  .app-frame-container {
    position: relative;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    overflow: hidden;
    width: 1000px;
    margin: 0 auto;
  }
  
  iframe {
    width: 1000px;
    height: 700px;
    border: none;
    display: block;
  }
  
  .annotation-box {
    position: absolute;
    width: 250px;
    max-width: 500px;
    background: rgba(255,255,255,0.98);
    border: 3px solid #2563eb;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    z-index: 100;
    display: none;
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  .annotation-box.visible {
    display: block;
    animation: fadeIn 0.3s ease-out;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .annotation-box h3 {
    margin: 0 0 12px;
    color: #2563eb;
    font-size: 18px;
  }
  
  .annotation-box p {
    margin: 0;
    line-height: 1.6;
    font-size: 15px;
  }
  
  .load-tutorial {
    background: #fff;
    padding: 32px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
  }
  
  .load-tutorial h2 {
    margin: 0 0 20px;
    color: #111;
  }
  
  .load-tutorial input[type="file"] {
    display: none;
  }
  
  .load-tutorial label {
    display: inline-block;
    padding: 12px 24px;
    background: #2563eb;
    color: #fff;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
  }
  
  .load-tutorial label:hover {
    background: #1d4ed8;
  }
  
  .error {
    background: #fee;
    border: 1px solid #fcc;
    color: #c00;
    padding: 12px;
    border-radius: 6px;
    margin-top: 16px;
  }
</style>
</head>
<body>

<div class="player-container">
  <div id="loadSection" class="load-tutorial">
    <h2>Load Tutorial</h2>
    <p style="color: #666; margin-bottom: 20px;">Select a tutorial JSON file to begin</p>
    <input type="file" id="tutorialFile" accept=".json" />
    <label for="tutorialFile">Choose Tutorial File</label>
    <div id="errorMsg" class="error" style="display:none;"></div>
  </div>
  
  <div id="playerSection" style="display:none;">
    <div class="app-frame-container">
      <iframe id="appFrame"></iframe>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';
  
  // Elements
  const loadSection = document.getElementById('loadSection');
  const playerSection = document.getElementById('playerSection');
  const tutorialFile = document.getElementById('tutorialFile');
  const errorMsg = document.getElementById('errorMsg');
  const appFrame = document.getElementById('appFrame');
  
  // Control elements (will be injected into iframe)
  let prevBtn = null;
  let nextBtn = null;
  let segmentIndicator = null;
  
  // State
  let tutorial = null;
  let segments = []; // Array of {start, end} for each segment
  let currentSegment = 0;
  let isPlaying = false;
  let playbackStartTime = 0;
  let currentTime = 0;
  let animationFrame = null;
  let annotationBox = null;
  let currentAnnotationIndex = -1;
  let annotationTimeout = null;
  let atSegmentEnd = false; // Track if we're paused at the end of a segment
  let lastLeftButtonPressTime = 0; // Track for double-press detection
  
  // Check for embedded tutorial
  const embeddedTutorial = window.TUTORIAL_DATA || null;
  
  // Check for tutorial URL parameter
  const urlParams = new URLSearchParams(window.location.search);
  const tutorialUrl = urlParams.get('tutorial') || urlParams.get('json');
  
  // Auto-load tutorial from URL parameter if present
  if (tutorialUrl) {
    loadSection.style.display = 'none';
    const loadingMsg = document.createElement('div');
    loadingMsg.style.cssText = 'text-align:center;padding:40px;color:#666;';
    loadingMsg.textContent = 'Loading tutorial...';
    document.querySelector('.player-container').insertBefore(loadingMsg, playerSection);
    
    fetch(tutorialUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to load tutorial: ' + response.statusText);
        }
        return response.json();
      })
      .then(data => {
        console.log('ðŸ“¥ Raw data received from fetch:', data);
        console.log('ðŸ“¥ Annotations key exists?', 'annotations' in data);
        console.log('ðŸ“¥ Annotations value:', data.annotations);
        console.log('ðŸ“¥ Annotations is array?', Array.isArray(data.annotations));
        
        tutorial = data;
        
        // Validate tutorial - only initialState and snapshots are required
        if (!tutorial.initialState || !tutorial.snapshots) {
          throw new Error('Invalid tutorial format');
        }
        
        // Backward compatibility: add empty arrays if missing
        if (!tutorial.annotations) {
          console.log('âš ï¸ No annotations property found, creating empty array');
          tutorial.annotations = [];
        }
        if (!tutorial.pauses) {
          tutorial.pauses = [];
        }
        
        console.log('ðŸ“¤ Tutorial parsed from URL');
        console.log('  Snapshots:', tutorial.snapshots.length);
        console.log('  Annotations in data:', tutorial.annotations.length);
        console.log('  Pauses:', tutorial.pauses ? tutorial.pauses.length : 0);
        if (tutorial.annotations && tutorial.annotations.length > 0) {
          console.log('  First annotation:', tutorial.annotations[0]);
        }
        
        // Check for app URL
        if (!tutorial.appUrl) {
          throw new Error('This tutorial does not contain an app URL. Please use a tutorial created with v12.31 or later.');
        }
        
        loadingMsg.remove();
        loadApp();
      })
      .catch(err => {
        loadingMsg.remove();
        loadSection.style.display = 'block';
        showError('Error loading tutorial from URL: ' + err.message);
      });
  }
  // Auto-load embedded tutorial if present
  else if (embeddedTutorial) {
    try {
      tutorial = embeddedTutorial;
      
      // Validate tutorial - only initialState and snapshots are required
      if (!tutorial.initialState || !tutorial.snapshots) {
        throw new Error('Invalid tutorial format');
      }
      
      // Backward compatibility: add empty arrays if missing
      if (!tutorial.annotations) {
        tutorial.annotations = [];
      }
      if (!tutorial.pauses) {
        tutorial.pauses = [];
      }
      
      // Check for app URL
      if (!tutorial.appUrl) {
        showError('This tutorial does not contain an app URL. Please use a tutorial created with v12.31 or later.');
      } else {
        // Load the app
        loadApp();
      }
    } catch (err) {
      showError('Error loading embedded tutorial: ' + err.message);
    }
  }
  
  // Load tutorial from file
  tutorialFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        tutorial = JSON.parse(event.target.result);
        
        // Validate tutorial - only initialState and snapshots are required
        if (!tutorial.initialState || !tutorial.snapshots) {
          throw new Error('Invalid tutorial format');
        }
        
        // Backward compatibility: add empty arrays if missing
        if (!tutorial.annotations) {
          tutorial.annotations = [];
        }
        if (!tutorial.pauses) {
          tutorial.pauses = [];
        }
        
        console.log('ðŸ“¤ Tutorial parsed from file');
        console.log('  Snapshots:', tutorial.snapshots.length);
        console.log('  Annotations in data:', tutorial.annotations.length);
        console.log('  Pauses:', tutorial.pauses ? tutorial.pauses.length : 0);
        if (tutorial.annotations && tutorial.annotations.length > 0) {
          console.log('  First annotation:', tutorial.annotations[0]);
        }
        
        // Check for app URL
        if (!tutorial.appUrl) {
          showError('This tutorial does not contain an app URL. Please use a tutorial created with v12.31 or later.');
          return;
        }
        
        // Load the app
        loadApp();
        
      } catch (err) {
        showError('Error loading tutorial: ' + err.message);
      }
    };
    reader.readAsText(file);
  });
  
  function showError(msg) {
    errorMsg.textContent = msg;
    errorMsg.style.display = 'block';
  }
  
  function loadApp() {
    loadSection.style.display = 'none';
    playerSection.style.display = 'block';
    
    appFrame.src = tutorial.appUrl;
    
    // Wait for iframe to load
    appFrame.addEventListener('load', () => {
      // Poll for API
      const checkAPI = setInterval(() => {
        const api = getAPI();
        if (api) {
          clearInterval(checkAPI);
          console.log('âœ“ API ready');
          
          // Set initial state
          api.setState(tutorial.initialState);
          
          // Inject annotation box
          injectAnnotationBox();
          
          // Inject controls into iframe
          injectControls();
          
          // Build segments from pauses
          buildSegments();
          
          console.log('Tutorial loaded:', tutorial.snapshots.length, 'snapshots,', tutorial.annotations.length, 'annotations', tutorial.pauses.length, 'pauses');
          console.log('Segments:', segments.length);
        }
      }, 100);
      
      setTimeout(() => {
        clearInterval(checkAPI);
      }, 5000);
    });
  }
  
  function buildSegments() {
    if (!tutorial) return;
    
    segments = [];
    
    if (!tutorial.pauses || tutorial.pauses.length === 0) {
      // No pauses - entire tutorial is one segment
      segments.push({ start: 0, end: tutorial.duration });
    } else {
      // Sort pauses by timestamp
      const pauses = [...tutorial.pauses].sort((a, b) => a.timestamp - b.timestamp);
      
      // First segment: 0 to first pause
      segments.push({ start: 0, end: pauses[0].timestamp });
      
      // Middle segments: pause to pause
      for (let i = 0; i < pauses.length - 1; i++) {
        segments.push({ start: pauses[i].timestamp, end: pauses[i + 1].timestamp });
      }
      
      // Last segment: last pause to end
      segments.push({ start: pauses[pauses.length - 1].timestamp, end: tutorial.duration });
    }
    
    console.log('Built', segments.length, 'segments:', segments.map((s, i) => 
      `Segment ${i + 1}: ${(s.start / 1000).toFixed(2)}s - ${(s.end / 1000).toFixed(2)}s`
    ));
    updateSegmentIndicator();
  }
  
  function updateSegmentIndicator() {
    if (segmentIndicator) {
      segmentIndicator.textContent = `${currentSegment + 1} / ${segments.length}`;
    }
    
    // Update button states
    if (prevBtn) {
      prevBtn.disabled = currentSegment === 0 && !atSegmentEnd;
    }
    if (nextBtn) {
      nextBtn.disabled = false; // Always enabled - resets to beginning at end
    }
  }
  
  function handlePrevious() {
    const now = Date.now();
    const timeSinceLastPress = now - lastLeftButtonPressTime;
    lastLeftButtonPressTime = now;
    
    if (isPlaying) {
      pause();
    }
    
    // Double-press detection (within 500ms)
    if (timeSinceLastPress < 500 && currentSegment > 0) {
      // Double press: go to previous segment and pause
      currentSegment--;
      console.log('â—„â—„ Going to previous segment', currentSegment + 1, '(paused)');
      atSegmentEnd = false;
      updateSegmentIndicator();
      seekToTime(segments[currentSegment].start);
      currentTime = segments[currentSegment].start;
    } else {
      // Single press: replay current segment
      console.log('â—„ Replaying segment', currentSegment + 1);
      atSegmentEnd = false;
      playSegment(currentSegment);
    }
  }
  
  function handlePlayPause() {
    if (isPlaying) {
      // Currently playing - pause at current position
      pause();
      console.log('â¸ Paused at', (currentTime / 1000).toFixed(2) + 's');
      return;
    }
    
    // Currently paused - determine what to do
    if (atSegmentEnd) {
      // At end of a segment - advance to next
      if (currentSegment >= segments.length - 1) {
        // At last segment - reset to beginning
        console.log('â–º Resetting to beginning');
        currentSegment = 0;
        atSegmentEnd = false;
        updateSegmentIndicator();
        playSegment(currentSegment);
      } else {
        // Move to next segment
        currentSegment++;
        atSegmentEnd = false;
        updateSegmentIndicator();
        console.log('â–º Playing next segment', currentSegment + 1);
        playSegment(currentSegment);
      }
    } else {
      // Mid-segment - resume from current position
      resume();
    }
  }
  
  function playSegment(segmentIndex) {
    const segment = segments[segmentIndex];
    
    // Set start time for this segment
    currentTime = segment.start;
    playbackStartTime = Date.now() - currentTime;
    
    // Seek to start of segment
    seekToTime(currentTime);
    
    // Start playing
    isPlaying = true;
    
    // Change icon to pause
    if (nextBtn) {
      nextBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="5" width="3" height="10" fill="currentColor"/><rect x="11" y="5" width="3" height="10" fill="currentColor"/></svg>';
      nextBtn.title = 'Pause';
    }
    
    console.log('â–¶ Playing segment', segmentIndex + 1, 'from', (segment.start / 1000).toFixed(2) + 's', 'to', (segment.end / 1000).toFixed(2) + 's');
    
    animationFrame = requestAnimationFrame(playbackLoop);
  }
  
  function getAPI() {
    try {
      return appFrame.contentWindow.tutorialAPI;
    } catch (e) {
      return null;
    }
  }
  
  function injectAnnotationBox() {
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    if (!iframeDoc) return;
    
    annotationBox = iframeDoc.createElement('div');
    annotationBox.className = 'annotation-box';
    
    // Inject styles
    const style = iframeDoc.createElement('style');
    style.textContent = `
      .annotation-box {
        position: absolute;
        width: 250px;
        max-width: 500px;
        background: rgba(255,255,255,0.98);
        border: 3px solid #2563eb;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        z-index: 100;
        display: none;
        overflow-y: auto;
        overflow-x: hidden;
        box-sizing: border-box;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        font-size: 15px;
        line-height: 1.6;
      }
      .annotation-box.custom-position {
        max-width: none;
      }
      .annotation-box.visible {
        display: block;
        animation: fadeIn 0.3s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .annotation-box h3 {
        margin: 0 0 12px;
        color: #2563eb;
        font-size: 18px;
        line-height: 1.3;
      }
      .annotation-box p {
        margin: 0;
        line-height: inherit;
        font-size: inherit;
      }
    `;
    iframeDoc.head.appendChild(style);
    iframeDoc.body.appendChild(annotationBox);
  }
  
  function injectControls() {
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    if (!iframeDoc) return;
    
    // Create controls container
    const controlsContainer = iframeDoc.createElement('div');
    controlsContainer.id = 'tutorial-controls';
    
    // Create Previous button
    prevBtn = iframeDoc.createElement('button');
    prevBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 5L8 10L13 15"/></svg>';
    prevBtn.title = 'Previous segment / Replay';
    prevBtn.className = 'tutorial-nav-btn';
    
    // Create segment indicator
    segmentIndicator = iframeDoc.createElement('div');
    segmentIndicator.className = 'tutorial-segment-indicator';
    segmentIndicator.textContent = '1 / 1';
    
    // Create Next button
    nextBtn = iframeDoc.createElement('button');
    nextBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 5L12 10L7 15"/></svg>';
    nextBtn.title = 'Next segment';
    nextBtn.className = 'tutorial-nav-btn';
    
    // Add to container
    controlsContainer.appendChild(prevBtn);
    controlsContainer.appendChild(segmentIndicator);
    controlsContainer.appendChild(nextBtn);
    
    // Add controls to iframe body
    iframeDoc.body.appendChild(controlsContainer);
    
    // Add styles
    const controlStyles = iframeDoc.createElement('style');
    controlStyles.textContent = `
      #tutorial-controls {
        position: fixed;
        bottom: 40px;
        left: 80px;
        display: flex;
        align-items: center;
        gap: 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 10px 18px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        z-index: 10000;
        font-family: system-ui, -apple-system, sans-serif;
        cursor: move;
        user-select: none;
      }
      
      .tutorial-nav-btn {
        width: 40px;
        height: 40px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        cursor: pointer;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        padding: 0;
        color: #667eea;
        font-weight: bold;
      }
      
      .tutorial-nav-btn:hover:not(:disabled) {
        background: #fff;
        border-color: rgba(255, 255, 255, 0.8);
        transform: scale(1.1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }
      
      .tutorial-nav-btn:active:not(:disabled) {
        transform: scale(0.95);
      }
      
      .tutorial-nav-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      
      .tutorial-segment-indicator {
        font-size: 14px;
        color: #fff;
        font-weight: 600;
        min-width: 50px;
        text-align: center;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }
    `;
    iframeDoc.head.appendChild(controlStyles);
    
    // Add event listeners
    prevBtn.addEventListener('click', handlePrevious);
    nextBtn.addEventListener('click', handlePlayPause);
    
    // Make controller draggable
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let controlStartLeft = 0;
    let controlStartBottom = 0;
    
    controlsContainer.addEventListener('mousedown', (e) => {
      // Don't drag if clicking on buttons
      if (e.target.closest('button')) return;
      
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      
      const style = iframeDoc.defaultView.getComputedStyle(controlsContainer);
      controlStartLeft = parseInt(style.left) || 0;
      controlStartBottom = parseInt(style.bottom) || 0;
      
      controlsContainer.style.cursor = 'grabbing';
      e.preventDefault();
    });
    
    iframeDoc.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - dragStartX;
      const deltaY = -(e.clientY - dragStartY); // Negative because bottom positioning
      
      const newLeft = controlStartLeft + deltaX;
      const newBottom = controlStartBottom + deltaY;
      
      // Keep within bounds
      const maxLeft = iframeDoc.documentElement.clientWidth - controlsContainer.offsetWidth;
      const maxBottom = iframeDoc.documentElement.clientHeight - controlsContainer.offsetHeight;
      
      controlsContainer.style.left = Math.max(0, Math.min(maxLeft, newLeft)) + 'px';
      controlsContainer.style.bottom = Math.max(0, Math.min(maxBottom, newBottom)) + 'px';
    });
    
    iframeDoc.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        controlsContainer.style.cursor = 'move';
      }
    });
  }
  
  // Play/Pause
  function seekToTime(time) {
    const api = getAPI();
    if (!api) return;
    
    // Find the most recent snapshot before this time
    let targetState = tutorial.initialState;
    for (const snapshot of tutorial.snapshots) {
      if (snapshot.timestamp <= time) {
        targetState = snapshot.state;
      } else {
        break;
      }
    }
    api.setState(targetState);
    
    // Handle annotations at this time
    handleAnnotationsAtTime(time);
  }
  
  function handleAnnotationsAtTime(time) {
    if (!tutorial.annotations || tutorial.annotations.length === 0) {
      hideAnnotation();
      currentAnnotationIndex = -1;
      return;
    }
    
    // Find annotation that should be visible at this time
    let found = false;
    for (let i = 0; i < tutorial.annotations.length; i++) {
      const ann = tutorial.annotations[i];
      const annStart = ann.timestamp;
      const annEnd = ann.timestamp + ann.duration;
      
      if (time >= annStart && time < annEnd) {
        showAnnotation(ann);
        currentAnnotationIndex = i;
        found = true;
        break;
      }
    }
    
    if (!found) {
      hideAnnotation();
      currentAnnotationIndex = -1;
    }
  }
  
  function pause() {
    isPlaying = false;
    
    // Change icon back to play
    if (nextBtn) {
      nextBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 5L12 10L7 15"/></svg>';
      nextBtn.title = 'Next segment';
    }
    
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
      animationFrame = null;
    }
  }
  
  function resume() {
    // Continue playing from current position
    isPlaying = true;
    playbackStartTime = Date.now() - currentTime;
    
    // Change icon to pause
    if (nextBtn) {
      nextBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="5" width="3" height="10" fill="currentColor"/><rect x="11" y="5" width="3" height="10" fill="currentColor"/></svg>';
      nextBtn.title = 'Pause';
    }
    
    console.log('â–¶ Resuming from', (currentTime / 1000).toFixed(2) + 's');
    
    animationFrame = requestAnimationFrame(playbackLoop);
  }
  
  function playbackLoop() {
    if (!isPlaying) return;
    
    currentTime = Date.now() - playbackStartTime;
    const segment = segments[currentSegment];
    
    // Apply snapshots
    const api = getAPI();
    if (api) {
      for (const snapshot of tutorial.snapshots) {
        if (snapshot.timestamp <= currentTime && snapshot.timestamp > currentTime - 100) {
          api.setState(snapshot.state);
        }
      }
    }
    
    // Handle annotations
    handleAnnotations();
    
    // Check if we've reached the end of this segment
    if (currentTime >= segment.end) {
      pause();
      atSegmentEnd = true;
      updateSegmentIndicator();
      
      // If this is the last segment, check if tutorial ends with an annotation
      if (currentSegment === segments.length - 1) {
        let tutorialEndsWithAnnotation = false;
        
        if (tutorial.annotations && tutorial.annotations.length > 0) {
          const lastAnn = tutorial.annotations[tutorial.annotations.length - 1];
          const annEnd = lastAnn.timestamp + lastAnn.duration;
          const tolerance = 100; // 100ms tolerance
          
          if (Math.abs(annEnd - tutorial.duration) < tolerance) {
            tutorialEndsWithAnnotation = true;
            // Show the last annotation
            showAnnotation(lastAnn);
            currentAnnotationIndex = tutorial.annotations.length - 1;
            console.log('âœ“ Tutorial ends with annotation - keeping it visible');
          }
        }
        
        if (!tutorialEndsWithAnnotation) {
          console.log('âœ“ Final segment complete');
        }
      } else {
        console.log('âœ“ Segment', currentSegment + 1, 'complete');
      }
      
      return;
    }
    
    animationFrame = requestAnimationFrame(playbackLoop);
  }
  
  function handleAnnotations() {
    if (!tutorial.annotations || tutorial.annotations.length === 0) {
      return;
    }
    
    for (let i = 0; i < tutorial.annotations.length; i++) {
      const ann = tutorial.annotations[i];
      const annStart = ann.timestamp;
      const annEnd = ann.timestamp + ann.duration;
      
      // Show annotation if we're in its time range
      if (currentTime >= annStart && currentTime < annEnd) {
        if (currentAnnotationIndex !== i) {
          console.log(`ðŸ“ Time ${(currentTime / 1000).toFixed(2)}s: Showing annotation ${i} "${ann.title}" (range: ${(annStart / 1000).toFixed(2)}s-${(annEnd / 1000).toFixed(2)}s)`);
          showAnnotation(ann);
          currentAnnotationIndex = i;
        }
        return;
      }
    }
    
    // Hide annotation if we're not in any range
    if (currentAnnotationIndex !== -1) {
      console.log(`ðŸ“ Time ${(currentTime / 1000).toFixed(2)}s: Hiding annotation`);
      hideAnnotation();
      currentAnnotationIndex = -1;
    }
  }
  
  function applyCSSToAnnotation(ann, annotationBox) {
    // EITHER/OR approach: use global styles OR custom CSS, never both
    const hasClassAttribute = ann.content && ann.content.includes('class=');
    
    if (hasClassAttribute && tutorial && tutorial.globalStyles) {
      // OPTION 1: Using global styles - inject them and make container transparent
      console.log('ðŸŽ¨ Applying GLOBAL STYLES - making container transparent wrapper');
      injectGlobalStyles();
      
      // Make container completely transparent - it's just a positioning/sizing wrapper
      annotationBox.style.backgroundColor = 'transparent';
      annotationBox.style.border = 'none';
      annotationBox.style.borderRadius = '0';
      annotationBox.style.boxShadow = 'none';
      annotationBox.style.padding = '0';
      annotationBox.style.margin = '0';
      annotationBox.style.overflow = 'visible';
      
      // Positioning properties
      annotationBox.style.position = 'absolute';
      annotationBox.style.zIndex = '10000';
      annotationBox.style.opacity = '1';
      annotationBox.style.visibility = 'visible';
      
      console.log('ðŸŽ¨ Container configured as transparent wrapper for global-styled content');
    } else if (ann.customCSS && ann.customCSS.trim()) {
      // OPTION 2: Using custom CSS - apply it directly to container
      console.log('ðŸŽ¨ Applying CUSTOM CSS to container:', ann.customCSS);
      annotationBox.style.cssText += '; ' + ann.customCSS.trim();
    }
  }
  
  function injectGlobalStyles() {
    if (!tutorial || !tutorial.globalStyles) return;
    
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    if (!iframeDoc) return;
    
    // Check if we already injected global styles
    let styleEl = iframeDoc.getElementById('tutorial-global-styles');
    
    if (!styleEl) {
      // Create and inject the global styles
      styleEl = iframeDoc.createElement('style');
      styleEl.id = 'tutorial-global-styles';
      styleEl.textContent = tutorial.globalStyles;
      iframeDoc.head.appendChild(styleEl);
      console.log('âœ“ Injected global styles into iframe');
    } else {
      // Update existing styles (in case they changed)
      styleEl.textContent = tutorial.globalStyles;
      console.log('âœ“ Updated global styles in iframe');
    }
  }
  
  function showAnnotation(ann) {
    console.log('ðŸŽ¯ showAnnotation called:', ann);
    
    if (!annotationBox) {
      console.error('âŒ annotationBox is null!');
      return;
    }
    
    // Handle content - support both new flexible format and old title/text format for backward compatibility
    if (ann.content !== undefined) {
      // New format: single content field with HTML support
      console.log('  Using new content format');
      annotationBox.innerHTML = ann.content;
    } else if (ann.title && ann.text) {
      // Backward compatibility: old format
      console.log('  Using old title/text format');
      annotationBox.innerHTML = `<h3>${ann.title}</h3><p>${ann.text}</p>`;
    } else {
      console.error('  Annotation has no content!');
      return;
    }
    
    // Apply EITHER/OR styling: global styles OR custom CSS OR defaults
    const hasClassAttribute = ann.content && ann.content.includes('class=');
    
    if (hasClassAttribute && tutorial && tutorial.globalStyles) {
      // Using global styles
      console.log('ðŸŽ¨ Using GLOBAL STYLES');
      injectGlobalStyles();
      applyCSSToAnnotation(ann, annotationBox);
    } else if (ann.customCSS && ann.customCSS.trim()) {
      // Using custom CSS
      console.log('ðŸŽ¨ Using CUSTOM CSS');
      applyCSSToAnnotation(ann, annotationBox);
    } else {
      // Default styles - set explicit properties to match creator behavior
      console.log('ðŸŽ¨ Using DEFAULT STYLES');
      annotationBox.style.backgroundColor = 'rgba(255,255,255,0.98)';
      annotationBox.style.color = '#333333';
      annotationBox.style.fontSize = '15px';
      annotationBox.style.textAlign = 'left';
      annotationBox.style.border = '3px solid #2563eb';
    }
    
    // Position annotation
    if (ann.position) {
      console.log('  Using custom position');
      console.log('    left:', ann.position.left);
      console.log('    top:', ann.position.top);
      console.log('    width:', ann.position.width);
      console.log('    height:', ann.position.height);
      
      // Custom positioned annotation
      annotationBox.className = 'annotation-box visible custom-position';
      annotationBox.style.left = ann.position.left + 'px';
      annotationBox.style.top = ann.position.top + 'px';
      annotationBox.style.width = ann.position.width + 'px';
      annotationBox.style.height = ann.position.height + 'px';
      annotationBox.style.transform = 'none';
      
      console.log('  Applied position styles:', {
        left: annotationBox.style.left,
        top: annotationBox.style.top,
        width: annotationBox.style.width,
        height: annotationBox.style.height
      });
    } else {
      console.log('  Using default center position');
      // Default center position
      annotationBox.classList.remove('custom-position');
      annotationBox.style.left = '50%';
      annotationBox.style.top = '50%';
      annotationBox.style.transform = 'translate(-50%, -50%)';
      annotationBox.style.width = '250px';
      annotationBox.style.height = 'auto';
    }
    
    annotationBox.classList.add('visible');
    console.log('  âœ“ Annotation box visible class added');
    
    // Typeset math if present
    const contentToCheck = ann.content || ann.text || '';
    if (window.MathJax && contentToCheck.includes('$')) {
      MathJax.typesetPromise([annotationBox]).catch(err => console.log('MathJax error:', err));
    }
  }
  
  function hideAnnotation() {
    if (annotationBox) {
      annotationBox.classList.remove('visible');
      annotationBox.classList.remove('custom-position');
    }
  }
  
  console.log('Tutorial Player v2.3 initialized - Play/Pause toggle control');
})();
</script>
</body>
</html>
