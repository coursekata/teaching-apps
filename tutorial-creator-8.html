<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Tutorial Creator - v11.37</title>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    },
    startup: {
      ready: () => {
        MathJax.startup.defaultReady();
      }
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  :root{
    --accent:#2563eb;
    --record:#ef4444;
    --success:#10b981;
    --warning:#f59e0b;
  }
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#111;
    background:#f5f5f5;
  }
  
  .tutorial-header{
    position: sticky;
    top: 0;
    background:#fff;
    border-bottom:2px solid #ddd;
    padding:12px 20px;
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .version-number{
    color: #666;
    font-size: 12px;
    font-weight: 500;
  }
  
  .tutorial-controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  button{
    padding:8px 14px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:13px;
  }
  
  button:hover:not(:disabled):not(.primary):not(.record):not(.success):not(.warning){
    background:#f9f9f9;
  }
  
  button:disabled{
    opacity:0.5;
    cursor:not-allowed;
  }
  
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button.record{
    background:var(--record);
    color:#fff;
    border-color:var(--record);
  }
  
  button.success{
    background:var(--success);
    color:#fff;
    border-color:var(--success);
  }
  
  button.warning{
    background:var(--warning);
    color:#fff;
    border-color:var(--warning);
  }
  
  button.record.recording{
    animation:pulse 1.5s infinite;
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.6}
  }
  
  .recording-indicator{
    background:var(--record);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
    animation:pulse 1.5s infinite;
  }
  
  .paused-indicator{
    background:var(--warning);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
  }
  
  .app-container{
    position:relative;
    width:100%;
    height:800px;
    overflow:hidden;
    margin-bottom:40px;
  }
  
  iframe{
    width:100%;
    height:100%;
    border:none;
  }
  
  iframe.playback-mode{
    pointer-events:none;
  }
  
  .annotation-box{
    position:absolute;
    width:250px;
    max-width:500px;
    background:rgba(255,255,255,0.98);
    border:3px solid var(--accent);
    border-radius:12px;
    padding:20px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15);
    z-index:100;
    display:none;
    overflow-y:auto;
    overflow-x:hidden;
  }
  
  .annotation-box.custom-position{
    max-width:none;
  }
  
  .annotation-box.draggable{
    overflow:hidden;
    cursor:move;
    border-color:var(--warning);
    border-style:dashed;
    border-width:4px;
    background:#fff;
    box-shadow:0 12px 32px rgba(0,0,0,0.3);
    z-index:10001;
  }
  
  .annotation-box.visible{
    display:block;
    animation:slideIn 0.3s ease-out;
  }
  
  .annotation-box.draggable .resize-handle{
    position:absolute;
    bottom:0;
    right:0;
    width:20px;
    height:20px;
    background:var(--warning);
    cursor:nwse-resize;
    border-top-left-radius:4px;
    border-bottom-right-radius:12px;
  }
  
  .annotation-box.draggable .resize-handle::after{
    content:'⋰';
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    color:#fff;
    font-size:14px;
    line-height:1;
  }
  
  @keyframes slideIn{
    from{opacity:0;}
    to{opacity:1;}
  }
  
  .annotation-box h3{
    margin:0 0 12px;
    color:var(--accent);
    font-size:18px;
  }
  
  .annotation-box p{
    margin:0;
    line-height:1.6;
    font-size:15px;
  }
  
  /* Timeline Editor */
  .timeline-container{
    background:#fff;
    border-top:2px solid #ddd;
    border-bottom:2px solid #ddd;
    padding:4px 20px 6px 20px;
    display:none;
    position:relative;
    margin-bottom:8px;
  }
  
  .timeline-container.visible{
    display:block;
  }
  
  .timeline-ruler{
    height:14px;
    position:relative;
    margin-bottom:0px;
    margin-left:60px;
    overflow:hidden;
  }
  
  .timeline-tick{
    position:absolute;
    top:0;
    font-size:8px;
    color:#999;
  }
  
  .timeline-track{
    height:26px;
    background:#fafafa;
    border:1px solid #ddd;
    border-radius:4px;
    position:relative;
    margin-bottom:2px;
    overflow:hidden;
    padding-left:60px;
  }
  
  .timeline-track-label{
    position:absolute;
    left:4px;
    top:50%;
    transform:translateY(-50%);
    font-size:9px;
    font-weight:600;
    color:#666;
    pointer-events:none;
    z-index:0;
    width:55px;
    text-align:right;
    padding-right:5px;
  }
  
  .timeline-event{
    position:absolute;
    top:2px;
    bottom:2px;
    width:8px;
    background:#6366f1;
    border-radius:2px;
    cursor:move;
    z-index:1;
    transition:background 0.15s;
  }
  
  .timeline-event:hover{
    background:#4f46e5;
    box-shadow:0 0 0 2px rgba(99, 102, 241, 0.3);
  }
  
  .timeline-event.simulate{
    background:#10b981;
  }
  
  .timeline-event.simulate:hover{
    background:#059669;
    box-shadow:0 0 0 2px rgba(16, 185, 129, 0.3);
  }
  
  .timeline-pause{
    position:absolute;
    top:2px;
    bottom:2px;
    width:3px;
    background:#f59e0b;
    border-radius:1px;
    cursor:move;
    z-index:2;
    transition:background 0.15s;
  }
  
  .timeline-pause:hover{
    background:#d97706;
    box-shadow:0 0 0 2px rgba(245, 158, 11, 0.4);
    width:5px;
  }
  
  .timeline-annotation{
    position:absolute;
    top:2px;
    bottom:2px;
    background:#ec4899;
    border-radius:2px;
    cursor:move;
    z-index:1;
    transition:background 0.15s;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }
  
  .timeline-annotation:hover{
    background:#db2777;
    box-shadow:0 0 0 2px rgba(236, 72, 153, 0.3);
  }
  
  .timeline-annotation-label{
    font-size:7px;
    color:#fff;
    font-weight:600;
    white-space:nowrap;
    padding:0 2px;
    pointer-events:none;
  }
  
  .timeline-playhead{
    position:absolute;
    top:-2px;
    bottom:-2px;
    width:2px;
    background:#ef4444;
    z-index:10;
    pointer-events:none;
    display:none;
  }
  
  .timeline-playhead::before{
    content:'';
    position:absolute;
    top:0;
    left:50%;
    transform:translateX(-50%);
    width:0;
    height:0;
    border-left:4px solid transparent;
    border-right:4px solid transparent;
    border-top:6px solid #ef4444;
  }
  
  /* Event Context Menu */
  .event-context-menu{
    position:fixed;
    background:#fff;
    border:1px solid #ddd;
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
    padding:4px 0;
    z-index:1000;
    display:none;
    min-width:120px;
  }
  
  .event-context-menu.visible{
    display:block;
  }
  
  .event-context-menu button{
    display:block;
    width:100%;
    text-align:left;
    padding:8px 16px;
    border:none;
    background:none;
    cursor:pointer;
    font-size:13px;
    border-radius:0;
  }
  
  .event-context-menu button:hover{
    background:#f5f5f5;
  }
  
  .event-context-menu button:first-child{
    border-radius:8px 8px 0 0;
  }
  
  .event-context-menu button:last-child{
    border-radius:0 0 8px 8px;
  }
  
  /* Position Editor */
  .position-editor-overlay{
    position:absolute;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.5);
    z-index:10000;
    display:none;
    align-items:center;
    justify-content:center;
  }
  
  .position-editor-overlay.visible{
    display:flex;
  }
  
  .position-editor-controls{
    position:absolute;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    background:#fff;
    padding:16px 24px;
    border-radius:12px;
    box-shadow:0 8px 24px rgba(0,0,0,0.3);
    display:flex;
    gap:12px;
    z-index:10002;
  }
  
  /* Modals */
  .modal{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.5);
    z-index:1000;
    display:none;
    align-items:center;
    justify-content:center;
  }
  
  .modal.visible{
    display:flex;
  }
  
  .modal-content{
    background:#fff;
    border-radius:12px;
    padding:24px;
    max-width:600px;
    width:90%;
    max-height:80vh;
    overflow-y:auto;
    box-shadow:0 20px 60px rgba(0,0,0,0.3);
  }
  
  .modal-content h2{
    margin:0 0 16px;
    color:var(--accent);
  }
  
  .modal-content label{
    display:block;
    margin-bottom:8px;
    font-weight:600;
  }
  
  .modal-content input, .modal-content textarea{
    width:100%;
    padding:8px;
    border:1px solid #ddd;
    border-radius:6px;
    font-family:inherit;
    font-size:14px;
    margin-bottom:12px;
    box-sizing:border-box;
  }
  
  .modal-content textarea{
    min-height:100px;
    resize:vertical;
  }
  
  .modal-buttons{
    display:flex;
    gap:12px;
    margin-top:16px;
    justify-content:flex-end;
  }
  
  .export-stats{
    background:#f5f5f5;
    padding:12px;
    border-radius:8px;
    margin-bottom:16px;
    display:flex;
    gap:20px;
    font-size:13px;
  }
  
  .export-stats div{
    display:flex;
    align-items:center;
    gap:6px;
  }
  
  .export-stats strong{
    color:var(--accent);
  }
  
  textarea#exportTextarea{
    font-family:Monaco, Consolas, monospace;
    font-size:11px;
    min-height:300px;
  }
  
  .help-section{
    margin-bottom:20px;
  }
  
  .help-section h3{
    color:var(--accent);
    margin:0 0 8px;
    font-size:16px;
  }
  
  .help-section p, .help-section ul{
    margin:0 0 8px;
    line-height:1.6;
  }
  
  .help-section ul{
    padding-left:24px;
  }
  
  .help-section li{
    margin-bottom:4px;
  }
  
  .help-section code{
    background:#f5f5f5;
    padding:2px 6px;
    border-radius:4px;
    font-family:Monaco, Consolas, monospace;
    font-size:12px;
  }
</style>
</head>
<body>

<div class="tutorial-header">
  <div>
    <span style="font-weight:600; font-size:16px;">📚 Interactive Tutorial Creator</span>
    <span class="version-number">v11.37</span>
  </div>
  <div class="tutorial-controls">
    <button id="loadAppBtn" class="primary">📂 Load App</button>
    <button id="startRecording" style="display:none;">⏺ Start Recording</button>
    <button id="playPauseRecording" style="display:none;"></button>
    <span id="recordingIndicator" class="recording-indicator" style="display:none;">🔴 Recording</span>
    <span id="pausedIndicator" class="paused-indicator" style="display:none;">⏸ Paused</span>
    <button id="addAnnotation" style="display:none;">💬 Add Annotation</button>
    <button id="addPause" style="display:none;">⏸ Add Pause</button>
    <button id="playPreview" style="display:none;">▶️ Play</button>
    <button id="replayPreview" style="display:none;">🔄 Replay</button>
    <button id="addAnnotationAtPause" style="display:none;">💬 Add Annotation Here</button>
    <button id="recordAgain" style="display:none;">🔄 New Tutorial</button>
    <button id="exportRecording" style="display:none;">💾 Export</button>
    <button id="loadJSON">📥 Import</button>
    <button id="helpBtn">❓ Help</button>
    <input type="file" id="jsonFileInput" accept=".json" style="display:none;"/>
  </div>
</div>

<div id="timelineContainer" class="timeline-container">
  <div class="timeline-ruler" id="timelineRuler"></div>
  <div class="timeline-track">
    <div class="timeline-track-label">EVENTS</div>
    <div id="eventsTrack" style="position:relative;height:100%;"></div>
  </div>
  <div class="timeline-track">
    <div class="timeline-track-label">PAUSES</div>
    <div id="pausesTrack" style="position:relative;height:100%;"></div>
  </div>
  <div class="timeline-track">
    <div class="timeline-track-label">ANNOTATIONS</div>
    <div id="annotationsTrack" style="position:relative;height:100%;"></div>
  </div>
  <div id="timelinePlayhead" class="timeline-playhead"></div>
</div>

<div class="app-container">
  <iframe id="appFrame"></iframe>
  <div id="annotationBox" class="annotation-box">
    <h3 id="annotationTitle"></h3>
    <p id="annotationText"></p>
  </div>
</div>

<div id="positionEditorOverlay" class="position-editor-overlay">
  <div class="position-editor-controls">
    <button id="confirmPosition" class="primary">✓ Confirm Position</button>
    <button id="deleteAnnotation" class="record">🗑 Delete</button>
    <button id="cancelPosition">✗ Cancel</button>
  </div>
</div>

<div id="eventContextMenu" class="event-context-menu">
  <button id="deleteEvent">🗑 Delete Event</button>
</div>

<!-- Annotation Editor Modal -->
<div id="annotationEditorModal" class="modal">
  <div class="modal-content">
    <h2>Add Annotation</h2>
    <label for="annTitle">Title</label>
    <input type="text" id="annTitle" placeholder="Enter a title for the annotation"/>
    
    <label for="annText">Text (LaTeX supported: $x^2$ or $$\frac{a}{b}$$)</label>
    <textarea id="annText" placeholder="Enter the annotation text. Use $...$ for inline math or $$...$$ for display math."></textarea>
    
    <label for="annDuration">Duration (seconds)</label>
    <input type="number" id="annDuration" value="5" min="1" step="0.5"/>
    
    <div class="modal-buttons">
      <button id="cancelAnnotation">Cancel</button>
      <button id="createAnnotation" class="primary">Create & Position</button>
    </div>
  </div>
</div>

<!-- Export Modal -->
<div id="exportModal" class="modal">
  <div class="modal-content">
    <h2>Export Tutorial</h2>
    <div class="export-stats">
      <div>
        <strong id="snapshotCount">0</strong> events
      </div>
      <div>
        <strong id="annotationCount">0</strong> annotations
      </div>
    </div>
    <textarea id="exportTextarea" readonly></textarea>
    <div class="modal-buttons">
      <button id="downloadExport" class="primary">💾 Download JSON</button>
      <button id="copyExport">📋 Copy to Clipboard</button>
      <button id="closeExportModal">Close</button>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
  <div class="modal-content">
    <h2>Interactive Tutorial Creator Guide</h2>
    
    <div class="help-section">
      <h3>🚀 Quick Start</h3>
      <ol>
        <li><strong>Load Your App:</strong> Click "Load App" and enter the URL of your interactive application</li>
        <li><strong>Start Recording:</strong> Click "Start Recording" to begin capturing your interactions</li>
        <li><strong>Interact:</strong> Use your app normally - all interactions are captured automatically</li>
        <li><strong>Add Annotations:</strong> Click "Add Annotation" to add explanatory text boxes at any time</li>
        <li><strong>Preview:</strong> Click "Play" to watch your tutorial playback</li>
        <li><strong>Export:</strong> Click "Export" to save your tutorial as JSON</li>
      </ol>
    </div>
    
    <div class="help-section">
      <h3>⏯️ Recording Controls</h3>
      <ul>
        <li><strong>⏺ Start Recording:</strong> Begin capturing interactions with your app</li>
        <li><strong>⏸ Pause / ⏺ Resume:</strong> Temporarily pause recording (useful for preparation)</li>
        <li><strong>💬 Add Annotation:</strong> Create a text annotation at the current time</li>
        <li><strong>⏸ Add Pause:</strong> Insert a pause point where playback will stop and wait for user to continue</li>
        <li><strong>▶️ Play:</strong> Preview your tutorial from the beginning or resume from pause</li>
        <li><strong>🔄 Replay:</strong> Restart the tutorial from the beginning</li>
      </ul>
    </div>
    
    <div class="help-section">
      <h3>📝 Annotations</h3>
      <ul>
        <li>Annotations appear as overlay text boxes during playback</li>
        <li>Support LaTeX math: use <code>$x^2$</code> for inline or <code>$$\frac{a}{b}$$</code> for display math</li>
        <li>After creating an annotation, drag it to position and resize as needed</li>
        <li>Click "Confirm Position" when satisfied with the placement</li>
        <li>Edit annotations by clicking them in the timeline</li>
      </ul>
    </div>
    
    <div class="help-section">
      <h3>⏸️ Pause Events</h3>
      <ul>
        <li>Pause events stop tutorial playback at specific moments</li>
        <li>Useful for giving students time to think or try something themselves</li>
        <li>The user must click "Play" to continue after reaching a pause</li>
        <li>You can add annotations at pause points for extra context</li>
      </ul>
    </div>
    
    <div class="help-section">
      <h3>⏱️ Timeline Editor</h3>
      <ul>
        <li><strong>Blue markers:</strong> App interaction events</li>
        <li><strong>Green markers:</strong> Simulation/calculation events</li>
        <li><strong>Orange lines:</strong> Pause events (where playback stops)</li>
        <li><strong>Pink bars:</strong> Annotations (length shows duration)</li>
        <li><strong>Red line:</strong> Current playback position</li>
        <li>Drag events, pauses, and annotations to adjust timing</li>
        <li>Right-click events to delete them</li>
      </ul>
    </div>
    
    <div class="help-section">
      <h3>💾 Export & Import</h3>
      <ul>
        <li><strong>Export:</strong> Save tutorial as JSON file</li>
        <li><strong>Import:</strong> Load a saved tutorial to continue editing or preview</li>
        <li>After importing, you can continue recording, add more annotations, or export again</li>
        <li>The timeline shows the complete tutorial history</li>
      </ul>
    </div>
    
    <div class="help-section">
      <h3>💡 Tips</h3>
      <ul>
        <li>Use pause events to break tutorials into manageable chunks</li>
        <li>Keep annotations concise and focused on key points</li>
        <li>Test your tutorial with "Play" before exporting</li>
        <li>Position annotations carefully so they don't obscure important UI elements</li>
        <li>Annotations can be repositioned at any time by clicking them in the timeline</li>
      </ul>
    </div>
    
    <div class="modal-buttons">
      <button id="closeHelpModal" class="primary">Close</button>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';
  
  // ========== DOM ELEMENTS ==========
  const loadAppBtn = document.getElementById('loadAppBtn');
  const startRecording = document.getElementById('startRecording');
  const playPauseRecording = document.getElementById('playPauseRecording');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const pausedIndicator = document.getElementById('pausedIndicator');
  const addAnnotation = document.getElementById('addAnnotation');
  const addPause = document.getElementById('addPause');
  const playPreview = document.getElementById('playPreview');
  const replayPreview = document.getElementById('replayPreview');
  const addAnnotationAtPause = document.getElementById('addAnnotationAtPause');
  const recordAgain = document.getElementById('recordAgain');
  const exportRecording = document.getElementById('exportRecording');
  const loadJSON = document.getElementById('loadJSON');
  const jsonFileInput = document.getElementById('jsonFileInput');
  const helpBtn = document.getElementById('helpBtn');
  
  const timelineContainer = document.getElementById('timelineContainer');
  const timelineRuler = document.getElementById('timelineRuler');
  const eventsTrack = document.getElementById('eventsTrack');
  const pausesTrack = document.getElementById('pausesTrack');
  const annotationsTrack = document.getElementById('annotationsTrack');
  const timelinePlayhead = document.getElementById('timelinePlayhead');
  
  const appFrame = document.getElementById('appFrame');
  const annotationBox = document.getElementById('annotationBox');
  const annotationTitle = document.getElementById('annotationTitle');
  const annotationText = document.getElementById('annotationText');
  
  const positionEditorOverlay = document.getElementById('positionEditorOverlay');
  const confirmPosition = document.getElementById('confirmPosition');
  const deleteAnnotation = document.getElementById('deleteAnnotation');
  const cancelPosition = document.getElementById('cancelPosition');
  
  const eventContextMenu = document.getElementById('eventContextMenu');
  const deleteEvent = document.getElementById('deleteEvent');
  
  const annotationEditorModal = document.getElementById('annotationEditorModal');
  const annTitle = document.getElementById('annTitle');
  const annText = document.getElementById('annText');
  const annDuration = document.getElementById('annDuration');
  const createAnnotation = document.getElementById('createAnnotation');
  const cancelAnnotation = document.getElementById('cancelAnnotation');
  
  const exportModal = document.getElementById('exportModal');
  const snapshotCount = document.getElementById('snapshotCount');
  const annotationCount = document.getElementById('annotationCount');
  const exportTextarea = document.getElementById('exportTextarea');
  const downloadExport = document.getElementById('downloadExport');
  const copyExport = document.getElementById('copyExport');
  const closeExportModal = document.getElementById('closeExportModal');
  
  const helpModal = document.getElementById('helpModal');
  const closeHelpModal = document.getElementById('closeHelpModal');
  
  // ========== STATE ==========
  let isAppLoaded = false;
  let isRecording = false;
  let isPaused = false;
  let isPlaying = false;
  let isPreviewingFromPaused = false;
  
  let currentTutorial = null;
  let recordingStartTime = 0;
  let totalPausedTime = 0;
  let pauseStartTime = 0;
  let importedDurationOffset = 0;
  
  let eventListener = null;
  
  let playbackStartTime = 0;
  let playbackPausedAt = 0;
  let currentAnnotationIndex = -1;
  let annotationTimeout = null;
  
  let editingAnnotationIndex = -1;
  let isDraggingAnnotation = false;
  let isResizingAnnotation = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let resizeStartWidth = 0;
  let resizeStartHeight = 0;
  
  // Timeline drag state
  let draggingEvent = null;
  let draggingAnnotation = null;
  let draggingPause = null;
  let timelineScale = 50; // pixels per second
  
  // Context menu state
  let contextMenuTarget = null;
  
  // ========== API INTEGRATION ==========
  
  function getAPI() {
    try {
      return appFrame.contentWindow.tutorialAPI;
    } catch (e) {
      return null;
    }
  }
  
  // ========== APP LOADING ==========
  
  loadAppBtn.addEventListener('click', () => {
    const url = prompt('Enter the URL of your app (must support tutorial API):');
    if (!url) return;
    
    appFrame.src = url;
    
    appFrame.onload = () => {
      // Give the app a moment to initialize its API
      setTimeout(() => {
        const api = getAPI();
        if (api) {
          isAppLoaded = true;
          startRecording.style.display = 'inline-block';
          loadAppBtn.textContent = '✓ App Loaded';
          loadAppBtn.disabled = true;
          console.log('✅ App loaded with tutorial API');
        } else {
          alert('Error: App does not expose tutorialAPI. Please ensure your app implements the tutorial API.');
          appFrame.src = '';
        }
      }, 500);
    };
  });
  
  // ========== RECORDING ==========
  
  startRecording.addEventListener('click', () => {
    const api = getAPI();
    if (!api) return;
    
    // Initialize tutorial object
    currentTutorial = {
      initialState: api.getState(),
      snapshots: [],
      annotations: [],
      pauses: [],
      duration: 0
    };
    
    isRecording = true;
    isPaused = false;
    recordingStartTime = Date.now();
    totalPausedTime = 0;
    importedDurationOffset = 0;
    
    // Set up event listener
    eventListener = (event) => {
      const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
      const snapshot = {
        timestamp: timestamp,
        event: event,
        state: api.getState()
      };
      currentTutorial.snapshots.push(snapshot);
      
      // Update timeline
      renderTimeline();
    };
    
    api.onAction(eventListener);
    
    // Update UI
    startRecording.style.display = 'none';
    loadJSON.style.display = 'none';
    playPauseRecording.style.display = 'inline-block';
    playPauseRecording.textContent = '⏸ Pause';
    playPauseRecording.className = 'warning';
    recordingIndicator.style.display = 'inline-block';
    addAnnotation.style.display = 'inline-block';
    addAnnotation.disabled = false;
    addPause.style.display = 'inline-block';
    addPause.disabled = false;
    
    // Show timeline
    timelineContainer.classList.add('visible');
    
    console.log('🔴 Recording started');
  });
  
  playPauseRecording.addEventListener('click', () => {
    if (!isRecording) return;
    
    if (isPaused) {
      // Resume recording
      isPaused = false;
      totalPausedTime += Date.now() - pauseStartTime;
      
      playPauseRecording.textContent = '⏸ Pause';
      playPauseRecording.className = 'warning';
      recordingIndicator.style.display = 'inline-block';
      pausedIndicator.style.display = 'none';
      addAnnotation.disabled = false;
      addPause.disabled = false;
      playPreview.style.display = 'none';
      playPreview.disabled = true;
      recordAgain.style.display = 'none';
      recordAgain.disabled = true;
      exportRecording.style.display = 'none';
      exportRecording.disabled = true;
      
      console.log('⏺ Recording resumed');
    } else {
      // Pause recording
      isPaused = true;
      pauseStartTime = Date.now();
      
      playPauseRecording.textContent = '⏺ Resume';
      playPauseRecording.className = 'success';
      recordingIndicator.style.display = 'none';
      pausedIndicator.style.display = 'inline-block';
      addAnnotation.disabled = false;
      addPause.disabled = false;
      playPreview.style.display = 'inline-block';
      playPreview.disabled = false;
      recordAgain.style.display = 'inline-block';
      recordAgain.disabled = false;
      exportRecording.style.display = 'inline-block';
      exportRecording.disabled = false;
      
      // Recalculate duration when pausing
      recalculateTutorialDuration();
      
      console.log('⏸ Recording paused');
    }
  });
  
  addAnnotation.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Calculate current timestamp
    let currentTime;
    if (isPaused) {
      currentTime = pauseStartTime - recordingStartTime - totalPausedTime + importedDurationOffset;
    } else {
      currentTime = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
    }
    
    // Open modal
    annTitle.value = '';
    annText.value = '';
    annDuration.value = 5;
    annotationEditorModal.classList.add('visible');
  });
  
  addPause.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Calculate current timestamp
    let currentTime;
    if (isPaused) {
      currentTime = pauseStartTime - recordingStartTime - totalPausedTime + importedDurationOffset;
    } else {
      currentTime = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
    }
    
    // Add pause event
    currentTutorial.pauses.push({
      timestamp: currentTime
    });
    
    // Sort pauses by timestamp
    currentTutorial.pauses.sort((a, b) => a.timestamp - b.timestamp);
    
    // Update timeline
    recalculateTutorialDuration();
    renderTimeline();
    
    console.log('⏸ Pause event added at', (currentTime / 1000).toFixed(2) + 's');
  });
  
  createAnnotation.addEventListener('click', () => {
    const title = annTitle.value.trim();
    const text = annText.value.trim();
    const duration = parseFloat(annDuration.value) * 1000;
    
    if (!title || !text) {
      alert('Please enter both title and text');
      return;
    }
    
    // Calculate current timestamp
    let currentTime;
    if (isPaused) {
      currentTime = pauseStartTime - recordingStartTime - totalPausedTime + importedDurationOffset;
    } else {
      currentTime = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
    }
    
    const annotation = {
      timestamp: currentTime,
      title: title,
      text: text,
      duration: duration,
      position: null
    };
    
    currentTutorial.annotations.push(annotation);
    
    annotationEditorModal.classList.remove('visible');
    
    // Show annotation for positioning
    showAnnotationForPositioning(annotation, currentTutorial.annotations.length - 1);
  });
  
  cancelAnnotation.addEventListener('click', () => {
    annotationEditorModal.classList.remove('visible');
  });
  
  function showAnnotationForPositioning(annotation, index) {
    editingAnnotationIndex = index;
    
    // Populate annotation box
    annotationTitle.innerHTML = annotation.title;
    annotationText.innerHTML = annotation.text;
    
    // Set default position and size
    if (!annotation.position) {
      annotation.position = {
        left: 100,
        top: 100,
        width: 300,
        height: 200
      };
    }
    
    annotationBox.className = 'annotation-box visible draggable';
    annotationBox.style.left = annotation.position.left + 'px';
    annotationBox.style.top = annotation.position.top + 'px';
    annotationBox.style.width = annotation.position.width + 'px';
    annotationBox.style.height = annotation.position.height + 'px';
    annotationBox.style.transform = 'none';
    
    // Add resize handle
    if (!annotationBox.querySelector('.resize-handle')) {
      const handle = document.createElement('div');
      handle.className = 'resize-handle';
      annotationBox.appendChild(handle);
    }
    
    // Render MathJax
    if (window.MathJax && window.MathJax.typesetPromise) {
      window.MathJax.typesetPromise([annotationBox]).catch(err => console.error('MathJax error:', err));
    }
    
    // Show overlay
    positionEditorOverlay.style.display = 'flex';
    
    // Set up drag/resize handlers
    setupAnnotationDragResize();
  }
  
  function setupAnnotationDragResize() {
    const handle = annotationBox.querySelector('.resize-handle');
    
    annotationBox.onmousedown = (e) => {
      if (e.target === handle) {
        isResizingAnnotation = true;
        resizeStartWidth = annotationBox.offsetWidth;
        resizeStartHeight = annotationBox.offsetHeight;
      } else if (e.target === annotationBox || annotationBox.contains(e.target)) {
        isDraggingAnnotation = true;
      } else {
        return;
      }
      
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      e.preventDefault();
    };
    
    document.onmousemove = (e) => {
      if (isDraggingAnnotation && !isResizingAnnotation) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        
        const newLeft = annotationBox.offsetLeft + dx;
        const newTop = annotationBox.offsetTop + dy;
        
        annotationBox.style.left = newLeft + 'px';
        annotationBox.style.top = newTop + 'px';
        
        dragStartX = e.clientX;
        dragStartY = e.clientY;
      } else if (isResizingAnnotation) {
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        
        const newWidth = Math.max(200, resizeStartWidth + dx);
        const newHeight = Math.max(100, resizeStartHeight + dy);
        
        annotationBox.style.width = newWidth + 'px';
        annotationBox.style.height = newHeight + 'px';
      }
    };
    
    document.onmouseup = () => {
      isDraggingAnnotation = false;
      isResizingAnnotation = false;
    };
  }
  
  confirmPosition.addEventListener('click', () => {
    if (editingAnnotationIndex < 0) return;
    
    // Save position
    const annotation = currentTutorial.annotations[editingAnnotationIndex];
    annotation.position = {
      left: annotationBox.offsetLeft,
      top: annotationBox.offsetTop,
      width: annotationBox.offsetWidth,
      height: annotationBox.offsetHeight
    };
    
    // Hide annotation and overlay
    annotationBox.classList.remove('visible', 'draggable');
    positionEditorOverlay.style.display = 'none';
    
    editingAnnotationIndex = -1;
    
    // Recalculate duration and update timeline
    recalculateTutorialDuration();
    renderTimeline();
    
    console.log('✅ Annotation positioned');
  });
  
  // ========== PREVIEW/PLAYBACK ==========
  
  playPreview.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Handle play/resume logic
    if (isPlaying) {
      // Currently playing - this shouldn't happen as button should show pause
      return;
    }
    
    if (playbackPausedAt > 0) {
      // Resume from pause
      resumePlayback();
    } else {
      // Start from beginning
      startPlayback();
    }
  });
  
  replayPreview.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Stop current playback if playing
    if (isPlaying) {
      stopPlayback();
    }
    
    // Reset and start from beginning
    playbackPausedAt = 0;
    startPlayback();
  });
  
  function startPlayback() {
    if (!currentTutorial) return;
    
    const api = getAPI();
    if (!api) return;
    
    // Detect if we're previewing from paused recording state
    isPreviewingFromPaused = isRecording && isPaused;
    
    // Don't hide recording controls - just add playback mode to iframe
    appFrame.classList.add('playback-mode');
    
    // Update button states
    playPreview.textContent = '⏸ Pause';
    playPreview.style.display = 'inline-block';
    replayPreview.style.display = 'inline-block';
    
    // Hide other buttons during playback
    addAnnotationAtPause.style.display = 'none';
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
    
    // Reset to initial state
    api.setState(currentTutorial.initialState);
    
    // Hide any visible annotation before starting
    if (annotationBox) {
      annotationBox.classList.remove('visible');
    }
    if (annotationTimeout) {
      clearTimeout(annotationTimeout);
      annotationTimeout = null;
    }
    currentAnnotationIndex = -1;
    
    isPlaying = true;
    
    // Start playback at the earliest timestamp (0, first annotation, or first snapshot)
    let startOffset = 0;
    
    // Check if there are annotations before the first snapshot
    if (currentTutorial.annotations.length > 0) {
      const firstAnnTimestamp = Math.min(...currentTutorial.annotations.map(ann => ann.timestamp));
      if (currentTutorial.snapshots.length > 0) {
        const firstSnapshotTimestamp = currentTutorial.snapshots[0].timestamp;
        // Start at whichever comes first: annotation or snapshot
        startOffset = Math.min(firstAnnTimestamp, firstSnapshotTimestamp);
      } else {
        // No snapshots, just annotations
        startOffset = firstAnnTimestamp;
      }
      console.log('▶️ Starting playback at first event:', (startOffset / 1000).toFixed(2) + 's');
    } else if (currentTutorial.snapshots.length > 0) {
      // No annotations, start at first snapshot
      startOffset = currentTutorial.snapshots[0].timestamp;
      console.log('▶️ Starting playback at first event:', (startOffset / 1000).toFixed(2) + 's');
    }
    // If neither snapshots nor annotations exist, startOffset stays 0
    
    playbackStartTime = Date.now() - startOffset;
    playbackPausedAt = 0;
    
    requestAnimationFrame(playbackLoop);
    
    console.log('▶️ Playback started');
  }
  
  function pausePlayback() {
    if (!isPlaying) return;
    
    isPlaying = false;
    playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
    
    playPreview.textContent = '▶️ Play';
    addAnnotationAtPause.style.display = 'inline-block';
    recordAgain.style.display = 'inline-block';
    exportRecording.style.display = isPreviewingFromPaused ? 'none' : 'inline-block';
    
    console.log('⏸ Playback paused at', playbackPausedAt.toFixed(1) + 's');
  }
  
  function resumePlayback() {
    if (isPlaying) return;
    
    isPlaying = true;
    playbackStartTime = Date.now() - (playbackPausedAt * 1000);
    
    playPreview.textContent = '⏸ Pause';
    addAnnotationAtPause.style.display = 'none';
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
    
    requestAnimationFrame(playbackLoop);
    
    console.log('▶️ Playback resumed');
  }
  
  addAnnotationAtPause.addEventListener('click', () => {
    if (isPlaying) return; // Should only work when paused
    
    // Open annotation modal with timestamp set to current playback position
    const currentTime = playbackPausedAt * 1000; // Convert to ms
    
    annTitle.value = '';
    annText.value = '';
    annDuration.value = 5;
    annotationEditorModal.classList.add('visible');
    
    // Override the createAnnotation handler to use the paused time
    const originalHandler = createAnnotation.onclick;
    createAnnotation.onclick = () => {
      const title = annTitle.value.trim();
      const text = annText.value.trim();
      const duration = parseFloat(annDuration.value) * 1000;
      
      if (!title || !text) {
        alert('Please enter both title and text');
        return;
      }
      
      const annotation = {
        timestamp: currentTime,
        title: title,
        text: text,
        duration: duration,
        position: null
      };
      
      currentTutorial.annotations.push(annotation);
      
      annotationEditorModal.classList.remove('visible');
      
      // Show annotation for positioning
      showAnnotationForPositioning(annotation, currentTutorial.annotations.length - 1);
      
      // Restore original handler
      createAnnotation.onclick = originalHandler;
    };
  });
  
  function playbackLoop() {
    if (!isPlaying || !currentTutorial) return;
    
    const api = getAPI();
    if (!api) {
      stopPlayback();
      return;
    }
    
    const elapsed = (Date.now() - playbackStartTime) / 1000;
    const elapsedMs = elapsed * 1000;
    
    // Update timeline playhead (adjusted for timeline start offset)
    const timelineStartOffset = getTimelineStartOffset();
    const timelineElapsed = (elapsedMs - timelineStartOffset) / 1000;
    timelinePlayhead.style.display = 'block';
    timelinePlayhead.style.left = (timelineElapsed * timelineScale + 60) + 'px';
    
    // Find the most recent snapshot that should be active at this time
    let targetSnapshot = null;
    for (let i = currentTutorial.snapshots.length - 1; i >= 0; i--) {
      if (currentTutorial.snapshots[i].timestamp <= elapsedMs) {
        targetSnapshot = currentTutorial.snapshots[i];
        break;
      }
    }
    
    // Apply the most recent applicable snapshot BEFORE checking if finished
    if (targetSnapshot) {
      // Use a simple flag to avoid re-applying the same snapshot
      if (!playbackLoop.lastAppliedTimestamp || 
          targetSnapshot.timestamp !== playbackLoop.lastAppliedTimestamp) {
        api.setState(targetSnapshot.state);
        playbackLoop.lastAppliedTimestamp = targetSnapshot.timestamp;
        
        // Log important state changes
        if (targetSnapshot.event.action === 'simulate') {
          console.log('▶️ Applying simulate event - data length:', targetSnapshot.state.data.length, 'currentN:', targetSnapshot.state.currentN);
        }
      }
    }
    
    // Handle annotations
    let annotationShowing = false;
    for (let i = 0; i < currentTutorial.annotations.length; i++) {
      const ann = currentTutorial.annotations[i];
      const annStart = ann.timestamp;
      const annEnd = ann.timestamp + ann.duration;
      
      // Check if annotation should be visible at current time
      if (elapsedMs >= annStart && elapsedMs <= annEnd) {
        annotationShowing = true;
        if (currentAnnotationIndex !== i) {
          console.log(`📍 Showing annotation "${ann.title}" at ${(elapsedMs / 1000).toFixed(2)}s (should be ${(annStart / 1000).toFixed(2)}s-${(annEnd / 1000).toFixed(2)}s)`);
          showAnnotation(ann);
          currentAnnotationIndex = i;
        }
        break;
      }
    }
    
    // Hide annotation if no longer in range
    if (!annotationShowing && currentAnnotationIndex >= 0) {
      if (annotationBox) {
        annotationBox.classList.remove('visible');
      }
      currentAnnotationIndex = -1;
    }
    
    // Check for pauses - only trigger once per pause
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      for (let i = 0; i < currentTutorial.pauses.length; i++) {
        const pause = currentTutorial.pauses[i];
        // Check if we just reached this pause
        // Use a smaller window and track which pauses we've already hit
        if (!playbackLoop.triggeredPauses) {
          playbackLoop.triggeredPauses = new Set();
        }
        
        const pauseKey = `pause_${i}_${pause.timestamp}`;
        if (elapsedMs >= pause.timestamp && !playbackLoop.triggeredPauses.has(pauseKey)) {
          playbackLoop.triggeredPauses.add(pauseKey);
          console.log('⏸ Pause reached at', (pause.timestamp / 1000).toFixed(2) + 's - pausing playback');
          pausePlayback();
          return;
        }
      }
    }
    
    // Check if finished AFTER applying all state/annotations/pauses
    // This ensures the last snapshot gets applied before stopping
    if (elapsedMs >= currentTutorial.duration) {
      console.log(`⏹ Stopping playback: elapsed=${(elapsedMs / 1000).toFixed(3)}s duration=${(currentTutorial.duration / 1000).toFixed(3)}s`);
      stopPlayback();
      return;
    }
    
    requestAnimationFrame(playbackLoop);
  }
  
  function showAnnotation(ann) {
    if (!annotationBox) return;
    
    annotationTitle.innerHTML = ann.title;
    annotationText.innerHTML = ann.text;
    
    if (ann.position) {
      annotationBox.className = 'annotation-box visible custom-position';
      annotationBox.style.left = ann.position.left + 'px';
      annotationBox.style.top = ann.position.top + 'px';
      annotationBox.style.width = ann.position.width + 'px';
      annotationBox.style.height = ann.position.height + 'px';
      annotationBox.style.transform = 'none';
    }
    
    // Render MathJax
    if (window.MathJax && window.MathJax.typesetPromise) {
      window.MathJax.typesetPromise([annotationBox]).catch(err => console.error('MathJax error:', err));
    }
  }
  
  function stopPlayback() {
    isPlaying = false;
    
    // Save the preview context before resetting
    const wasPreviewingFromPaused = isPreviewingFromPaused;
    isPreviewingFromPaused = false;
    
    playbackLoop.lastAppliedTimestamp = null; // Reset the flag
    playbackLoop.triggeredPauses = null; // Reset triggered pauses
    
    // Check if tutorial ends with an annotation (within 100ms tolerance)
    let tutorialEndsWithAnnotation = false;
    if (currentTutorial && currentTutorial.annotations.length > 0) {
      const lastAnn = currentTutorial.annotations[currentTutorial.annotations.length - 1];
      const annEnd = lastAnn.timestamp + lastAnn.duration;
      const tolerance = 100; // 100ms tolerance
      
      if (Math.abs(annEnd - currentTutorial.duration) < tolerance) {
        tutorialEndsWithAnnotation = true;
        // Show the last annotation
        showAnnotation(lastAnn);
        currentAnnotationIndex = currentTutorial.annotations.length - 1;
        console.log('✓ Tutorial ends with annotation - keeping it visible');
      }
    }
    
    // Hide annotation only if tutorial doesn't end with one
    if (annotationBox && !tutorialEndsWithAnnotation) {
      annotationBox.classList.remove('visible');
      currentAnnotationIndex = -1;
    }
    
    if (annotationTimeout) {
      clearTimeout(annotationTimeout);
      annotationTimeout = null;
    }
    
    appFrame.classList.remove('playback-mode');
    
    // Reset playback paused state
    playbackPausedAt = 0;
    
    // If we were previewing from paused, just restore the preview button
    if (wasPreviewingFromPaused) {
      playPreview.textContent = '▶️ Play';
      playPreview.style.display = 'inline-block';
      replayPreview.style.display = 'none';
      
      // Apply current state from last snapshot
      const api = getAPI();
      if (api && currentTutorial && currentTutorial.snapshots.length > 0) {
        const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
        api.setState(lastSnapshot.state);
      }
      
      // Update pauseStartTime so preview time doesn't count as pause time
      pauseStartTime = Date.now();
      
      console.log('⏹ Preview finished - returned to paused state');
    } else {
      // Was previewing from finished recording - show final state with playhead
      if (currentTutorial) {
        const timelineStartOffset = getTimelineStartOffset();
        const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
        timelinePlayhead.style.left = timelineEndPosition + 'px';
        timelinePlayhead.style.display = 'block';
      }
      
      playPreview.style.display = 'inline-block';
      playPreview.textContent = '▶️ Play';
      replayPreview.style.display = 'inline-block';
      addAnnotationAtPause.style.display = 'none';
      recordAgain.style.display = 'inline-block';
      exportRecording.style.display = 'inline-block';
      
      // Apply final state
      const api = getAPI();
      if (api && currentTutorial && currentTutorial.snapshots.length > 0) {
        const finalSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
        api.setState(finalSnapshot.state);
      }
      
      console.log('⏹ Playback stopped');
    }
  }
  
  recordAgain.addEventListener('click', () => {
    // Finalize recording if still in recording mode
    if (isRecording || isPaused) {
      finalizeRecording();
    }
    
    // Clear current tutorial
    currentTutorial = null;
    importedDurationOffset = 0; // Reset offset
    
    // Reset UI
    startRecording.style.display = 'inline-block';
    playPauseRecording.style.display = 'none';
    addAnnotation.style.display = 'none';
    addPause.style.display = 'none';
    playPreview.style.display = 'none';
    playPreview.disabled = true;
    replayPreview.style.display = 'none';
    addAnnotationAtPause.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    
    // Hide these buttons - they should not appear
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
    loadJSON.style.display = 'inline-block'; // Show import button again
    
    // Clear timeline
    timelineContainer.classList.remove('visible');
    eventsTrack.innerHTML = '';
    pausesTrack.innerHTML = '';
    annotationsTrack.innerHTML = '';
    timelineRuler.innerHTML = '';
    timelinePlayhead.style.display = 'none';
    
    // Reset iframe to initial state
    const api = getAPI();
    if (api) {
      // Try to reset to some default state, but this is app-specific
      // The app should handle a fresh start gracefully
      try {
        api.setState(api.getState()); // Trigger a state refresh
      } catch(e) {
        console.log('Could not reset app state');
      }
    }
    
    console.log('🔄 Ready to record new tutorial');
  });
  
  function finalizeRecording() {
    if (!isRecording) return;
    
    const api = getAPI();
    if (api && eventListener) {
      api.offAction(eventListener);
    }
    
    isRecording = false;
    isPaused = false;
    
    // Recalculate final duration
    recalculateTutorialDuration();
    
    // Update UI for finished state
    playPauseRecording.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    addAnnotation.style.display = 'none';
    addPause.style.display = 'none';
    playPreview.style.display = 'inline-block';
    playPreview.disabled = false;
    replayPreview.style.display = 'none'; // Only show after playing once
    recordAgain.style.display = 'inline-block';
    exportRecording.style.display = 'inline-block';
    
    console.log('✅ Recording finalized -', currentTutorial.snapshots.length, 'events,', currentTutorial.annotations.length, 'annotations');
  }
  
  // ========== TIMELINE RENDERING ==========
  
  function renderTimeline() {
    if (!currentTutorial) return;
    
    // Calculate timeline range
    const timelineStartOffset = getTimelineStartOffset();
    const timelineDuration = currentTutorial.duration - timelineStartOffset;
    const timelineWidth = (timelineDuration / 1000) * timelineScale;
    
    // Render ruler
    renderTimelineRuler(timelineDuration);
    
    // Render events track
    eventsTrack.innerHTML = '';
    currentTutorial.snapshots.forEach((snapshot, index) => {
      const event = document.createElement('div');
      event.className = 'timeline-event';
      if (snapshot.event && snapshot.event.action === 'simulate') {
        event.classList.add('simulate');
      }
      
      const position = ((snapshot.timestamp - timelineStartOffset) / 1000) * timelineScale;
      event.style.left = position + 'px';
      event.dataset.index = index;
      
      // Context menu
      event.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showEventContextMenu(e, index, 'event');
      });
      
      // Drag functionality
      event.addEventListener('mousedown', startEventDrag);
      
      eventsTrack.appendChild(event);
    });
    
    // Render pauses track
    pausesTrack.innerHTML = '';
    if (currentTutorial.pauses) {
      currentTutorial.pauses.forEach((pause, index) => {
        const pauseEl = document.createElement('div');
        pauseEl.className = 'timeline-pause';
        
        const position = ((pause.timestamp - timelineStartOffset) / 1000) * timelineScale;
        pauseEl.style.left = position + 'px';
        pauseEl.dataset.index = index;
        
        // Context menu
        pauseEl.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showEventContextMenu(e, index, 'pause');
        });
        
        // Drag functionality
        pauseEl.addEventListener('mousedown', startPauseDrag);
        
        pausesTrack.appendChild(pauseEl);
      });
    }
    
    // Render annotations track
    annotationsTrack.innerHTML = '';
    currentTutorial.annotations.forEach((annotation, index) => {
      const annEl = document.createElement('div');
      annEl.className = 'timeline-annotation';
      
      const position = ((annotation.timestamp - timelineStartOffset) / 1000) * timelineScale;
      const width = (annotation.duration / 1000) * timelineScale;
      annEl.style.left = position + 'px';
      annEl.style.width = width + 'px';
      annEl.dataset.index = index;
      
      // Add label if there's room
      if (width > 30) {
        const label = document.createElement('div');
        label.className = 'timeline-annotation-label';
        label.textContent = annotation.title;
        annEl.appendChild(label);
      }
      
      // Click to edit
      annEl.addEventListener('click', () => {
        showAnnotationForPositioning(annotation, index);
      });
      
      // Context menu
      annEl.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showEventContextMenu(e, index, 'annotation');
      });
      
      // Drag functionality
      annEl.addEventListener('mousedown', startAnnotationDrag);
      
      annotationsTrack.appendChild(annEl);
    });
  }
  
  function renderTimelineRuler(duration) {
    timelineRuler.innerHTML = '';
    
    const seconds = Math.ceil(duration / 1000);
    for (let i = 0; i <= seconds; i++) {
      const tick = document.createElement('div');
      tick.className = 'timeline-tick';
      tick.style.left = (i * timelineScale) + 'px';
      tick.textContent = i + 's';
      timelineRuler.appendChild(tick);
    }
  }
  
  function getTimelineStartOffset() {
    if (!currentTutorial) return 0;
    
    let minTimestamp = Infinity;
    
    if (currentTutorial.snapshots.length > 0) {
      minTimestamp = Math.min(minTimestamp, currentTutorial.snapshots[0].timestamp);
    }
    
    if (currentTutorial.annotations.length > 0) {
      minTimestamp = Math.min(minTimestamp, ...currentTutorial.annotations.map(a => a.timestamp));
    }
    
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      minTimestamp = Math.min(minTimestamp, ...currentTutorial.pauses.map(p => p.timestamp));
    }
    
    return minTimestamp === Infinity ? 0 : minTimestamp;
  }
  
  // ========== TIMELINE INTERACTION ==========
  
  function showEventContextMenu(e, index, type) {
    contextMenuTarget = { index, type };
    
    eventContextMenu.style.left = e.pageX + 'px';
    eventContextMenu.style.top = e.pageY + 'px';
    eventContextMenu.classList.add('visible');
  }
  
  document.addEventListener('click', () => {
    eventContextMenu.classList.remove('visible');
  });
  
  deleteEvent.addEventListener('click', () => {
    if (!contextMenuTarget) return;
    
    const { index, type } = contextMenuTarget;
    
    if (type === 'event') {
      currentTutorial.snapshots.splice(index, 1);
      console.log('🗑 Event deleted');
    } else if (type === 'annotation') {
      currentTutorial.annotations.splice(index, 1);
      console.log('🗑 Annotation deleted');
    } else if (type === 'pause') {
      currentTutorial.pauses.splice(index, 1);
      console.log('🗑 Pause deleted');
    }
    
    recalculateTutorialDuration();
    renderTimeline();
  });
  
  function startEventDrag(e) {
    const index = parseInt(e.target.dataset.index);
    draggingEvent = {
      index: index,
      startX: e.clientX,
      startTimestamp: currentTutorial.snapshots[index].timestamp,
      hasMoved: false
    };
    
    document.addEventListener('mousemove', doEventDrag);
    document.addEventListener('mouseup', stopEventDrag);
    e.preventDefault();
  }
  
  function doEventDrag(e) {
    if (!draggingEvent) return;
    
    const dx = e.clientX - draggingEvent.startX;
    const dt = (dx / timelineScale) * 1000;
    
    const newTimestamp = Math.max(0, draggingEvent.startTimestamp + dt);
    currentTutorial.snapshots[draggingEvent.index].timestamp = newTimestamp;
    
    // Mark that we've moved
    if (Math.abs(dx) > 3) {
      draggingEvent.hasMoved = true;
    }
    
    renderTimeline();
  }
  
  function stopEventDrag() {
    if (!draggingEvent) return;
    
    // Only recalculate if user actually dragged
    if (draggingEvent.hasMoved) {
      // Sort snapshots by timestamp after dragging
      currentTutorial.snapshots.sort((a, b) => a.timestamp - b.timestamp);
      recalculateTutorialDuration();
      renderTimeline();
    }
    
    draggingEvent = null;
    document.removeEventListener('mousemove', doEventDrag);
    document.removeEventListener('mouseup', stopEventDrag);
  }
  
  function startAnnotationDrag(e) {
    // Don't start drag if clicking the label text
    if (e.target.classList.contains('timeline-annotation-label')) {
      return;
    }
    
    const index = parseInt(e.currentTarget.dataset.index);
    draggingAnnotation = {
      index: index,
      startX: e.clientX,
      startTimestamp: currentTutorial.annotations[index].timestamp,
      hasMoved: false
    };
    
    document.addEventListener('mousemove', doAnnotationDrag);
    document.addEventListener('mouseup', stopAnnotationDrag);
    e.preventDefault();
    e.stopPropagation(); // Prevent click event
  }
  
  function doAnnotationDrag(e) {
    if (!draggingAnnotation) return;
    
    const dx = e.clientX - draggingAnnotation.startX;
    const dt = (dx / timelineScale) * 1000;
    
    const newTimestamp = Math.max(0, draggingAnnotation.startTimestamp + dt);
    currentTutorial.annotations[draggingAnnotation.index].timestamp = newTimestamp;
    
    // Mark that we've moved
    if (Math.abs(dx) > 3) {
      draggingAnnotation.hasMoved = true;
    }
    
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  function stopAnnotationDrag() {
    if (!draggingAnnotation) return;
    
    // Only do overlap checking and re-rendering if user actually dragged
    if (!draggingAnnotation.hasMoved) {
      draggingAnnotation = null;
      document.removeEventListener('mousemove', doAnnotationDrag);
      document.removeEventListener('mouseup', stopAnnotationDrag);
      return;
    }
    
    const draggedIndex = draggingAnnotation.index;
    const draggedAnn = currentTutorial.annotations[draggedIndex];
    
    // Check for overlap with previous annotation (dragging right over left)
    if (draggedIndex > 0) {
      const prevAnn = currentTutorial.annotations[draggedIndex - 1];
      const prevEnd = prevAnn.timestamp + prevAnn.duration;
      
      if (draggedAnn.timestamp < prevEnd) {
        // Current annotation overlaps previous one
        // Shorten the previous annotation so it ends where current one starts
        const newPrevDuration = draggedAnn.timestamp - prevAnn.timestamp;
        if (newPrevDuration >= 1000) { // Minimum 1 second
          prevAnn.duration = newPrevDuration;
          console.log('⚠️ Shortened previous annotation to avoid overlap');
        } else {
          // If shortening would make it too small, push the dragged annotation forward instead
          draggedAnn.timestamp = prevAnn.timestamp + prevAnn.duration;
          console.log('⚠️ Moved annotation forward to avoid making previous one too short');
        }
      }
    }
    
    // Check for overlap with next annotation (dragging left over right)
    if (draggedIndex < currentTutorial.annotations.length - 1) {
      const nextAnn = currentTutorial.annotations[draggedIndex + 1];
      const draggedEnd = draggedAnn.timestamp + draggedAnn.duration;
      
      if (draggedEnd > nextAnn.timestamp) {
        // Dragged annotation overlaps next one
        // Move the next annotation to start where dragged one ends
        nextAnn.timestamp = draggedEnd;
        console.log('⚠️ Moved next annotation forward to avoid overlap');
      }
    }
    
    draggingAnnotation = null;
    document.removeEventListener('mousemove', doAnnotationDrag);
    document.removeEventListener('mouseup', stopAnnotationDrag);
    
    // Recalculate tutorial duration after moving
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  function startPauseDrag(e) {
    const index = parseInt(e.target.dataset.index);
    draggingPause = {
      index: index,
      startX: e.clientX,
      startTimestamp: currentTutorial.pauses[index].timestamp
    };
    
    document.addEventListener('mousemove', doPauseDrag);
    document.addEventListener('mouseup', stopPauseDrag);
    e.preventDefault();
  }
  
  function doPauseDrag(e) {
    if (!draggingPause) return;
    
    const dx = e.clientX - draggingPause.startX;
    const dt = (dx / timelineScale) * 1000;
    
    const newTimestamp = Math.max(0, draggingPause.startTimestamp + dt);
    currentTutorial.pauses[draggingPause.index].timestamp = newTimestamp;
    
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  function stopPauseDrag() {
    if (!draggingPause) return;
    
    draggingPause = null;
    document.removeEventListener('mousemove', doPauseDrag);
    document.removeEventListener('mouseup', stopPauseDrag);
    
    // Recalculate tutorial duration after moving
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  // Recalculate tutorial duration based on snapshots and annotations
  function recalculateTutorialDuration() {
    if (!currentTutorial) return;
    
    let calculatedDuration = 0;
    let durationSource = 'none';
    
    // Get last snapshot time
    let lastSnapshotTime = 0;
    if (currentTutorial.snapshots.length > 0) {
      lastSnapshotTime = currentTutorial.snapshots[currentTutorial.snapshots.length - 1].timestamp;
      calculatedDuration = lastSnapshotTime;
      durationSource = 'snapshot';
    }
    
    // Get last annotation end time
    let lastAnnotationEnd = 0;
    if (currentTutorial.annotations.length > 0) {
      lastAnnotationEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
      if (lastAnnotationEnd > calculatedDuration) {
        calculatedDuration = lastAnnotationEnd;
        durationSource = 'annotation';
      }
    }
    
    // No buffer needed - playback loop applies snapshots before checking duration
    currentTutorial.duration = calculatedDuration;
    console.log('📊 Duration recalculated:', (calculatedDuration / 1000).toFixed(2) + 's');
    console.log('  Last snapshot:', (lastSnapshotTime / 1000).toFixed(2) + 's');
    console.log('  Last annotation end:', (lastAnnotationEnd / 1000).toFixed(2) + 's');
    console.log('  Duration determined by:', durationSource);
  }
  
  // ========== ANNOTATION EDITING ==========
  
  deleteAnnotation.addEventListener('click', () => {
    if (editingAnnotationIndex < 0) return;
    
    // Remove the annotation
    currentTutorial.annotations.splice(editingAnnotationIndex, 1);
    
    // Hide annotation and overlay
    annotationBox.classList.remove('visible', 'draggable');
    positionEditorOverlay.style.display = 'none';
    
    editingAnnotationIndex = -1;
    
    // Recalculate duration and update timeline
    recalculateTutorialDuration();
    renderTimeline();
    
    console.log('🗑 Annotation deleted');
  });
  
  cancelPosition.addEventListener('click', () => {
    if (editingAnnotationIndex < 0) return;
    
    // Remove the annotation
    currentTutorial.annotations.splice(editingAnnotationIndex, 1);
    
    // Hide annotation and overlay
    annotationBox.classList.remove('visible', 'draggable');
    positionEditorOverlay.style.display = 'none';
    
    editingAnnotationIndex = -1;
    
    console.log('✗ Annotation positioning cancelled');
  });
  
  // ========== EXPORT/IMPORT ==========
  
  exportRecording.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Don't finalize - just export the current state
    // User can continue recording after exporting
    
    snapshotCount.textContent = currentTutorial.snapshots.length;
    annotationCount.textContent = currentTutorial.annotations.length;
    exportTextarea.value = JSON.stringify(currentTutorial, null, 2);
    exportModal.classList.add('visible');
  });
  
  downloadExport.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    const jsonStr = JSON.stringify(currentTutorial, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tutorial-' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    downloadExport.textContent = '✓ Downloaded!';
    setTimeout(() => {
      downloadExport.textContent = '💾 Download JSON';
    }, 2000);
  });
  
  copyExport.addEventListener('click', () => {
    exportTextarea.select();
    document.execCommand('copy');
    copyExport.textContent = '✓ Copied!';
    setTimeout(() => {
      copyExport.textContent = '📋 Copy to Clipboard';
    }, 2000);
  });
  
  closeExportModal.addEventListener('click', () => {
    exportModal.classList.remove('visible');
  });
  
  loadJSON.addEventListener('click', () => {
    jsonFileInput.click();
  });
  
  jsonFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const imported = JSON.parse(event.target.result);
        
        if (!imported.initialState || !imported.snapshots || !imported.annotations) {
          throw new Error('Invalid tutorial format');
        }
        
        // Backward compatibility: add pauses array if it doesn't exist
        if (!imported.pauses) {
          imported.pauses = [];
        }
        
        currentTutorial = imported;
        
        // Load the app if not already loaded
        if (!isAppLoaded && imported.initialState) {
          // We can't auto-load without a URL, so just inform user
          alert('Tutorial loaded! Please load the app first using "Load App", then the tutorial will be ready to edit.');
        } else if (isAppLoaded) {
          const api = getAPI();
          if (api) {
            // Apply the last snapshot's state instead of initial state
            // This shows the final state with all settings that were active at the end
            if (currentTutorial.snapshots.length > 0) {
              const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
              api.setState(lastSnapshot.state);
            } else {
              api.setState(currentTutorial.initialState);
            }
          }
          
          // Set up recording state as if we just paused
          isRecording = true;
          isPaused = true;
          recordingStartTime = Date.now(); // Start recording from NOW
          pauseStartTime = Date.now(); // Set pause start time for correct resume calculation
          totalPausedTime = 0;
          importedDurationOffset = currentTutorial.duration || 0; // Offset new events by imported duration
          
          // Set up event listener (so we can continue recording)
          eventListener = (event) => {
            const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
            const snapshot = {
              timestamp: timestamp,
              event: event,
              state: api.getState()
            };
            currentTutorial.snapshots.push(snapshot);
            renderTimeline();
          };
          api.onAction(eventListener);
          
          // Show paused recording UI
          startRecording.style.display = 'none';
          loadJSON.style.display = 'none';
          playPauseRecording.style.display = 'inline-block';
          playPauseRecording.textContent = '⏺ Resume';
          playPauseRecording.className = 'success';
          pausedIndicator.style.display = 'inline-block';
          addAnnotation.style.display = 'inline-block';
          addAnnotation.disabled = false;
          addPause.style.display = 'inline-block';
          addPause.disabled = false;
          playPreview.style.display = 'inline-block';
          playPreview.disabled = false;
          replayPreview.style.display = 'none';
          recordAgain.style.display = 'inline-block';
          recordAgain.disabled = false;
          exportRecording.style.display = 'inline-block';
          exportRecording.disabled = false;
          
          renderTimeline();
          
          // Position playhead at the end of the imported tutorial
          const timelineStartOffset = getTimelineStartOffset();
          const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
          timelinePlayhead.style.left = timelineEndPosition + 'px';
          timelinePlayhead.style.display = 'block';
          
          alert('✓ Tutorial loaded!\n\nYou can now:\n• Preview it\n• Resume recording to add more\n• Add/edit annotations\n• Export when done');
        }
        
        console.log('📤 Tutorial imported');
      } catch (err) {
        alert('Error importing tutorial: ' + err.message);
        console.error('Import error:', err);
      }
    };
    
    reader.readAsText(file);
    jsonFileInput.value = '';
  });
  
  // ========== HELP ==========
  
  helpBtn.addEventListener('click', () => {
    helpModal.classList.add('visible');
  });
  
  closeHelpModal.addEventListener('click', () => {
    helpModal.classList.remove('visible');
  });
  
  helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
      helpModal.classList.remove('visible');
    }
  });
  
  exportModal.addEventListener('click', (e) => {
    if (e.target === exportModal) {
      exportModal.classList.remove('visible');
    }
  });
  
  annotationEditorModal.addEventListener('click', (e) => {
    if (e.target === annotationEditorModal) {
      annotationEditorModal.classList.remove('visible');
    }
  });
  
  console.log('Tutorial Creator v11.37 initialized');
})();
</script>
</body>
</html>
