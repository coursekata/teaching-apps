<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Tutorial System</title>
<style>
  :root{
    --accent:#2563eb;
    --record:#ef4444;
    --success:#10b981;
  }
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#111;
    background:#f5f5f5;
    display:flex;
    flex-direction:column;
    height:100vh;
  }
  
  .tutorial-header{
    background:#fff;
    border-bottom:2px solid #ddd;
    padding:12px 20px;
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
  }
  
  .tutorial-controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  .mode-toggle{
    display:flex;
    gap:8px;
    padding:4px;
    background:#f0f0f0;
    border-radius:8px;
  }
  
  .mode-toggle button{
    padding:8px 16px;
    border-radius:6px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-weight:600;
    font-size:13px;
  }
  
  .mode-toggle button.active{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button{
    padding:8px 14px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:13px;
  }
  
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button.record{
    background:var(--record);
    color:#fff;
    border-color:var(--record);
  }
  
  button.success{
    background:var(--success);
    color:#fff;
    border-color:var(--success);
  }
  
  button.record.recording{
    animation:pulse 1.5s infinite;
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.6}
  }
  
  .recording-indicator{
    background:var(--record);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
    animation:pulse 1.5s infinite;
  }
  
  .playback-controls{
    display:flex;
    gap:8px;
    align-items:center;
    background:#f0f0f0;
    padding:8px;
    border-radius:8px;
  }
  
  .playback-timeline{
    flex:1;
    min-width:200px;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  
  .playback-timeline input[type=range]{
    width:100%;
    accent-color:var(--accent);
  }
  
  .time-display{
    font-size:11px;
    color:#666;
    text-align:center;
  }
  
  .app-container{
    flex:1;
    position:relative;
    overflow:hidden;
  }
  
  iframe{
    width:100%;
    height:100%;
    border:none;
  }
  
  .annotation-box{
    position:absolute;
    max-width:500px;
    background:rgba(255,255,255,0.98);
    border:3px solid var(--accent);
    border-radius:12px;
    padding:20px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15);
    z-index:100;
    display:none;
  }
  
  .annotation-box.visible{
    display:block;
    animation:slideIn 0.3s ease-out;
  }
  
  /* Position variants */
  .annotation-box.pos-top{top:20px;left:50%;transform:translateX(-50%);}
  .annotation-box.pos-bottom{bottom:20px;left:50%;transform:translateX(-50%);}
  .annotation-box.pos-left{top:50%;left:20px;transform:translateY(-50%);max-width:350px;}
  .annotation-box.pos-right{top:50%;right:20px;transform:translateY(-50%);max-width:350px;}
  .annotation-box.pos-center{top:50%;left:50%;transform:translate(-50%, -50%);}
  .annotation-box.pos-top-left{top:20px;left:20px;transform:none;max-width:400px;}
  .annotation-box.pos-top-right{top:20px;right:20px;transform:none;max-width:400px;}
  .annotation-box.pos-bottom-left{bottom:20px;left:20px;transform:none;max-width:400px;}
  .annotation-box.pos-bottom-right{bottom:20px;right:20px;transform:none;max-width:400px;}
  
  @keyframes slideIn{
    from{opacity:0;}
    to{opacity:1;}
  }
  
  .annotation-box h3{
    margin:0 0 12px;
    color:var(--accent);
    font-size:18px;
  }
  
  .annotation-box p{
    margin:0;
    line-height:1.6;
    font-size:15px;
  }
  
  .modal-overlay{
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.5);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:1000;
  }
  
  .modal-overlay.visible{
    display:flex;
  }
  
  .modal{
    background:#fff;
    border-radius:12px;
    padding:24px;
    max-width:700px;
    width:90%;
    max-height:80vh;
    overflow-y:auto;
    box-shadow:0 8px 32px rgba(0,0,0,0.2);
  }
  
  .modal h2{
    margin:0 0 16px;
    color:#111;
  }
  
  .modal textarea{
    width:100%;
    min-height:300px;
    font-family:monospace;
    font-size:12px;
    padding:12px;
    border:1px solid #ddd;
    border-radius:8px;
    resize:vertical;
  }
  
  .modal-buttons{
    display:flex;
    gap:8px;
    margin-top:16px;
    justify-content:flex-end;
  }
  
  .help-text{
    font-size:13px;
    color:#666;
    margin:8px 0;
    line-height:1.5;
  }
  
  ol.help-text{
    margin-left:20px;
    padding-left:0;
  }
  
  ol.help-text li{
    margin:6px 0;
  }
  
  select{
    padding:6px 10px;
    border-radius:6px;
    border:1px solid #ddd;
    background:#fff;
    font-size:13px;
  }
  
  .control-group{
    display:flex;
    gap:8px;
    align-items:center;
  }
  
  label{
    font-size:12px;
    color:#666;
    display:flex;
    align-items:center;
    gap:6px;
  }
  
  input[type=text]{
    padding:6px 10px;
    border-radius:6px;
    border:1px solid #ddd;
    font-size:13px;
    width:300px;
  }
  
  .info-box{
    background:#e0f2fe;
    border:1px solid #0284c7;
    border-radius:8px;
    padding:12px;
    margin:12px 0;
    font-size:13px;
    color:#0c4a6e;
  }
  
  .info-box strong{
    color:#075985;
  }
</style>
</head>
<body>
  <div class="tutorial-header">
    <div class="tutorial-controls">
      <div class="mode-toggle">
        <button id="modeRecord" class="active">Record</button>
        <button id="modePlayback">Playback</button>
      </div>
      
      <div id="recordingControls" class="control-group">
        <label>
          App URL:
          <input type="text" id="appUrl" placeholder="Enter your app URL">
        </label>
        <button id="loadApp" class="primary">Load App</button>
        <button id="reloadApp" class="primary" style="display:none;">üîÑ Reload App</button>
        <button id="startRecord" class="record" style="display:none;">‚óè Start Recording</button>
        <button id="stopRecord" class="record" style="display:none;">‚ñ† Stop Recording</button>
        <span id="recordingIndicator" class="recording-indicator" style="display:none;">‚óè REC <span id="recordingTime">0:00</span></span>
        <button id="previewRecording" class="primary" style="display:none;">‚ñ∂ Preview Recording</button>
        <button id="playPausePreview" class="primary" style="display:none;">‚è∏ Pause</button>
        <button id="recordAgain" class="record" style="display:none;">üîÑ Record Again</button>
      </div>
      
      <div id="playbackControls" class="playback-controls" style="display:none;">
        <button id="loadTutorial" class="primary">üìÇ Load Tutorial</button>
        <button id="backToRecording" class="primary" style="display:none;">‚Üê Back to Recording</button>
        <button id="playBtn">‚ñ∂ Play</button>
        <button id="pauseBtn" style="display:none;">‚è∏ Pause</button>
        <button id="restartBtn">‚ü≤ Restart</button>
        <div class="playback-timeline">
          <input type="range" id="timelineSlider" min="0" max="100" value="0">
          <div class="time-display">
            <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
          </div>
        </div>
        <label>
          Speed:
          <select id="playbackSpeed">
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x</option>
          </select>
        </label>
      </div>
      
      <button id="exportTutorial" class="success" style="display:none;">üì• Export Tutorial</button>
      <button id="helpBtn">‚ùì Help</button>
    </div>
  </div>
  
  <div class="app-container">
    <iframe id="appFrame"></iframe>
    <div id="annotationBox" class="annotation-box">
      <h3 id="annotationTitle"></h3>
      <p id="annotationText"></p>
    </div>
  </div>
  
  <!-- Export Modal -->
  <div id="exportModal" class="modal-overlay">
    <div class="modal">
      <h2>Export Tutorial</h2>
      <div class="help-text">
        Copy this JSON and save it. You can edit the annotations array to add helpful text at specific timestamps.
      </div>
      <textarea id="exportTextarea" readonly></textarea>
      <div class="modal-buttons">
        <button id="copyExport" class="primary">üìã Copy to Clipboard</button>
        <button id="closeExportModal">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Load Modal -->
  <div id="loadModal" class="modal-overlay">
    <div class="modal">
      <h2>Load Tutorial</h2>
      <div class="help-text">
        Paste your tutorial JSON below, or load from a file:
      </div>
      <input type="file" id="fileInput" accept=".json" style="display:none;">
      <button id="loadFromFile" class="primary">üìÅ Choose File</button>
      <textarea id="loadTextarea" placeholder='Paste tutorial JSON here...'></textarea>
      <div id="loadError" class="help-text" style="display:none;color:#ef4444;"></div>
      <div class="modal-buttons">
        <button id="loadFromText" class="primary">‚úì Load Tutorial</button>
        <button id="closeLoadModal">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Help Modal -->
  <div id="helpModal" class="modal-overlay">
    <div class="modal">
      <h2>How to Use This Tutorial System</h2>
      
      <h3>Record Mode (Default)</h3>
      <p class="help-text">
        Enter your app URL and click "Load App". You can now use your app normally. When you're ready to create a tutorial:
      </p>
      <ol class="help-text">
        <li>Click "Start Recording"</li>
        <li>Interact with your app (clicks, inputs, drags, etc.)</li>
        <li>Click "Stop Recording"</li>
        <li>Click "Preview Recording" to see it play back</li>
        <li>Click "Export Tutorial" to get the JSON</li>
        <li>Click "Record Again" to create a new recording</li>
      </ol>
      <p class="help-text">
        <strong>Note:</strong> Your app remains fully interactive between recordings and after previews. 
        Use "Reload App" if you need to reset the app state.
      </p>
      
      <h3>Playback Mode</h3>
      <p class="help-text">
        This mode is for loading and viewing tutorial JSON files created by others. 
        Click "Load Tutorial", paste the JSON, and use the playback controls to watch the tutorial.
      </p>
      
      <h3>Adding Annotations</h3>
      <p class="help-text">
        Edit the "annotations" array in the exported JSON to add text overlays at specific timestamps. 
        Each annotation needs: timestamp (ms), duration (ms), title, text, and position 
        (top, bottom, left, right, center, top-left, top-right, bottom-left, bottom-right).
      </p>
      
      <div class="info-box">
        <strong>Note:</strong> This system works best with apps on the same domain or with CORS enabled. 
        For cross-origin apps, host them on GitHub Pages or a server with appropriate CORS headers.
      </div>
      
      <div class="modal-buttons">
        <button id="closeHelpModal" class="primary">Got it!</button>
      </div>
    </div>
  </div>

<script>
(function() {
  'use strict';
  
  // Elements
  const modeRecord = document.getElementById('modeRecord');
  const modePlayback = document.getElementById('modePlayback');
  const recordingControls = document.getElementById('recordingControls');
  const playbackControls = document.getElementById('playbackControls');
  const appUrl = document.getElementById('appUrl');
  const loadApp = document.getElementById('loadApp');
  const reloadApp = document.getElementById('reloadApp');
  const appFrame = document.getElementById('appFrame');
  const startRecord = document.getElementById('startRecord');
  const stopRecord = document.getElementById('stopRecord');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const recordingTime = document.getElementById('recordingTime');
  const previewRecording = document.getElementById('previewRecording');
  const playPausePreview = document.getElementById('playPausePreview');
  const exportTutorial = document.getElementById('exportTutorial');
  const recordAgain = document.getElementById('recordAgain');
  const exportModal = document.getElementById('exportModal');
  const exportTextarea = document.getElementById('exportTextarea');
  const copyExport = document.getElementById('copyExport');
  const closeExportModal = document.getElementById('closeExportModal');
  const loadTutorial = document.getElementById('loadTutorial');
  const backToRecording = document.getElementById('backToRecording');
  const loadModal = document.getElementById('loadModal');
  const loadTextarea = document.getElementById('loadTextarea');
  const loadFromFile = document.getElementById('loadFromFile');
  const loadFromText = document.getElementById('loadFromText');
  const closeLoadModal = document.getElementById('closeLoadModal');
  const fileInput = document.getElementById('fileInput');
  const loadError = document.getElementById('loadError');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const timelineSlider = document.getElementById('timelineSlider');
  const currentTimeEl = document.getElementById('currentTime');
  const totalTimeEl = document.getElementById('totalTime');
  const playbackSpeedSelect = document.getElementById('playbackSpeed');
  const annotationBox = document.getElementById('annotationBox');
  const annotationTitle = document.getElementById('annotationTitle');
  const annotationText = document.getElementById('annotationText');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('helpModal');
  const closeHelpModal = document.getElementById('closeHelpModal');
  
  // State
  let currentMode = 'record';
  let isRecording = false;
  let recordStartTime = 0;
  let recordedEvents = [];
  let recordingInterval = null;
  let currentTutorial = null;
  let isPlaying = false;
  let playbackStartTime = 0;
  let playbackPausedAt = 0;
  let playbackSpeed = 1;
  let eventQueue = [];
  let currentAnnotationIndex = -1;
  
  // Drag tracking - SIMPLIFIED APPROACH
  let isDragging = false;
  let dragElement = null;
  let dragStartTime = 0;
  let dragStartSnapshot = null;
  let dragCheckInterval = null;
  
  // Mode switching
  function setMode(mode) {
    const previousMode = currentMode;
    currentMode = mode;
    
    // Hide any visible annotations when switching modes
    annotationBox.classList.remove('visible');
    currentAnnotationIndex = -1;
    
    // Update button states
    [modeRecord, modePlayback].forEach(btn => btn.classList.remove('active'));
    
    // Hide all control groups
    recordingControls.style.display = 'none';
    playbackControls.style.display = 'none';
    
    if (mode === 'record') {
      modeRecord.classList.add('active');
      recordingControls.style.display = 'flex';
      
      // If switching from playback to record, reload the app to reset state
      if (previousMode === 'playback' && appFrame.src && appFrame.src !== 'about:blank') {
        const url = appFrame.src;
        appFrame.src = '';
        setTimeout(() => {
          appFrame.src = url;
          console.log('üîÑ App reloaded for record mode');
        }, 100);
      }
    } else if (mode === 'playback') {
      modePlayback.classList.add('active');
      playbackControls.style.display = 'flex';
      
      // Show Load Tutorial button, hide Back to Recording
      loadTutorial.style.display = 'inline-block';
      backToRecording.style.display = 'none';
    }
  }
  
  modeRecord.addEventListener('click', () => setMode('record'));
  modePlayback.addEventListener('click', () => setMode('playback'));
  
  // Load app
  loadApp.addEventListener('click', () => {
    const url = appUrl.value.trim();
    if (!url) {
      alert('Please enter a URL');
      return;
    }
    
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      appUrl.value = 'https://' + url;
    }
    
    appFrame.src = appUrl.value;
    
    // Show recording controls after loading
    setTimeout(() => {
      loadApp.style.display = 'none';
      reloadApp.style.display = 'inline-block';
      startRecord.style.display = 'inline-block';
    }, 500);
  });
  
  // Reload app
  reloadApp.addEventListener('click', () => {
    const url = appFrame.src;
    if (url && url !== 'about:blank') {
      appFrame.src = '';
      setTimeout(() => {
        appFrame.src = url;
        console.log('üîÑ App reloaded');
      }, 100);
    }
  });
  
  // Recording
  startRecord.addEventListener('click', () => {
    if (!appFrame.src || appFrame.src === 'about:blank') {
      alert('Please load an app first!');
      return;
    }
    
    isRecording = true;
    recordStartTime = Date.now();
    recordedEvents = [];
    
    startRecord.style.display = 'none';
    stopRecord.style.display = 'inline-block';
    recordingIndicator.style.display = 'inline-block';
    previewRecording.style.display = 'none';
    exportTutorial.style.display = 'none';
    
    attachListeners();
    
    recordingInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      recordingTime.textContent = mins + ':' + (secs < 10 ? '0' : '') + secs;
    }, 1000);
    
    console.log('üî¥ Recording started');
  });
  
  stopRecord.addEventListener('click', () => {
    isRecording = false;
    clearInterval(recordingInterval);
    
    stopRecord.style.display = 'none';
    startRecord.style.display = 'none';
    recordingIndicator.style.display = 'none';
    previewRecording.style.display = 'inline-block';
    recordAgain.style.display = 'inline-block';
    exportTutorial.style.display = 'inline-block';
    
    detachListeners();
    
    console.log('‚èπ Recording stopped. Captured ' + recordedEvents.length + ' events');
  });
  
  recordAgain.addEventListener('click', () => {
    // Stop any active playback
    isPlaying = false;
    
    // Hide any visible annotations
    annotationBox.classList.remove('visible');
    currentAnnotationIndex = -1;
    
    // Reload the app to reset its state
    const url = appFrame.src;
    appFrame.src = '';
    
    setTimeout(() => {
      appFrame.src = url;
      
      // Reset recording UI - keep app controls visible
      recordedEvents = [];
      currentTutorial = null;
      
      reloadApp.style.display = 'inline-block';
      startRecord.style.display = 'inline-block';
      stopRecord.style.display = 'none';
      recordingIndicator.style.display = 'none';
      previewRecording.style.display = 'none';
      playPausePreview.style.display = 'none';
      recordAgain.style.display = 'none';
      exportTutorial.style.display = 'none';
      
      console.log('üîÑ Ready to record again');
    }, 100);
  });
  
  backToRecording.addEventListener('click', () => {
    // Stop any active playback
    isPlaying = false;
    
    // Hide any visible annotations
    annotationBox.classList.remove('visible');
    currentAnnotationIndex = -1;
    
    // Go back to recording mode
    setMode('record');
    
    // Show the post-recording buttons
    previewRecording.style.display = 'inline-block';
    playPausePreview.style.display = 'none';
    recordAgain.style.display = 'inline-block';
    exportTutorial.style.display = 'inline-block';
    
    console.log('‚Üê Back to recording controls');
  });
  
  previewRecording.addEventListener('click', () => {
    if (recordedEvents.length === 0) {
      alert('No events recorded to preview!');
      return;
    }
    
    // Stop any active playback first
    isPlaying = false;
    
    // Create a temporary tutorial from the recorded events
    currentTutorial = {
      version: '1.0',
      appUrl: appFrame.src,
      duration: recordedEvents[recordedEvents.length - 1].timestamp,
      events: recordedEvents,
      annotations: []
    };
    
    // Hide Preview button, show Play/Pause button
    previewRecording.style.display = 'none';
    playPausePreview.style.display = 'inline-block';
    playPausePreview.textContent = '‚è∏ Pause';
    
    // ALWAYS reload the app to reset state - critical for repeated previews
    const url = appFrame.src;
    appFrame.src = '';
    
    setTimeout(() => {
      appFrame.src = url;
      
      // Wait for app to load, then auto-start playback with fresh state
      setTimeout(() => {
        // Reset all playback state
        playbackPausedAt = 0;
        playbackStartTime = Date.now();
        eventQueue = [...currentTutorial.events];
        isPlaying = true;
        
        requestAnimationFrame(playbackLoop);
        
        console.log('‚ñ∂ Playing preview... (fresh start)');
      }, 500);
    }, 100);
  });
  
  playPausePreview.addEventListener('click', () => {
    if (isPlaying) {
      // Pause
      isPlaying = false;
      playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
      playPausePreview.textContent = '‚ñ∂ Resume';
      console.log('‚è∏ Paused preview');
    } else {
      // Resume
      isPlaying = true;
      playbackStartTime = Date.now() - playbackPausedAt * 1000;
      playPausePreview.textContent = '‚è∏ Pause';
      requestAnimationFrame(playbackLoop);
      console.log('‚ñ∂ Resumed preview');
    }
  });
  
  function getElementSelector(element) {
    // Try ID first
    if (element.id) {
      return '#' + element.id;
    }
    
    // Try unique attribute combinations
    const tag = element.tagName.toLowerCase();
    
    // For SVG groups with specific classes (common in D3)
    if (tag === 'g' && element.classList.length > 0) {
      const classes = Array.from(element.classList);
      return tag + '.' + classes.join('.');
    }
    
    // For buttons with text content
    if (tag === 'button' && element.textContent.trim()) {
      return {
        type: 'button-text',
        tagName: 'button',
        text: element.textContent.trim()
      };
    }
    
    // Try name attribute
    if (element.name) {
      return tag + '[name="' + element.name + '"]';
    }
    
    // Try class combinations
    if (element.className && typeof element.className === 'string') {
      const classes = element.className.split(' ').filter(c => c.trim());
      if (classes.length > 0) {
        return tag + '.' + classes.join('.');
      }
    }
    
    // For SVG elements, try data attributes
    if (element.hasAttribute('data-index')) {
      return tag + '[data-index="' + element.getAttribute('data-index') + '"]';
    }
    
    // Fallback to nth-of-type
    let parent = element.parentElement;
    if (parent) {
      const siblings = Array.from(parent.children).filter(el => el.tagName === element.tagName);
      const index = siblings.indexOf(element);
      if (index >= 0) {
        return tag + ':nth-of-type(' + (index + 1) + ')';
      }
    }
    
    return tag;
  }
  
  function recordEvent(type, target, detail = {}) {
    if (!isRecording) return;
    
    const timestamp = Date.now() - recordStartTime;
    const selector = getElementSelector(target);
    
    const event = {
      timestamp,
      type,
      target: selector,
      detail
    };
    
    recordedEvents.push(event);
    console.log('üìù Recorded:', type, selector, detail);
  }
  
  function handleClick(e) {
    // Don't record if it's part of a drag
    if (isDragging) return;
    recordEvent('click', e.target);
  }
  
  function handleInput(e) {
    recordEvent('input', e.target, { value: e.target.value });
  }
  
  function handleChange(e) {
    recordEvent('change', e.target, { value: e.target.value });
  }
  
  // SIMPLIFIED DRAG APPROACH: Snapshot entire iframe before/after
  function handleMouseDown(e) {
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      if (!iframeDoc) return;
      
      // Check if element is draggable
      let element = e.target;
      let draggable = null;
      
      while (element && element !== iframeDoc) {
        const style = window.getComputedStyle(element);
        const cursor = style.cursor;
        
        if (cursor === 'grab' || cursor === 'move' || cursor === 'grabbing' ||
            element.draggable ||
            element.classList.contains('draggable') ||
            element.classList.contains('draggable-veil')) {
          draggable = element;
          break;
        }
        element = element.parentElement;
      }
      
      if (!draggable) return;
      
      isDragging = true;
      dragElement = draggable;
      dragStartTime = Date.now() - recordStartTime;
      
      // Take snapshots at regular intervals during the drag
      dragStartSnapshot = {
        frames: [
          {
            time: 0,
            html: iframeDoc.body.innerHTML
          }
        ]
      };
      
      // Sample the DOM every 100ms during drag for smooth replay
      dragCheckInterval = setInterval(() => {
        if (isDragging) {
          const currentTime = Date.now() - recordStartTime - dragStartTime;
          dragStartSnapshot.frames.push({
            time: currentTime,
            html: iframeDoc.body.innerHTML
          });
        }
      }, 100);
      
      console.log('üñ±Ô∏è Drag started - capturing animation frames...');
      
    } catch (e) {
      console.warn('Cannot handle mousedown:', e);
    }
  }
  
  function handleMouseUp(e) {
    console.log('üñ±Ô∏è mouseup detected, isDragging:', isDragging, 'dragElement:', dragElement);
    
    if (!isDragging || !dragElement) return;
    
    // Stop capturing frames
    if (dragCheckInterval) {
      clearInterval(dragCheckInterval);
      dragCheckInterval = null;
    }
    
    // CRITICAL: Capture the current recording state NOW, before the setTimeout
    const wasRecording = isRecording;
    const capturedDragElement = dragElement;
    const capturedSnapshot = dragStartSnapshot;
    const capturedStartTime = dragStartTime;
    
    // Clear drag state immediately
    isDragging = false;
    dragElement = null;
    dragStartSnapshot = null;
    
    if (!wasRecording || !capturedSnapshot) {
      console.log('Drag ended but not recording or no snapshot');
      return;
    }
    
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      if (!iframeDoc) {
        console.warn('Cannot access iframe document on mouseup');
        return;
      }
      
      // Wait a moment for the app to finish updating, then record
      setTimeout(() => {
        const currentTime = Date.now() - recordStartTime - capturedStartTime;
        
        // Add final frame
        capturedSnapshot.frames.push({
          time: currentTime,
          html: iframeDoc.body.innerHTML
        });
        
        console.log('üì∏ Captured', capturedSnapshot.frames.length, 'total frames');
        
        // Always record the drag if we have multiple frames
        if (capturedSnapshot.frames.length > 1) {
          // Manually add to recordedEvents (bypassing isRecording check in recordEvent)
          const timestamp = capturedStartTime;
          const selector = getElementSelector(capturedDragElement);
          
          const event = {
            timestamp,
            type: 'drag',
            target: selector,
            detail: {
              animationFrames: capturedSnapshot.frames,
              duration: currentTime
            }
          };
          
          recordedEvents.push(event);
          console.log('‚úÖ Drag recorded successfully with', capturedSnapshot.frames.length, 'animation frames');
        } else {
          console.warn('‚ö†Ô∏è Drag had only 1 frame - not recording');
        }
        
      }, 100); // Wait 100ms for app to finish updating
      
    } catch (e) {
      console.warn('Cannot handle mouseup:', e);
    }
  }
  
  function attachListeners() {
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      const iframeWin = appFrame.contentWindow;
      
      if (!iframeDoc) {
        console.warn('Cannot access iframe document');
        return;
      }
      
      // Click events
      iframeDoc.addEventListener('click', handleClick, true);
      
      // Input events
      const inputs = iframeDoc.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        input.addEventListener('input', handleInput);
        input.addEventListener('change', handleChange);
      });
      
      // Drag events - attach to BOTH document and window
      // D3 often uses window-level listeners for drag
      iframeDoc.addEventListener('mousedown', handleMouseDown, true);
      iframeDoc.addEventListener('mouseup', handleMouseUp, true);
      
      if (iframeWin) {
        iframeWin.addEventListener('mouseup', handleMouseUp, true);
        console.log('‚úì Event listeners attached to both document and window (including simplified drag tracking)');
      } else {
        console.log('‚úì Event listeners attached to document only (including simplified drag tracking)');
      }
    } catch (e) {
      console.warn('Cannot attach listeners to iframe:', e);
    }
  }
  
  function detachListeners() {
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      const iframeWin = appFrame.contentWindow;
      
      if (!iframeDoc) return;
      
      iframeDoc.removeEventListener('click', handleClick, true);
      iframeDoc.removeEventListener('mousedown', handleMouseDown, true);
      iframeDoc.removeEventListener('mouseup', handleMouseUp, true);
      
      // Also remove from window
      if (iframeWin) {
        iframeWin.removeEventListener('mouseup', handleMouseUp, true);
      }
      
      const inputs = iframeDoc.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        input.removeEventListener('input', handleInput);
        input.removeEventListener('change', handleChange);
      });
      
      // Clean up any active drag sampling
      if (dragCheckInterval) {
        clearInterval(dragCheckInterval);
        dragCheckInterval = null;
      }
      isDragging = false;
      dragElement = null;
      dragStartSnapshot = null;
      
      console.log('‚úì Event listeners detached');
    } catch (e) {
      console.warn('Cannot detach listeners from iframe:', e);
    }
  }
  
  // Export
  exportTutorial.addEventListener('click', () => {
    const tutorial = {
      version: '1.0',
      appUrl: appFrame.src,
      duration: recordedEvents.length > 0 ? recordedEvents[recordedEvents.length - 1].timestamp : 0,
      events: recordedEvents,
      annotations: [
        {
          timestamp: 0,
          duration: 3000,
          title: "Welcome",
          text: "Edit this tutorial JSON to add your annotations. Change timestamps, titles, text, and positions.",
          position: "top"
        },
        {
          timestamp: 5000,
          duration: 4000,
          title: "Step 1",
          text: "Add annotations at key moments. Available positions: top, bottom, left, right, center, top-left, top-right, bottom-left, bottom-right",
          position: "bottom"
        }
      ],
      notes: "Position options: 'top' (default), 'bottom', 'left', 'right', 'center', 'top-left', 'top-right', 'bottom-left', 'bottom-right'"
    };
    
    exportTextarea.value = JSON.stringify(tutorial, null, 2);
    exportModal.classList.add('visible');
  });
  
  copyExport.addEventListener('click', () => {
    exportTextarea.select();
    document.execCommand('copy');
    copyExport.textContent = '‚úì Copied!';
    setTimeout(() => { copyExport.textContent = 'üìã Copy to Clipboard'; }, 2000);
  });
  
  closeExportModal.addEventListener('click', () => {
    exportModal.classList.remove('visible');
  });
  
  // Load tutorial
  loadTutorial.addEventListener('click', () => {
    loadModal.classList.add('visible');
    loadError.style.display = 'none';
  });
  
  loadFromFile.addEventListener('click', () => {
    fileInput.click();
  });
  
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      loadTextarea.value = e.target.result;
    };
    reader.readAsText(file);
  });
  
  loadFromText.addEventListener('click', () => {
    const jsonText = loadTextarea.value.trim();
    
    loadError.style.display = 'none';
    
    if (!jsonText) {
      loadError.textContent = 'Please paste tutorial JSON first!';
      loadError.style.display = 'block';
      return;
    }
    
    try {
      currentTutorial = JSON.parse(jsonText);
      
      // Validate
      if (!currentTutorial.appUrl) {
        throw new Error('Missing "appUrl" field in tutorial');
      }
      if (!currentTutorial.events || !Array.isArray(currentTutorial.events)) {
        throw new Error('Missing or invalid "events" array');
      }
      if (currentTutorial.duration === undefined) {
        throw new Error('Missing "duration" field');
      }
      
      // Load the app
      appFrame.src = currentTutorial.appUrl;
      appUrl.value = currentTutorial.appUrl;
      
      // Setup playback
      const duration = currentTutorial.duration / 1000;
      totalTimeEl.textContent = formatTime(duration);
      timelineSlider.max = duration;
      timelineSlider.value = 0;
      currentTimeEl.textContent = '0:00';
      playbackPausedAt = 0;
      playbackStartTime = 0;
      
      loadModal.classList.remove('visible');
      loadTextarea.value = '';
      
      alert('‚úì Tutorial loaded successfully! Click on the "Playback" tab, then click Play (‚ñ∂) to start.');
      
    } catch (e) {
      loadError.textContent = 'Invalid JSON! Error: ' + e.message + '\n\nMake sure you copied the entire JSON correctly.';
      loadError.style.display = 'block';
      console.error('JSON parse error:', e);
      console.log('Attempted JSON:', jsonText.substring(0, 500));
    }
  });
  
  closeLoadModal.addEventListener('click', () => {
    loadModal.classList.remove('visible');
  });
  
  // Playback
  playBtn.addEventListener('click', () => {
    if (!currentTutorial) {
      alert('Please load a tutorial first!');
      return;
    }
    
    isPlaying = true;
    playBtn.style.display = 'none';
    pauseBtn.style.display = 'inline-block';
    
    if (playbackPausedAt > 0) {
      playbackStartTime = Date.now() - playbackPausedAt * 1000;
    } else {
      playbackStartTime = Date.now();
      eventQueue = [...currentTutorial.events];
    }
    
    requestAnimationFrame(playbackLoop);
  });
  
  pauseBtn.addEventListener('click', () => {
    isPlaying = false;
    playBtn.style.display = 'inline-block';
    pauseBtn.style.display = 'none';
    playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
  });
  
  restartBtn.addEventListener('click', () => {
    isPlaying = false;
    playBtn.style.display = 'inline-block';
    pauseBtn.style.display = 'none';
    playbackPausedAt = 0;
    playbackStartTime = 0;
    timelineSlider.value = 0;
    currentTimeEl.textContent = '0:00';
    currentAnnotationIndex = -1;
    annotationBox.classList.remove('visible');
    eventQueue = [];
    
    // Reload app
    const url = appFrame.src;
    appFrame.src = '';
    setTimeout(() => { appFrame.src = url; }, 100);
  });
  
  playbackSpeedSelect.addEventListener('change', () => {
    playbackSpeed = parseFloat(playbackSpeedSelect.value);
  });
  
  timelineSlider.addEventListener('input', () => {
    if (isPlaying) return;
    playbackPausedAt = parseFloat(timelineSlider.value);
    currentTimeEl.textContent = formatTime(playbackPausedAt);
  });
  
  function playbackLoop() {
    if (!isPlaying) return;
    
    const elapsed = (Date.now() - playbackStartTime) / 1000;
    const duration = currentTutorial.duration / 1000;
    
    // Update timeline if visible (only in full playback mode)
    if (playbackControls.style.display !== 'none') {
      timelineSlider.value = elapsed;
      currentTimeEl.textContent = formatTime(elapsed);
    }
    
    // Process events
    while (eventQueue.length > 0 && eventQueue[0].timestamp / 1000 <= elapsed) {
      const event = eventQueue.shift();
      replayEvent(event);
    }
    
    // Handle annotations
    if (currentTutorial.annotations) {
      currentTutorial.annotations.forEach((ann, idx) => {
        const annStart = ann.timestamp / 1000;
        const annEnd = annStart + (ann.duration || 5000) / 1000;
        
        if (elapsed >= annStart && elapsed < annEnd && currentAnnotationIndex !== idx) {
          currentAnnotationIndex = idx;
          showAnnotation(ann.title, ann.text, ann.position || 'top');
        } else if (elapsed >= annEnd && currentAnnotationIndex === idx) {
          annotationBox.classList.remove('visible');
          currentAnnotationIndex = -1;
        }
      });
    }
    
    if (elapsed >= duration) {
      isPlaying = false;
      
      // Hide any visible annotations
      annotationBox.classList.remove('visible');
      currentAnnotationIndex = -1;
      
      // If this was a simple preview (playPausePreview visible), reset to preview button
      if (playPausePreview.style.display !== 'none') {
        playPausePreview.style.display = 'none';
        previewRecording.style.display = 'inline-block';
        
        // App remains interactive - no reload needed
        // User can continue using the app normally
        console.log('‚úì Preview finished - app remains interactive');
      } else {
        // Normal playback mode
        playBtn.style.display = 'inline-block';
        pauseBtn.style.display = 'none';
      }
      
      return;
    }
    
    requestAnimationFrame(playbackLoop);
  }
  
  function replayEvent(event) {
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      const element = findElement(iframeDoc, event.target);
      
      if (!element) {
        console.warn('Element not found for replay:', event.target);
        return;
      }
      
      // Visual feedback
      const originalOutline = element.style.outline;
      element.style.outline = '3px solid #2563eb';
      element.style.outlineOffset = '2px';
      setTimeout(() => {
        element.style.outline = originalOutline;
      }, 500);
      
      if (event.type === 'click') {
        element.click();
      } else if (event.type === 'input' || event.type === 'change') {
        if (event.detail.value !== undefined) {
          element.value = event.detail.value;
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
        }
      } else if (event.type === 'drag') {
        replayDrag(element, event.detail, iframeDoc);
      }
      
      console.log('Replayed event:', event.type, event.target);
    } catch (e) {
      console.warn('Cannot replay event:', e, event);
    }
  }
  
  function replayDrag(element, detail, iframeDoc) {
    // Use animation frames method - replay each frame with proper timing
    if (detail.animationFrames && detail.animationFrames.length > 0) {
      try {
        console.log('üé¨ Replaying drag with', detail.animationFrames.length, 'animation frames at speed', playbackSpeed + 'x');
        
        // Play frames using cumulative timing (not just frame.time directly)
        let cumulativeDelay = 0;
        detail.animationFrames.forEach((frame, index) => {
          // For first frame, delay is 0
          // For subsequent frames, delay is based on time since previous frame
          if (index > 0) {
            const intervalSinceLast = frame.time - detail.animationFrames[index - 1].time;
            cumulativeDelay += intervalSinceLast / playbackSpeed;
          }
          
          setTimeout(() => {
            try {
              iframeDoc.body.innerHTML = frame.html;
              console.log('  Frame', index + 1, '/', detail.animationFrames.length);
              
              if (index === detail.animationFrames.length - 1) {
                console.log('‚úì Drag animation complete');
              }
            } catch (e) {
              console.warn('Failed to apply frame', index, ':', e);
            }
          }, cumulativeDelay);
        });
        
        return;
      } catch (e) {
        console.warn('Animation frame replay failed:', e);
      }
    }
    
    // Backward compatibility: handle old snapshot format
    if (detail.snapshotAfter) {
      try {
        iframeDoc.body.innerHTML = detail.snapshotAfter;
        console.log('‚úì Replayed drag using snapshot (legacy format)');
        return;
      } catch (e) {
        console.warn('Snapshot replay failed:', e);
      }
    }
    
    // Fallback: can't replay drag
    console.warn('Cannot replay drag - no animation data available');
  }
  
  function findElement(doc, selector) {
    if (!selector) return null;
    
    // Handle object-based selectors
    if (typeof selector === 'object') {
      if (selector.type === 'button-text') {
        const buttons = doc.querySelectorAll(selector.tagName || 'button');
        for (let btn of buttons) {
          if (btn.textContent.trim() === selector.text) {
            return btn;
          }
        }
      }
      return null;
    }
    
    // String selectors
    if (selector.startsWith('#')) {
      return doc.getElementById(selector.substring(1));
    }
    
    // Try direct querySelector
    try {
      const element = doc.querySelector(selector);
      if (element) return element;
      
      // If not found and it's an SVG selector, try looking in SVG namespace
      const svg = doc.querySelector('svg');
      if (svg) {
        return svg.querySelector(selector);
      }
      
      return null;
    } catch (e) {
      console.warn('Invalid selector:', selector, e);
      return null;
    }
  }
  
  function showAnnotation(title, text, position = 'top') {
    annotationBox.className = 'annotation-box visible pos-' + position;
    annotationTitle.textContent = title;
    annotationText.textContent = text;
  }
  
  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return mins + ':' + (secs < 10 ? '0' : '') + secs;
  }
  
  // Help
  helpBtn.addEventListener('click', () => {
    helpModal.classList.add('visible');
  });
  
  closeHelpModal.addEventListener('click', () => {
    helpModal.classList.remove('visible');
  });
  
  // Close modals on outside click
  [exportModal, loadModal, helpModal].forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.remove('visible');
      }
    });
  });
})();
</script>
</body>
</html>
