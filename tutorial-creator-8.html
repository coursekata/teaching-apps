<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Tutorial Creator - v13.11</title>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    },
    startup: {
      ready: () => {
        MathJax.startup.defaultReady();
      }
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  :root{
    --accent:#2563eb;
    --record:#ef4444;
    --success:#10b981;
    --warning:#f59e0b;
    --teal:#06b6d4;
  }
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#111;
    background:#f5f5f5;
  }
  
  .tutorial-header{
    position: sticky;
    top: 0;
    background:#fff;
    border-bottom:2px solid #ddd;
    padding:12px 20px;
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .version-number{
    color: #666;
    font-size: 12px;
    font-weight: 500;
  }
  
  .tutorial-controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  button{
    padding:8px 14px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:13px;
  }
  
  button:hover:not(:disabled):not(.primary):not(.record):not(.success):not(.warning):not(.teal){
    background:#f9f9f9;
  }
  
  button:disabled{
    opacity:0.5;
    cursor:not-allowed;
  }
  
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button.record{
    background:var(--record);
    color:#fff;
    border-color:var(--record);
  }
  
  button.success{
    background:var(--success);
    color:#fff;
    border-color:var(--success);
  }
  
  button.warning{
    background:var(--warning);
    color:#fff;
    border-color:var(--warning);
  }
  
  button.teal{
    background:var(--teal);
    color:#fff;
    border-color:var(--teal);
  }
  
  button.record.recording{
    animation:pulse 1.5s infinite;
  }
  
  button.primary.playing{
    animation:pulse 1.5s infinite;
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.6}
  }
  
  .recording-active{
    animation:pulse 1.5s infinite;
  }
  
  .recording-indicator{
    background:var(--record);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
    animation:pulse 1.5s infinite;
  }
  
  .paused-indicator{
    background:var(--warning);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
  }
  
  .app-container{
    position:relative;
    width:1000px;
    height:800px;
    overflow:auto;
    margin:0 auto;
    border:1px solid #ddd;
    border-radius:8px;
    margin-bottom:40px;
  }
  
  iframe{
    width:1000px;
    height:100%;
    border:none;
  }
  
  iframe.playback-mode{
    pointer-events:none;
  }
  
  .annotation-box{
    position:absolute;
    width:250px;
    max-width:500px;
    background:rgba(255,255,255,0.98);
    border:3px solid var(--accent);
    border-radius:12px;
    padding:20px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15);
    z-index:100;
    display:none;
    overflow-y:auto;
    overflow-x:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    font-size:15px;
    line-height:1.6;
  }
  
  .annotation-box.custom-position{
    max-width:none;
  }
  
  .annotation-box.draggable{
    cursor:move;
    box-shadow:0 8px 24px rgba(0,0,0,0.2);
    z-index:10001;
  }
  
  .annotation-box.visible{
    display:block;
    animation:slideIn 0.3s ease-out;
  }
  
  .annotation-box.draggable .resize-handle{
    position:absolute;
    bottom:0;
    right:0;
    width:16px;
    height:16px;
    background:rgba(37, 99, 235, 0.3);
    cursor:nwse-resize;
    border-top-left-radius:4px;
    border-bottom-right-radius:12px;
  }
  
  .annotation-box.draggable .resize-handle::after{
    content:'‚ã∞';
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    color:rgba(37, 99, 235, 0.7);
    font-size:12px;
    line-height:1;
  }
  
  @keyframes slideIn{
    from{opacity:0;}
    to{opacity:1;}
  }
  
  .annotation-box h3{
    margin:0 0 12px;
    color:var(--accent);
    font-size:18px;
    line-height:1.3;
  }
  
  .annotation-box p{
    margin:0;
    line-height:inherit;
    font-size:inherit;
  }
  
  /* Timeline Editor */
  .timeline-container{
    background:#fff;
    border-top:2px solid #ddd;
    border-bottom:2px solid #ddd;
    padding:4px 20px 6px 20px;
    display:none;
    position:relative;
    margin-bottom:8px;
  }
  
  .timeline-container.visible{
    display:block;
  }
  
  .timeline-ruler{
    height:14px;
    position:relative;
    margin-bottom:0px;
    margin-left:60px;
    overflow:hidden;
  }
  
  .timeline-tick{
    position:absolute;
    top:0;
    font-size:8px;
    color:#999;
  }
  
  .timeline-track{
    height:26px;
    background:#fafafa;
    border:1px solid #ddd;
    border-radius:4px;
    position:relative;
    margin-bottom:2px;
    overflow:hidden;
    padding-left:60px;
  }
  
  .timeline-track-label{
    position:absolute;
    left:4px;
    top:50%;
    transform:translateY(-50%);
    font-size:9px;
    font-weight:600;
    color:#666;
    pointer-events:none;
    z-index:0;
    width:55px;
    text-align:right;
    padding-right:5px;
  }
  
  .timeline-event{
    position:absolute;
    top:2px;
    bottom:2px;
    width:8px;
    background:#6366f1;
    border-radius:2px;
    cursor:move;
    z-index:1;
    box-shadow:0 1px 3px rgba(99,102,241,0.3);
  }
  
  .timeline-event.drag-event{
    width:auto;
    background:#8b5cf6;
    box-shadow:0 1px 3px rgba(139,92,246,0.3);
  }
  
  .timeline-event:not(.drag-event):hover{
    background:#4f46e5;
    transform:scaleX(1.3);
  }
  
  .timeline-event.drag-event:hover{
    background:#7c3aed;
  }
  
  .event-trim-handle{
    position:absolute;
    top:0;
    bottom:0;
    width:6px;
    background:rgba(255,255,255,0.3);
    cursor:ew-resize;
    opacity:0;
    transition:opacity 0.2s;
    z-index:10;
  }
  
  .timeline-event.drag-event:hover .event-trim-handle{
    opacity:1;
  }
  
  .event-trim-handle.left{
    left:0;
    border-right:2px solid rgba(255,255,255,0.6);
  }
  
  .event-trim-handle.right{
    right:0;
    border-left:2px solid rgba(255,255,255,0.6);
  }
  
  .event-trim-handle:hover{
    background:rgba(255,255,255,0.5);
  }
  
  .timeline-annotation{
    position:absolute;
    top:2px;
    bottom:2px;
    background:linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
    border-radius:3px;
    color:#fff;
    font-size:9px;
    padding:0 6px;
    display:flex;
    align-items:center;
    cursor:move;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    z-index:2;
    box-shadow:0 2px 4px rgba(6,182,212,0.3);
    border:1px solid rgba(255,255,255,0.2);
  }
  
  .timeline-annotation:hover{
    background:linear-gradient(135deg, #0891b2 0%, #0e7490 100%);
    box-shadow:0 2px 6px rgba(6,182,212,0.4);
  }
  
  .timeline-annotation .resize-edge{
    position:absolute;
    top:0;
    bottom:0;
    width:5px;
    cursor:ew-resize;
    background:rgba(255,255,255,0.2);
  }
  
  .timeline-annotation .resize-edge.left{
    left:0;
    border-radius:3px 0 0 3px;
  }
  
  .timeline-annotation .resize-edge.right{
    right:0;
    border-radius:0 3px 3px 0;
  }
  
  .timeline-annotation .resize-edge:hover{
    background:rgba(255,255,255,0.4);
  }
  
  .timeline-pause{
    position:absolute;
    top:50%;
    width:12px;
    height:12px;
    background:#f59e0b;
    transform:translateY(-50%) rotate(45deg);
    cursor:move;
    z-index:3;
    box-shadow:0 2px 4px rgba(245,158,11,0.4);
    border:1px solid rgba(255,255,255,0.3);
  }
  
  .timeline-pause:hover{
    background:#d97706;
    box-shadow:0 3px 6px rgba(245,158,11,0.5);
    transform:translateY(-50%) rotate(45deg) scale(1.15);
  }
  
  .timeline-playhead{
    position:absolute;
    top:14px;
    height:56px;
    width:3px;
    background:#ef4444;
    pointer-events:none;
    z-index:9999;
    box-shadow:0 0 8px rgba(239,68,68,0.5);
  }
  
  .timeline-playhead::before{
    content:'';
    position:absolute;
    top:-8px;
    left:50%;
    transform:translateX(-50%);
    width:12px;
    height:12px;
    background:#ef4444;
    border-radius:50%;
    border:2px solid #fff;
    box-shadow:0 2px 6px rgba(0,0,0,0.3);
    z-index:10000;
    cursor:grab;
    pointer-events:auto;
  }
  
  .timeline-playhead::before:active{
    cursor:grabbing;
  }
  
  .timeline-playhead.dragging::before{
    transform:translateX(-50%) scale(1.1);
    box-shadow:0 4px 12px rgba(239,68,68,0.4);
  }
  
  .modal-overlay{
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.5);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:1000;
  }
  
  .modal-overlay.visible{
    display:flex;
  }
  
  .modal{
    background:#fff;
    border-radius:12px;
    padding:24px;
    max-width:700px;
    width:90%;
    max-height:80vh;
    overflow-y:auto;
    box-shadow:0 8px 32px rgba(0,0,0,0.2);
  }
  
  .modal h2{
    margin:0 0 16px;
    color:#111;
  }
  
  .modal textarea{
    width:100%;
    min-height:300px;
    max-height:400px;
    font-family:monospace;
    font-size:12px;
    padding:12px;
    border:1px solid #ddd;
    border-radius:8px;
    resize:vertical;
    overflow-y:auto;
  }
  
  .modal input[type=text]{
    width:100%;
    padding:8px 12px;
    border:1px solid #ddd;
    border-radius:8px;
    font-size:14px;
    margin-bottom:12px;
  }
  
  .modal-buttons{
    display:flex;
    gap:8px;
    margin-top:16px;
    justify-content:flex-end;
  }
  
  .help-text{
    font-size:13px;
    color:#666;
    margin:8px 0;
    line-height:1.5;
  }
  
  ol.help-text{
    margin-left:20px;
    padding-left:0;
  }
  
  ol.help-text li{
    margin:6px 0;
  }
  
  .control-group{
    display:flex;
    gap:8px;
    align-items:center;
  }
  
  label{
    font-size:12px;
    color:#666;
    display:flex;
    align-items:center;
    gap:6px;
  }
  
  input[type=text]{
    padding:6px 10px;
    border-radius:6px;
    border:1px solid #ddd;
    font-size:13px;
    width:300px;
  }
  
  .info-box{
    background:#e0f2fe;
    border:1px solid #0284c7;
    border-radius:8px;
    padding:12px;
    margin:12px 0;
    font-size:13px;
    color:#0c4a6e;
  }
  
  .info-box strong{
    color:#075985;
  }
  
  .form-group{
    margin-bottom:16px;
  }
  
  .form-group label{
    display:block;
    margin-bottom:6px;
    font-weight:600;
    color:#374151;
  }
  
  .form-group textarea{
    width:100%;
    min-height:100px;
    padding:8px 12px;
    border:1px solid #ddd;
    border-radius:8px;
    font-size:14px;
    font-family:inherit;
    resize:vertical;
  }
  
  .version-number{
    position: fixed;
    top: 8px;
    right: 12px;
    font-size: 11px;
    color: #999;
    background: rgba(255,255,255,0.9);
    padding: 4px 8px;
    border-radius: 4px;
    z-index: 1000;
    font-family: monospace;
  }
</style>
</head>
<body>
  <div class="tutorial-header">
    <div class="tutorial-controls">
      <div id="recordingControls" class="control-group">
        <label>
          App URL:
          <input type="text" id="appUrl" placeholder="Enter your app URL" value=""/>
        </label>
        <button id="loadApp" class="primary">Load App</button>
        <button id="startRecording" class="record" style="display:none;" title="Start recording interactions">‚è∫ Record</button>
        <button id="loadJSON" class="success" style="display:none;" title="Import existing tutorial JSON">Import</button>
        <button id="playPauseRecording" class="warning" style="display:none;" title="Pause recording">‚è∏</button>
        <span id="recordingIndicator" class="recording-indicator" style="display:none;">‚è∫ REC</span>
        <span id="pausedIndicator" class="paused-indicator" style="display:none;">‚è∏ PAUSED</span>
        <button id="addAnnotation" class="teal" style="display:none;" disabled title="Add text annotation">+Text</button>
        <button id="addPause" class="warning" style="display:none;" disabled title="Add pause point for students">+Pause</button>
        <button id="previewRecording" class="primary" style="display:none;" disabled title="Play tutorial">‚ñ∂ Play</button>
        <button id="playPausePreview" style="display:none;"></button><!-- Hidden, kept for compatibility -->
        <button id="recordAgain" class="record" style="display:none;" disabled title="Discard and start over">New Tutorial</button>
        <button id="exportRecording" class="success" style="display:none;" disabled title="Export tutorial JSON">Export</button>
      </div>
      
      <button id="helpBtn" style="margin-left:auto;" title="Show help">‚ùì</button>
      <input type="file" id="jsonFileInput" accept=".json" style="display:none;">
    </div>
    <div class="version-number">v13.11</div>
  </div>
  
  <!-- Timeline Editor (moved outside header so it scrolls independently) -->
  <div id="timelineContainer" class="timeline-container">
    <div id="timelineRuler" class="timeline-ruler"></div>
    
    <div class="timeline-track">
      <div class="timeline-track-label">Events</div>
      <div id="eventsTrack" style="position:relative;height:100%;"></div>
    </div>
    
    <div class="timeline-track">
      <div class="timeline-track-label">Annotations</div>
      <div id="annotationsTrack" style="position:relative;height:100%;"></div>
    </div>
    
    <div id="timelinePlayhead" class="timeline-playhead" style="display:none;"></div>
  </div>
  
  <div class="app-container">
    <iframe id="appFrame" sandbox="allow-scripts allow-same-origin"></iframe>
  </div>
  
  <!-- Annotation Editor Modal -->
  <div id="annotationEditorModal" class="modal-overlay">
    <div class="modal">
      <h2>Add Annotation</h2>
      
      <div class="info-box">
        <strong>üìù Instructions:</strong> Fill in the fields below and click "Create Annotation". The annotation will appear on screen where you can drag it to position it perfectly.
      </div>
      
      <div class="form-group">
        <label>Title</label>
        <input type="text" id="annTitle" placeholder="Enter annotation title..."/>
      </div>
      
      <div class="form-group">
        <label>Text</label>
        <textarea id="annText" placeholder="Enter annotation description..."></textarea>
      </div>
      
      <div class="form-group">
        <label>Duration (seconds)</label>
        <input type="number" id="annDuration" value="5" min="1" max="60" style="width:100px;"/>
      </div>
      
      <div class="modal-buttons">
        <button id="cancelAnnotation">Cancel</button>
        <button id="createAnnotation" class="primary">‚ú® Create Annotation</button>
      </div>
    </div>
  </div>
  
  <!-- Position Editor Overlay -->
  <div id="positionEditorOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:transparent;z-index:99;pointer-events:none;">
    <div style="position:absolute;top:20px;left:50%;transform:translateX(-50%);background:#fff;padding:16px 24px;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.15);pointer-events:auto;">
      <div style="font-weight:600;margin-bottom:8px;color:#111;">üìç Position Your Annotation</div>
      <div style="font-size:13px;color:#666;margin-bottom:12px;">Drag to move, resize from corner. Double-click title or text to edit.</div>
      <div style="display:flex;gap:8px;">
        <button id="savePosition" class="success">Save</button>
        <button id="deleteAnnotationFromOverlay" class="record">Delete</button>
        <button id="cancelPosition">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Event Deletion Modal -->
  <div id="eventDeletionModal" class="modal-overlay">
    <div class="modal" style="max-width:400px;">
      <h2>Delete Event?</h2>
      <p id="eventDeletionText" style="margin:16px 0;color:#666;">Are you sure you want to delete this event?</p>
      <div class="modal-buttons">
        <button id="cancelEventDeletion">Cancel</button>
        <button id="confirmEventDeletion" class="warning">üóë Delete</button>
      </div>
    </div>
  </div>
  
  <!-- Pause Deletion Modal -->
  <div id="pauseDeletionModal" class="modal-overlay">
    <div class="modal" style="max-width:400px;">
      <h2>Delete Pause?</h2>
      <p id="pauseDeletionText" style="margin:16px 0;color:#666;">Are you sure you want to delete this pause?</p>
      <div class="modal-buttons">
        <button id="cancelPauseDeletion">Cancel</button>
        <button id="confirmPauseDeletion" class="warning">üóë Delete</button>
      </div>
    </div>
  </div>
  
  <!-- Export Modal -->
  <div id="exportModal" class="modal-overlay">
    <div class="modal">
      <h2>Export Tutorial</h2>
      
      <div class="info-box">
        <strong>‚úì Recording Complete!</strong><br>
        Your tutorial has been recorded with <strong id="snapshotCount">0</strong> snapshots and <strong id="annotationCount">0</strong> annotations.
      </div>
      
      <p class="help-text">Download the JSON file to save your tutorial. You can load it later using the "Import Tutorial" button.</p>
      
      <textarea id="exportTextarea" readonly></textarea>
      
      <div class="modal-buttons">
        <button id="downloadExport" class="success">üíæ Download JSON</button>
        <button id="copyExport" class="primary">üìã Copy to Clipboard</button>
        <button id="closeExportModal">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Help Modal -->
  <div id="helpModal" class="modal-overlay">
    <div class="modal">
      <h2>How to Use</h2>
      
      <h3>Recording Mode:</h3>
      <ol class="help-text">
        <li><strong>Enter App URL</strong> - Type the URL of the web app you want to create a tutorial for</li>
        <li><strong>Load App</strong> - Click "Load App" to load the app in the iframe</li>
        <li><strong>Start Recording</strong> - Click "‚è∫ Start Recording" when you're ready to begin the tutorial</li>
        <li><strong>Interact Normally</strong> - Use your app normally. All interactions are being captured via the API!</li>
        <li><strong>Pause Recording</strong> - Click "‚è∏ Pause" to pause and add annotations or review your work</li>
        <li><strong>Add Annotations</strong> - While paused:
          <ul style="margin-left:20px;">
            <li>Click "‚ûï Add Annotation"</li>
            <li>Enter title, text, and duration</li>
            <li>Click "‚ú® Create Annotation"</li>
            <li>Drag the annotation box to position it exactly where you want</li>
            <li>Click "Save" when ready</li>
          </ul>
        </li>
        <li><strong>Preview While Recording</strong> - While paused, click "üëÅ Preview" to see your work so far, then click "‚Ü©Ô∏è Resume Recording" to continue</li>
        <li><strong>Resume Recording</strong> - Click "‚è∫ Resume" to continue recording</li>
        <li><strong>Finish Recording</strong> - When you're done, pause the recording. You can then Preview your work or Export it.</li>
        <li><strong>Preview Final</strong> - Click "üëÅ Preview" to watch the complete replay with annotations</li>
        <li><strong>Export</strong> - Click "üíæ Export Tutorial" to get the JSON, then copy it to save. This also finalizes the recording.</li>
        <li><strong>Start Over</strong> - Click "üîÑ Start Over" at any time to reset and create a new tutorial</li>
      </ol>
      
      <h3>Timeline:</h3>
      <ul class="help-text">
        <li><strong style="color:#6366f1;">Blue markers</strong> - Single events (simulate, parameter changes, etc.)</li>
        <li><strong style="color:#8b5cf6;">Purple bars</strong> - Drag operations (from mouse down to mouse up)</li>
        <li><strong style="color:#f59e0b;">Amber diamonds</strong> - Pauses (students must click to continue)</li>
        <li><strong style="color:#06b6d4;">Cyan bars</strong> - Annotations (text overlays during playback)</li>
      </ul>
      
      <div class="modal-buttons">
        <button id="closeHelpModal" class="primary">Got it!</button>
      </div>
    </div>
  </div>

<script>
(function() {
  'use strict';
  
  // DOM Elements
  const appUrl = document.getElementById('appUrl');
  const appFrame = document.getElementById('appFrame');
  const appContainer = document.querySelector('.app-container');
  const loadApp = document.getElementById('loadApp');
  const startRecording = document.getElementById('startRecording');
  const playPauseRecording = document.getElementById('playPauseRecording');
  const addAnnotation = document.getElementById('addAnnotation');
  const addPause = document.getElementById('addPause');
  const previewRecording = document.getElementById('previewRecording');
  const playPausePreview = document.getElementById('playPausePreview');
  const replayPreview = { style: { display: 'none' } }; // Button removed in v12.8, stub to prevent errors
  const addAnnotationAtPause = { style: { display: 'none' } }; // Button removed in v12.8, stub to prevent errors
  const recordAgain = document.getElementById('recordAgain');
  const exportRecording = document.getElementById('exportRecording');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const pausedIndicator = document.getElementById('pausedIndicator');
  
  const annotationEditorModal = document.getElementById('annotationEditorModal');
  const annTitle = document.getElementById('annTitle');
  const annText = document.getElementById('annText');
  const annDuration = document.getElementById('annDuration');
  const createAnnotation = document.getElementById('createAnnotation');
  const cancelAnnotation = document.getElementById('cancelAnnotation');
  
  // Fix cursor positioning in annotation fields with detailed logging
  [annTitle, annText, annDuration].forEach(field => {
    const fieldName = field.id;
    
    field.addEventListener('focus', function(e) {
      console.log(`[${fieldName}] FOCUS - selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}, value length: ${this.value.length}`);
    });
    
    field.addEventListener('mousedown', function(e) {
      console.log(`[${fieldName}] MOUSEDOWN - selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}, value length: ${this.value.length}`);
      // If the entire field is selected when user clicks, clear selection first
      if (this.selectionStart === 0 && this.selectionEnd === this.value.length) {
        console.log(`[${fieldName}] - All text selected, clearing selection`);
        this.setSelectionRange(0, 0);
      }
    });
    
    field.addEventListener('mouseup', function(e) {
      console.log(`[${fieldName}] MOUSEUP - selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}`);
    });
    
    field.addEventListener('click', function(e) {
      console.log(`[${fieldName}] CLICK - selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}`);
    });
    
    field.addEventListener('select', function(e) {
      console.log(`[${fieldName}] SELECT event - selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}`);
    });
  });
  
  const positionEditorOverlay = document.getElementById('positionEditorOverlay');
  const savePosition = document.getElementById('savePosition');
  const deleteAnnotationFromOverlay = document.getElementById('deleteAnnotationFromOverlay');
  const cancelPosition = document.getElementById('cancelPosition');
  
  const eventDeletionModal = document.getElementById('eventDeletionModal');
  const eventDeletionText = document.getElementById('eventDeletionText');
  const confirmEventDeletion = document.getElementById('confirmEventDeletion');
  const cancelEventDeletion = document.getElementById('cancelEventDeletion');
  
  // Event deletion state
  let eventToDelete = null; // Will store {startIdx, endIdx} or {startIdx} for single events
  
  const pauseDeletionModal = document.getElementById('pauseDeletionModal');
  const pauseDeletionText = document.getElementById('pauseDeletionText');
  const confirmPauseDeletion = document.getElementById('confirmPauseDeletion');
  const cancelPauseDeletion = document.getElementById('cancelPauseDeletion');
  
  // Pause deletion state
  let pauseToDelete = null; // Will store pause index
  
  
  const exportModal = document.getElementById('exportModal');
  const exportTextarea = document.getElementById('exportTextarea');
  const snapshotCount = document.getElementById('snapshotCount');
  const annotationCount = document.getElementById('annotationCount');
  const downloadExport = document.getElementById('downloadExport');
  const copyExport = document.getElementById('copyExport');
  const closeExportModal = document.getElementById('closeExportModal');
  
  const helpModal = document.getElementById('helpModal');
  const helpBtn = document.getElementById('helpBtn');
  const closeHelpModal = document.getElementById('closeHelpModal');
  
  const loadJSON = document.getElementById('loadJSON');
  const jsonFileInput = document.getElementById('jsonFileInput');
  
  const timelineContainer = document.getElementById('timelineContainer');
  const timelineRuler = document.getElementById('timelineRuler');
  const eventsTrack = document.getElementById('eventsTrack');
  const annotationsTrack = document.getElementById('annotationsTrack');
  const timelinePlayhead = document.getElementById('timelinePlayhead');
  
  // State
  let isAppLoaded = false;
  let apiReady = false;
  let isRecording = false;
  let isPaused = false;
  let isPlaying = false;
  let isPreviewingFromPaused = false;
  let recordingStartTime = null;
  let pauseStartTime = null;
  let totalPausedTime = 0;
  let currentTutorial = null;
  let eventListener = null;
  let playbackStartTime = null;
  let playbackPausedAt = 0;
  let currentAnnotationIndex = -1;
  let annotationTimeout = null;
  let editingAnnotationIndex = -1;
  let timelineScale = 50; // pixels per second
  let annotationBox = null; // Will be injected into iframe
  let annotationTitle = null;
  let annotationText = null;
  let activeRecordingAnnotation = null; // Track annotation that should remain visible during recording
  let importedDurationOffset = 0; // Offset to add to timestamps for imported tutorials
  
  // Playhead dragging state
  let isDraggingPlayhead = false;
  let playheadDragStartX = 0;
  let playheadDragStartLeft = 0;
  let playheadRepositionedTo = -1;
  
  // Calculate timeline start offset to remove blank space at beginning
  function getTimelineStartOffset() {
    if (!currentTutorial) return 0;
    
    if (currentTutorial.snapshots.length === 0 && currentTutorial.annotations.length === 0 && (!currentTutorial.pauses || currentTutorial.pauses.length === 0)) {
      return 0;
    }
    
    let firstEventTime = Infinity;
    
    if (currentTutorial.snapshots.length > 0) {
      firstEventTime = Math.min(firstEventTime, currentTutorial.snapshots[0].timestamp);
    }
    
    if (currentTutorial.annotations.length > 0) {
      const firstAnnotationTime = Math.min(...currentTutorial.annotations.map(ann => ann.timestamp));
      firstEventTime = Math.min(firstEventTime, firstAnnotationTime);
    }
    
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      const firstPauseTime = Math.min(...currentTutorial.pauses.map(p => p.timestamp));
      firstEventTime = Math.min(firstEventTime, firstPauseTime);
    }
    
    return (firstEventTime !== Infinity && firstEventTime > 0) ? firstEventTime : 0;
  }
  
  // Get tutorialAPI from iframe
  function getAPI() {
    if (!appFrame.contentWindow || !appFrame.contentWindow.tutorialAPI) {
      return null;
    }
    return appFrame.contentWindow.tutorialAPI;
  }
  
  // ========== APP LOADING ==========
  
  loadApp.addEventListener('click', () => {
    const url = appUrl.value.trim();
    if (!url) {
      alert('Please enter an app URL');
      return;
    }
    
    appFrame.src = url;
    loadApp.disabled = true;
    loadApp.textContent = 'Loading...';
  });
  
  appFrame.addEventListener('load', () => {
    console.log('Iframe loaded, checking for API...');
    
    // Poll for API availability
    const checkAPI = setInterval(() => {
      const api = getAPI();
      if (api) {
        clearInterval(checkAPI);
        apiReady = true;
        isAppLoaded = true;
        console.log('‚úì tutorialAPI ready');
        
        loadApp.style.display = 'none';
        loadApp.textContent = 'Load App'; // Reset text for next time
        appUrl.disabled = true;
        startRecording.style.display = 'inline-block';
        loadJSON.style.display = 'inline-block';
        
        // Inject annotation box into iframe
        injectAnnotationBox();
        
        // Show timeline
        timelineContainer.classList.add('visible');
        
        // Show playhead at position 0 (ready to start)
        timelinePlayhead.style.left = '60px'; // 60px for label offset
        timelinePlayhead.style.display = 'block';
      }
    }, 100);
    
    setTimeout(() => {
      if (!apiReady) {
        clearInterval(checkAPI);
        console.error('tutorialAPI not available after 5 seconds');
        alert('Error: This app does not have the tutorialAPI. Make sure you are loading the correct confidence demo app.');
        loadApp.disabled = false;
        loadApp.textContent = 'Load App';
      }
    }, 5000);
  });
  
  function injectAnnotationBox() {
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    if (!iframeDoc) return;
    
    annotationBox = iframeDoc.createElement('div');
    annotationBox.className = 'annotation-box';
    annotationBox.innerHTML = '<h3 id="annotationTitle"></h3><p id="annotationText"></p>';
    
    annotationTitle = annotationBox.querySelector('#annotationTitle');
    annotationText = annotationBox.querySelector('#annotationText');
    
    // Inject the CSS styles for annotation box
    const style = iframeDoc.createElement('style');
    style.textContent = `
      .annotation-box{
        position:absolute;
        width:250px;
        max-width:500px;
        background:rgba(255,255,255,0.98);
        border:3px solid #2563eb;
        border-radius:12px;
        padding:20px;
        box-shadow:0 8px 24px rgba(0,0,0,0.15);
        z-index:100;
        display:none;
        overflow-y:auto;
        overflow-x:hidden;
        box-sizing:border-box;
        font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
        font-size:15px;
        line-height:1.6;
      }
      .annotation-box.custom-position{max-width:none;}
      .annotation-box.draggable{
        cursor:move;
        box-shadow:0 8px 24px rgba(0,0,0,0.2);
        z-index:10001;
      }
      .annotation-box.visible{display:block;animation:slideIn 0.3s ease-out;}
      .annotation-box.draggable .resize-handle{
        position:absolute;
        bottom:0;
        right:0;
        width:16px;
        height:16px;
        background:rgba(37, 99, 235, 0.3);
        cursor:nwse-resize;
        border-top-left-radius:4px;
        border-bottom-right-radius:12px;
      }
      .annotation-box.draggable .resize-handle::after{
        content:'‚ã∞';
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%, -50%);
        color:rgba(37, 99, 235, 0.7);
        font-size:12px;
        line-height:1;
      }
      @keyframes slideIn{from{opacity:0;}to{opacity:1;}}
      .annotation-box h3{margin:0 0 12px;color:#2563eb;font-size:18px;line-height:1.3;}
      .annotation-box p{margin:0;line-height:inherit;font-size:inherit;}
    `;
    
    iframeDoc.head.appendChild(style);
    iframeDoc.body.appendChild(annotationBox);
    
    console.log('‚úì Annotation box injected into iframe');
  }
  
  // ========== RECORDING ==========
  
  startRecording.addEventListener('click', () => {
    if (!isRecording) {
      // Starting a new recording OR resuming from preview mode
      if (!apiReady) {
        alert('App not ready');
        return;
      }
      
      const api = getAPI();
      if (!api) {
        alert('App not ready');
        return;
      }
      
      // Check if playhead is positioned away from the end
      // This can happen in two scenarios:
      // 1. Dragged playhead during preview (playheadRepositionedTo >= 0)  
      // 2. Paused during playback preview (playbackPausedAt > 0)
      // 3. We have an existing tutorial from preview mode
      console.log('üéØ Record clicked - Debug values:');
      console.log('  playheadRepositionedTo:', playheadRepositionedTo);
      console.log('  playbackPausedAt:', playbackPausedAt);
      console.log('  currentTutorial exists:', !!currentTutorial);
      console.log('  isPreviewingFromPaused:', isPreviewingFromPaused);
      
      const hasExistingTutorial = !!currentTutorial;
      const isPlayheadRepositioned = (playheadRepositionedTo >= 0) || (playbackPausedAt > 0);
      console.log('  isPlayheadRepositioned:', isPlayheadRepositioned);
      
      if ((isPlayheadRepositioned || hasExistingTutorial) && currentTutorial) {
        // First click: Move playhead to end, change button text
        console.log('üéØ Record: Moving playhead to end of tutorial first');
        
        // Calculate end position
        const timelineStartOffset = getTimelineStartOffset();
        const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
        timelinePlayhead.style.left = timelineEndPosition + 'px';
        timelinePlayhead.style.display = 'block';
        
        // Reset position tracking
        playheadRepositionedTo = -1;
        playbackPausedAt = 0;
        
        // Replay to end state to update app visual state
        replayToTimestamp(currentTutorial.duration);
        
        // Set up for recording continuation (not new recording)
        isRecording = true;
        isPaused = true; // Start in paused state
        recordingStartTime = Date.now(); // Reset timing
        totalPausedTime = 0;
        pauseStartTime = Date.now();
        importedDurationOffset = currentTutorial.duration || 0; // Continue from where tutorial left off
        
        // Set up event listener for when recording resumes
        if (eventListener) {
          api.offAction(eventListener); // Remove old listener
        }
        eventListener = (event) => {
          if (isPaused) return;
          
          const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
          const snapshot = {
            timestamp: timestamp,
            event: event,
            state: api.getState()
          };
          currentTutorial.snapshots.push(snapshot);
          renderTimeline();
        };
        api.onAction(eventListener);
        
        console.log('üéØ Playhead moved to end - click Record again to start recording');
        return; // Exit early, don't start recording yet
      }
      
      // Initialize tutorial
      currentTutorial = {
        version: '9.32',
        appUrl: appUrl.value.trim(),
        initialState: api.getState(),
        snapshots: [],
        annotations: [],
        pauses: [],
        duration: 0,
        createdAt: new Date().toISOString()
      };
      
      isRecording = true;
      isPaused = false;
      recordingStartTime = Date.now();
      totalPausedTime = 0;
      importedDurationOffset = 0; // Reset offset for new recording
      
      // Start listening to events
      eventListener = (event) => {
        if (isPaused) return;
        
        // For simulate actions, we need to delay capturing the state slightly
        // because the simulation is asynchronous and the state isn't updated yet
        if (event.action === 'simulate') {
          setTimeout(() => {
            if (isPaused || !isRecording) return; // Don't capture if recording was paused/stopped
            
            // Capture timestamp NOW, when state is actually ready
            const captureTime = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
            
            const snapshot = {
              timestamp: captureTime,
              state: api.getState(),
              event: event
            };
            
            currentTutorial.snapshots.push(snapshot);
            console.log('üì∏ Simulate snapshot captured (delayed) at', (captureTime / 1000).toFixed(2) + 's', '- data.length:', snapshot.state.data.length);
          }, 50); // 50ms delay to allow simulation to complete
        } else {
          // For all other events, capture immediately
          const relativeTime = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
          
          const snapshot = {
            timestamp: relativeTime,
            state: api.getState(),
            event: event
          };
          
          currentTutorial.snapshots.push(snapshot);
          
          // Log drag-related events for debugging
          if (event.action.includes('drag') || event.action.includes('Drag')) {
            console.log('üì∏ Drag event captured at', (relativeTime / 1000).toFixed(2) + 's', '- Action:', event.action, 'Params:', event.params);
          }
          
          // Log other important events
          if (event.action === 'changeBeta' || event.action === 'changeN') {
            console.log('üì∏ Key snapshot captured at', (relativeTime / 1000).toFixed(2) + 's', '- Action:', event.action, 'Params:', event.params);
          }
        }
      };
      
      api.onAction(eventListener);
      
      // Update UI - button now shows Pause and blinks
      startRecording.textContent = '‚è∏ Pause';
      startRecording.classList.add('recording-active');
      startRecording.className = 'record recording-active'; // Keep red, add animation
      loadJSON.style.display = 'none'; // Hide Import Tutorial during recording
      playPauseRecording.style.display = 'none'; // Not used anymore
      addAnnotation.style.display = 'inline-block';
      addAnnotation.disabled = true; // Disabled during active recording
      addAnnotationAtPause.style.display = 'none';
      addPause.style.display = 'inline-block';
      addPause.disabled = true; // Disabled during active recording
      previewRecording.style.display = 'inline-block';
      previewRecording.disabled = true; // Disabled until paused
      recordingIndicator.style.display = 'none'; // Indicator not shown - button blinks instead
      pausedIndicator.style.display = 'none'; // Indicator not shown
      recordAgain.style.display = 'inline-block';
      recordAgain.disabled = true; // Disabled while actively recording
      exportRecording.style.display = 'inline-block';
      exportRecording.disabled = true; // Disabled while actively recording
      appUrl.disabled = true;
      
      console.log('üî¥ Recording started');
    } else if (isPaused) {
      // Resume recording
      
      // Check if we're resuming from a playback pause
      const isResumingFromPlaybackPause = (playbackPausedAt > 0 || isPlaying);
      
      // Ensure iframe is interactive (remove playback mode if it was left on)
      appFrame.classList.remove('playback-mode');
      appFrame.style.pointerEvents = 'auto';
      
      // Move playhead to end of tutorial before resuming
      if (currentTutorial) {
        const timelineStartOffset = getTimelineStartOffset();
        let timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
        
        // Add pixel adjustments based on final element type (using current timelineScale)
        if (currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          const action = lastSnapshot.event.action;
          const lastIsSingleEvent = !action.includes('End') && !action.includes('drag') && !action.includes('Drag');
          
          // Check if annotation or pause extends past last snapshot
          let snapshotIsLastElement = true;
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > lastSnapshot.timestamp) snapshotIsLastElement = false;
          }
          if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
            const lastPause = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
            if (lastPause > lastSnapshot.timestamp) snapshotIsLastElement = false;
          }
          
          // Add pixel adjustment for single events
          // Empirically determined: 50px needed
          if (lastIsSingleEvent && snapshotIsLastElement) {
            timelineEndPosition += 50;
          }
        }
        
        // Check if pause is the final element
        if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
          const lastPauseTime = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
          let pauseIsLastElement = true;
          
          if (currentTutorial.snapshots.length > 0) {
            const lastSnapshotTime = currentTutorial.snapshots[currentTutorial.snapshots.length - 1].timestamp;
            if (lastSnapshotTime > lastPauseTime) pauseIsLastElement = false;
          }
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > lastPauseTime) pauseIsLastElement = false;
          }
          
          // Add pixel adjustment for pause to reach center
          // Empirically determined: 26px needed
          if (pauseIsLastElement) {
            timelineEndPosition += 26;
          }
        }
        
        timelinePlayhead.style.left = timelineEndPosition + 'px';
        timelinePlayhead.style.display = 'block';
        
        // Apply the last snapshot's state so visual state matches the end
        const api = getAPI();
        if (api && currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          api.setState(lastSnapshot.state);
        }
        
        // Reset time calculations so new events start at current duration
        // This prevents gaps from preview time being added to timestamps
        recordingStartTime = Date.now();
        totalPausedTime = 0;
        importedDurationOffset = currentTutorial.duration;
      }
      
      // If preview is playing or was paused, stop it first
      if (isPlaying || playbackPausedAt > 0) {
        isPlaying = false;
        isPreviewingFromPaused = false;
        appFrame.classList.remove('playback-mode');
        appFrame.style.pointerEvents = 'auto';
        previewRecording.textContent = '‚ñ∂ Play';
        previewRecording.title = 'Play';
        previewRecording.classList.remove('playing');
        playbackPausedAt = 0; // Reset playback position
        
        // Apply the last snapshot's state if not already done above
        const api = getAPI();
        if (api && currentTutorial && currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          api.setState(lastSnapshot.state);
        }
      }
      
      // If resuming from playback pause, stay in paused state (don't immediately start recording)
      // This gives user a chance to see where recording will resume from
      if (isResumingFromPlaybackPause) {
        // Keep recording paused - user can click Record again to actually resume
        startRecording.textContent = '‚è∫ Record';
        startRecording.classList.remove('recording-active');
        startRecording.className = 'record';
        addAnnotation.disabled = false;
        addPause.disabled = false;
        previewRecording.disabled = false;
        recordAgain.disabled = false;
        exportRecording.disabled = false;
        
        console.log('‚è∏ Moved to end of timeline, ready to resume recording');
        return; // Exit without starting active recording
      }
      
      // Otherwise, resume active recording normally
      isPaused = false;
      
      startRecording.textContent = '‚è∏ Pause';
      startRecording.classList.add('recording-active');
      startRecording.className = 'record recording-active'; // Keep red, add animation
      addAnnotation.disabled = true;
      addAnnotationAtPause.style.display = 'none';
      addPause.disabled = true;
      previewRecording.disabled = true; // Disable when resuming
      recordAgain.disabled = true; // Disable Start Over when actively recording
      exportRecording.disabled = true; // Disable Export when actively recording
      
      // Hide timeline playhead when resuming active recording
      timelinePlayhead.style.display = 'none';
      
      console.log('‚ñ∂Ô∏è Recording resumed');
    } else {
      // Pause recording
      pauseStartTime = Date.now();
      isPaused = true;
      
      const pauseTimestamp = pauseStartTime - recordingStartTime - totalPausedTime;
      
      startRecording.textContent = '‚è∫ Record';
      startRecording.classList.remove('recording-active');
      startRecording.className = 'record'; // Keep red
      addAnnotation.disabled = false;
      addPause.disabled = false;
      previewRecording.disabled = false; // Enable when paused
      previewRecording.textContent = '‚ñ∂ Play';
      previewRecording.title = 'Play';
      recordAgain.disabled = false; // Enable Start Over when paused
      exportRecording.disabled = false; // Enable Export when paused
      
      // Calculate duration so preview works
      recalculateTutorialDuration();
      
      // Render timeline to show any events captured so far (including drags in progress)
      renderTimeline();
      
      // Position playhead at the end of the timeline
      if (currentTutorial) {
        const timelineStartOffset = getTimelineStartOffset();
        let timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
        
        // Add pixel adjustments based on final element type (using current timelineScale)
        if (currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          const action = lastSnapshot.event.action;
          const lastIsSingleEvent = !action.includes('End') && !action.includes('drag') && !action.includes('Drag');
          
          // Check if annotation or pause extends past last snapshot
          let snapshotIsLastElement = true;
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > lastSnapshot.timestamp) snapshotIsLastElement = false;
          }
          if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
            const lastPause = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
            if (lastPause > lastSnapshot.timestamp) snapshotIsLastElement = false;
          }
          
          // Add pixel adjustment for single events
          // Empirically determined: 50px needed
          if (lastIsSingleEvent && snapshotIsLastElement) {
            timelineEndPosition += 50;
          }
        }
        
        // Check if pause is the final element
        if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
          const lastPauseTime = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
          let pauseIsLastElement = true;
          
          if (currentTutorial.snapshots.length > 0) {
            const lastSnapshotTime = currentTutorial.snapshots[currentTutorial.snapshots.length - 1].timestamp;
            if (lastSnapshotTime > lastPauseTime) pauseIsLastElement = false;
          }
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > lastPauseTime) pauseIsLastElement = false;
          }
          
          // Add pixel adjustment for pause to reach center
          // Empirically determined: 26px needed
          if (pauseIsLastElement) {
            timelineEndPosition += 26;
          }
        }
        
        timelinePlayhead.style.left = timelineEndPosition + 'px';
        timelinePlayhead.style.display = 'block';
      }
      
      console.log('‚è∏ Recording paused at', (pauseTimestamp / 1000).toFixed(2) + 's');
    }
  });
  
  playPauseRecording.addEventListener('click', () => {
    if (!isRecording) return;
    
    if (isPaused) {
      // Resume recording
      
      // Ensure iframe is interactive (remove playback mode if it was left on)
      appFrame.classList.remove('playback-mode');
      
      // Move playhead to end of tutorial before resuming
      if (currentTutorial) {
        const timelineStartOffset = getTimelineStartOffset();
        let timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
        
        // Adjust playhead for single event endings to align with right edge of visual marker
        if (currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          const action = lastSnapshot.event.action;
          const lastIsSingleEvent = !action.includes('End') && !action.includes('drag') && !action.includes('Drag');
          
          // Check if annotation or pause extends past last snapshot
          let annotationExtendsPast = false;
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > lastSnapshot.timestamp) annotationExtendsPast = true;
          }
          if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
            const lastPause = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
            if (lastPause > lastSnapshot.timestamp) annotationExtendsPast = true;
          }
          
          // Add visual adjustment for single events
          if (lastIsSingleEvent && !annotationExtendsPast) {
            timelineEndPosition += 10; // Add 10px for better visual alignment with marker end
          }
        }
        
        timelinePlayhead.style.left = timelineEndPosition + 'px';
        timelinePlayhead.style.display = 'block';
        
        // Apply the last snapshot's state so visual state matches the end
        const api = getAPI();
        if (api && currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          api.setState(lastSnapshot.state);
        }
        
        // Reset time calculations so new events start at current duration
        // This prevents gaps from preview time being added to timestamps
        recordingStartTime = Date.now();
        totalPausedTime = 0;
        importedDurationOffset = currentTutorial.duration;
      }
      
      isPaused = false;
      
      playPauseRecording.textContent = '‚è∏ Pause';
      playPauseRecording.className = 'warning'; // Yellow for pause
      pausedIndicator.style.display = 'none';
      recordingIndicator.style.display = 'inline-block';
      addAnnotation.disabled = true;
      addAnnotationAtPause.style.display = 'none';
      addPause.disabled = true;
      previewRecording.disabled = true; // Disable when resuming
      recordAgain.disabled = true; // Disable Start Over when actively recording
      exportRecording.disabled = true; // Disable Export when actively recording
      
      // If preview is playing, stop it first
      if (isPlaying) {
        isPlaying = false;
        isPreviewingFromPaused = false;
        appFrame.classList.remove('playback-mode');
        previewRecording.textContent = '‚ñ∂ Play';
        
        // Apply current state from last snapshot
        const api = getAPI();
        if (api && currentTutorial && currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          api.setState(lastSnapshot.state);
        }
      }
      
      // If there's an active annotation, schedule it to hide after its duration
      if (activeRecordingAnnotation && annotationBox) {
        const remainingDuration = activeRecordingAnnotation.duration;
        console.log('‚ñ∂Ô∏è Recording resumed - annotation will hide in', (remainingDuration / 1000).toFixed(1) + 's');
        
        if (annotationTimeout) clearTimeout(annotationTimeout);
        annotationTimeout = setTimeout(() => {
          if (annotationBox) {
            annotationBox.classList.remove('visible');
            console.log('‚úì Annotation hidden after duration expired');
          }
          activeRecordingAnnotation = null;
        }, remainingDuration);
      } else {
        console.log('‚ñ∂Ô∏è Recording resumed');
      }
    } else {
      // Pause recording
      pauseStartTime = Date.now();
      isPaused = true;
      
      const pauseTimestamp = pauseStartTime - recordingStartTime - totalPausedTime;
      
      playPauseRecording.textContent = '‚è∫ Resume';
      playPauseRecording.className = 'success'; // Green for resume
      recordingIndicator.style.display = 'none';
      pausedIndicator.style.display = 'inline-block';
      addAnnotation.disabled = false;
      addPause.disabled = false;
      previewRecording.disabled = false; // Enable when paused
      previewRecording.textContent = '‚ñ∂ Play'; // Reset button text
      recordAgain.disabled = false; // Enable Start Over when paused
      exportRecording.disabled = false; // Enable Export when paused
      
      // Calculate duration so preview works
      recalculateTutorialDuration();
      
      // Render timeline to show any events captured so far (including drags in progress)
      renderTimeline();
      
      console.log('‚è∏ Recording paused at', (pauseTimestamp / 1000).toFixed(2) + 's');
    }
  });
  
  // Helper function to finalize recording (stop listening to events and calculate final duration)
  function finalizeRecording() {
    if (!isRecording) return;
    
    // If preview is playing, stop it first
    if (isPlaying && isPreviewingFromPaused) {
      isPlaying = false;
      isPreviewingFromPaused = false;
      appFrame.classList.remove('playback-mode');
      previewRecording.textContent = '‚ñ∂ Play';
    }
    
    const api = getAPI();
    if (api && eventListener) {
      api.offAction(eventListener);
    }
    
    // Calculate the actual end time of the tutorial
    let calculatedDuration = 0;
    
    console.log('‚èπ FINALIZING RECORDING - Duration Calculation:');
    console.log('  Total snapshots:', currentTutorial.snapshots.length);
    
    if (currentTutorial.snapshots.length > 0) {
      const lastSnapshotTime = currentTutorial.snapshots[currentTutorial.snapshots.length - 1].timestamp;
      const lastAction = currentTutorial.snapshots[currentTutorial.snapshots.length - 1].event.action;
      
      calculatedDuration = lastSnapshotTime;
      console.log('  Last snapshot time:', (lastSnapshotTime / 1000).toFixed(3) + 's');
      console.log('  Last snapshot action:', lastAction);
      
      // Check if last event is a single click event (not a drag)
      const isDragEnd = lastAction === 'dragEnd' || lastAction === 'dragBetaEnd' || 
                        lastAction === 'dragBetaPrimeEnd' || lastAction === 'dragBEnd' || 
                        lastAction === 'dragAxisEnd';
      
      if (!isDragEnd) {
        // For single events, add visual width so playhead stops at right edge of marker
        const visualWidthMs = (30 / timelineScale) * 1000;
        calculatedDuration = lastSnapshotTime + visualWidthMs;
        console.log('  Added visual width for single event:', visualWidthMs.toFixed(1) + 'ms');
        console.log('  Adjusted duration:', (calculatedDuration / 1000).toFixed(3) + 's');
      }
    }
    
    if (currentTutorial.annotations.length > 0) {
      const lastAnnotationEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
      console.log('  Last annotation ends at:', (lastAnnotationEnd / 1000).toFixed(3) + 's');
      calculatedDuration = Math.max(calculatedDuration, lastAnnotationEnd);
    }
    
    currentTutorial.duration = calculatedDuration;
    console.log('  Calculated duration:', (currentTutorial.duration / 1000).toFixed(3) + 's');
    
    // Clear any active annotation and timeout
    if (annotationTimeout) {
      clearTimeout(annotationTimeout);
      annotationTimeout = null;
    }
    if (annotationBox) {
      annotationBox.classList.remove('visible');
    }
    activeRecordingAnnotation = null;
    
    isRecording = false;
    isPaused = false;
    
    // Update UI
    playPauseRecording.style.display = 'none';
    addAnnotation.style.display = 'none';
    addPause.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    previewRecording.disabled = false;
    
    console.log('‚úì Recording finalized');
    renderTimeline();
  }
  
  // ========== ANNOTATIONS ==========
  
  addAnnotation.addEventListener('click', () => {
    if (!isPaused && playbackPausedAt === 0) return;
    
    // Determine timestamp based on context (priority order):
    // 1. If playhead was dragged while paused, use that position
    // 2. If paused during playback preview, use playback position
    // 3. Otherwise use end of tutorial (normal recording behavior)
    let timestamp;
    if (playheadRepositionedTo >= 0) {
      // Playhead was dragged to a specific position while paused
      timestamp = playheadRepositionedTo;
      console.log('üìù Creating annotation at dragged playhead position:', (timestamp / 1000).toFixed(2) + 's');
    } else if (playbackPausedAt > 0) {
      // Paused during playback - use current playback position
      timestamp = playbackPausedAt * 1000; // Convert seconds to milliseconds
      console.log('üìù Creating annotation at playback position:', (timestamp / 1000).toFixed(2) + 's');
    } else {
      // Normal paused recording - use end of tutorial
      timestamp = currentTutorial.duration || 0;
      console.log('üìù Creating annotation at end of tutorial:', (timestamp / 1000).toFixed(2) + 's');
    }
    
    // Check if there are existing annotations
    // If so, place this one after the last one to avoid overlap
    // BUT: respect intentional playhead positioning (don't auto-adjust when user dragged playhead)
    const isIntentionalPositioning = (playheadRepositionedTo >= 0) || (playbackPausedAt > 0);
    if (currentTutorial.annotations.length > 0 && !isIntentionalPositioning) {
      const lastAnn = currentTutorial.annotations[currentTutorial.annotations.length - 1];
      const lastAnnEnd = lastAnn.timestamp + lastAnn.duration;
      
      // If the new annotation would overlap, place it after the last one
      // (Only applies when adding at end of tutorial, not when user positioned playhead)
      if (timestamp < lastAnnEnd) {
        timestamp = lastAnnEnd;
        console.log('üìù Adjusted annotation timestamp to avoid overlap:', (timestamp / 1000).toFixed(2) + 's');
      }
    }
    
    // Create annotation with default text
    const annotation = {
      timestamp: timestamp,
      title: 'New Annotation',
      text: 'Double-click to edit this text',
      duration: 5000, // 5 seconds default
      position: null // Will be set after positioning
    };
    
    currentTutorial.annotations.push(annotation);
    
    // Store index for save handler
    editingAnnotationIndex = currentTutorial.annotations.length - 1;
    
    // Directly show annotation for positioning/editing
    showAnnotationForPositioning(annotation, editingAnnotationIndex);
  });
  
  addPause.addEventListener('click', () => {
    if (!isPaused && playbackPausedAt === 0) return;
    
    // Determine timestamp based on context (priority order):
    // 1. If playhead was dragged while paused, use that position
    // 2. If paused during playback preview, use playback position
    // 3. Otherwise use end of tutorial (normal recording behavior)
    let timestamp;
    if (playheadRepositionedTo >= 0) {
      // Playhead was dragged to a specific position while paused
      timestamp = playheadRepositionedTo;
      console.log('‚è∏ Creating pause at dragged playhead position:', (timestamp / 1000).toFixed(2) + 's');
    } else if (playbackPausedAt > 0) {
      // Paused during playback - use current playback position
      timestamp = playbackPausedAt * 1000; // Convert seconds to milliseconds
      console.log('‚è∏ Creating pause at playback position:', (timestamp / 1000).toFixed(2) + 's');
      console.log('  playbackPausedAt =', playbackPausedAt.toFixed(3), 's');
      console.log('  timestamp =', timestamp.toFixed(2), 'ms');
      
      // Debug: Where is the playhead right now?
      const currentPlayheadLeft = timelinePlayhead.style.left;
      console.log('  Current playhead position (CSS):', currentPlayheadLeft);
      
      // Get actual rendered position
      const playheadRect = timelinePlayhead.getBoundingClientRect();
      const containerRect = timelineContainer.getBoundingClientRect();
      console.log('  Current playhead position (rendered, container-relative):', (playheadRect.left - containerRect.left).toFixed(2), 'px');
      
      // Debug: Where will the pause be rendered?
      const timelineStartOffset = getTimelineStartOffset();
      const pauseTime = (timestamp - timelineStartOffset) / 1000;
      const pauseLeft = pauseTime * timelineScale;
      console.log('  timelineStartOffset =', (timelineStartOffset / 1000).toFixed(3), 's');
      console.log('  pauseTime (relative to timeline) =', pauseTime.toFixed(3), 's');
      console.log('  timelineScale =', timelineScale.toFixed(2), 'px/s');
      console.log('  pauseLeft (calculated) =', pauseLeft.toFixed(2), 'px');
      console.log('  pauseEl.style.left will be:', (pauseLeft - 6).toFixed(2), 'px (centered)');
    } else {
      // Normal paused recording - use end of tutorial
      timestamp = currentTutorial.duration || 0;
      console.log('‚è∏ Creating pause at end of tutorial:', (timestamp / 1000).toFixed(2) + 's');
    }
    
    // Create pause (just a timestamp)
    const pause = {
      timestamp: timestamp
    };
    
    currentTutorial.pauses.push(pause);
    
    // Recalculate duration and re-render timeline
    recalculateTutorialDuration();
    renderTimeline();
    
    // Debug: Check if playhead moved after re-rendering
    if (playbackPausedAt > 0) {
      setTimeout(() => {
        const playheadRect = timelinePlayhead.getBoundingClientRect();
        const containerRect = timelineContainer.getBoundingClientRect();
        const playheadAfter = playheadRect.left - containerRect.left;
        console.log('  üìç AFTER re-render: Playhead is now at:', playheadAfter.toFixed(2), 'px (container-relative)');
        console.log('  üìç Playhead CSS left:', timelinePlayhead.style.left);
      }, 0);
    }
  });
  
  createAnnotation.addEventListener('click', () => {
    const title = annTitle.value.trim();
    const text = annText.value.trim();
    const duration = parseFloat(annDuration.value) * 1000;
    
    if (!title || !text) {
      alert('Please enter both title and text');
      return;
    }
    
    // Use current tutorial duration as the timestamp (end of existing content)
    let timestamp = currentTutorial.duration || 0;
    
    // Check if there are existing annotations
    // If so, place this one after the last one to avoid overlap
    if (currentTutorial.annotations.length > 0) {
      const lastAnn = currentTutorial.annotations[currentTutorial.annotations.length - 1];
      const lastAnnEnd = lastAnn.timestamp + lastAnn.duration;
      
      // If the new annotation would overlap, place it after the last one
      if (timestamp < lastAnnEnd) {
        timestamp = lastAnnEnd;
        console.log('üìù Adjusted annotation timestamp to avoid overlap:', (timestamp / 1000).toFixed(2) + 's');
      }
    }
    
    console.log('üìù Creating annotation at timestamp:', (timestamp / 1000).toFixed(2) + 's');
    
    const annotation = {
      timestamp: timestamp,
      title: title,
      text: text,
      duration: duration,
      position: null // Will be set after positioning
    };
    
    currentTutorial.annotations.push(annotation);
    
    annotationEditorModal.classList.remove('visible');
    
    // Show annotation for positioning
    showAnnotationForPositioning(annotation, currentTutorial.annotations.length - 1);
  });
  
  cancelAnnotation.addEventListener('click', () => {
    annotationEditorModal.classList.remove('visible');
  });
  
  function showAnnotationForPositioning(ann, index) {
    if (!annotationBox) {
      console.error('showAnnotationForPositioning: annotationBox is null');
      return;
    }
    
    console.log('showAnnotationForPositioning called for:', ann.title);
    
    annotationBox.className = 'annotation-box visible draggable custom-position';
    annotationBox.style.position = 'absolute';
    
    // Annotation box is INSIDE the iframe, so use iframe-document coordinates
    annotationBox.style.left = '300px';
    annotationBox.style.top = '200px';
    annotationBox.style.width = '400px';
    annotationBox.style.height = 'auto';
    annotationBox.style.transform = 'none';
    annotationBox.style.zIndex = '10000';
    
    annotationTitle.innerHTML = ann.title;
    annotationText.innerHTML = ann.text;
    
    console.log('Annotation box styles set, display:', window.getComputedStyle(annotationBox).display);
    
    // Make title and text editable on double-click
    annotationTitle.ondblclick = (e) => {
      e.stopPropagation();
      console.log('üñ±Ô∏è Double-clicked title to edit');
      const currentText = annotationTitle.textContent;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentText;
      input.style.width = '100%';
      input.style.fontSize = '18px';
      input.style.fontWeight = 'bold';
      input.style.border = '2px solid var(--accent)';
      input.style.padding = '4px';
      input.style.borderRadius = '4px';
      
      annotationTitle.innerHTML = '';
      annotationTitle.appendChild(input);
      input.focus();
      
      // CRITICAL: Stop propagation to prevent annotation box drag handler from interfering
      input.addEventListener('mousedown', function(e) {
        console.log('  Title input mousedown - selectionStart:', this.selectionStart, 'selectionEnd:', this.selectionEnd);
        e.stopPropagation(); // Prevent drag handler from triggering
      });
      
      input.addEventListener('click', function(e) {
        console.log('  Title input click - selectionStart:', this.selectionStart, 'selectionEnd:', this.selectionEnd);
        e.stopPropagation(); // Prevent drag handler from triggering
      });
      
      const saveEdit = () => {
        console.log('  Saving title edit:', input.value);
        ann.title = input.value.trim() || currentText;
        annotationTitle.innerHTML = ann.title;
      };
      
      input.onblur = saveEdit;
      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          saveEdit();
        } else if (e.key === 'Escape') {
          annotationTitle.innerHTML = currentText;
        }
      };
    };
    
    annotationText.ondblclick = (e) => {
      e.stopPropagation();
      console.log('üñ±Ô∏è Double-clicked text to edit');
      const currentText = annotationText.textContent;
      const textarea = document.createElement('textarea');
      textarea.value = currentText;
      textarea.style.width = '100%';
      textarea.style.minHeight = '60px';
      textarea.style.fontSize = '15px';
      textarea.style.border = '2px solid var(--accent)';
      textarea.style.padding = '4px';
      textarea.style.borderRadius = '4px';
      textarea.style.fontFamily = 'inherit';
      
      annotationText.innerHTML = '';
      annotationText.appendChild(textarea);
      textarea.focus();
      
      // CRITICAL: Stop propagation to prevent annotation box drag handler from interfering
      textarea.addEventListener('mousedown', function(e) {
        console.log('  Text textarea mousedown - selectionStart:', this.selectionStart, 'selectionEnd:', this.selectionEnd);
        e.stopPropagation(); // Prevent drag handler from triggering
      });
      
      textarea.addEventListener('click', function(e) {
        console.log('  Text textarea click - selectionStart:', this.selectionStart, 'selectionEnd:', this.selectionEnd);
        e.stopPropagation(); // Prevent drag handler from triggering
      });
      
      const saveEdit = () => {
        console.log('  Saving text edit:', textarea.value);
        ann.text = textarea.value.trim() || currentText;
        annotationText.innerHTML = ann.text;
      };
      
      textarea.onblur = saveEdit;
      textarea.onkeydown = (e) => {
        if (e.key === 'Escape') {
          annotationText.innerHTML = currentText;
        }
        // Allow Enter for new lines, don't close on Enter
      };
    };
    
    // Add resize handle
    if (!annotationBox.querySelector('.resize-handle')) {
      const handle = document.createElement('div');
      handle.className = 'resize-handle';
      annotationBox.appendChild(handle);
      console.log('Resize handle added');
    }
    
    makeDraggable();
    positionEditorOverlay.style.display = 'block';
    
    // Override save handler
    savePosition.onclick = () => {
      // Use offsetLeft/offsetTop to get iframe-document coordinates
      console.log('üîç SAVE POSITION - About to save annotation position');
      console.log('  annotationBox.offsetLeft:', annotationBox.offsetLeft);
      console.log('  annotationBox.offsetTop:', annotationBox.offsetTop);
      console.log('  annotationBox.offsetWidth:', annotationBox.offsetWidth);
      console.log('  annotationBox.offsetHeight:', annotationBox.offsetHeight);
      console.log('  Iframe dimensions:', {
        offsetWidth: appFrame.offsetWidth,
        offsetHeight: appFrame.offsetHeight,
        clientWidth: appFrame.clientWidth,
        clientHeight: appFrame.clientHeight
      });
      
      ann.position = {
        left: annotationBox.offsetLeft,
        top: annotationBox.offsetTop,
        width: annotationBox.offsetWidth,
        height: annotationBox.offsetHeight
      };
      
      console.log('üîç SAVE POSITION - Final saved position object:', JSON.stringify(ann.position, null, 2));
      
      console.log('‚úì Annotation positioned (iframe-document coords):', ann.position);
      
      positionEditorOverlay.style.display = 'none';
      annotationBox.classList.remove('draggable'); // Remove draggable but keep visible
      
      const handles = annotationBox.querySelectorAll('.resize-handle');
      handles.forEach(h => h.remove());
      
      // Clear editing index
      editingAnnotationIndex = -1;
      
      // Keep annotation visible during recording
      // Store it so we can hide it when recording resumes and duration expires
      activeRecordingAnnotation = ann;
      
      console.log('  Annotation will remain visible until recording resumes and duration expires');
      
      // Recalculate duration in case annotation extends beyond current duration
      recalculateTutorialDuration();
      renderTimeline();
    };
  }
  
  cancelPosition.addEventListener('click', () => {
    // Remove the last annotation that wasn't positioned
    if (currentTutorial && currentTutorial.annotations.length > 0) {
      const lastAnn = currentTutorial.annotations[currentTutorial.annotations.length - 1];
      if (!lastAnn.position) {
        currentTutorial.annotations.pop();
      }
    }
    
    editingAnnotationIndex = -1;
    
    positionEditorOverlay.style.display = 'none';
    if (annotationBox) {
      annotationBox.classList.remove('visible', 'draggable');
      const handles = annotationBox.querySelectorAll('.resize-handle');
      handles.forEach(h => h.remove());
    }
  });
  
  deleteAnnotationFromOverlay.addEventListener('click', () => {
    if (editingAnnotationIndex >= 0 && currentTutorial && currentTutorial.annotations[editingAnnotationIndex]) {
      if (confirm('Delete this annotation?')) {
        currentTutorial.annotations.splice(editingAnnotationIndex, 1);
        editingAnnotationIndex = -1;
        
        positionEditorOverlay.style.display = 'none';
        if (annotationBox) {
          annotationBox.classList.remove('visible', 'draggable');
          const handles = annotationBox.querySelectorAll('.resize-handle');
          handles.forEach(h => h.remove());
        }
        
        recalculateTutorialDuration();
        renderTimeline();
      }
    }
  });
  
  // Event deletion modal handlers
  confirmEventDeletion.addEventListener('click', () => {
    if (!eventToDelete || !currentTutorial) return;
    
    console.log('üóëÔ∏è Deleting event:', eventToDelete);
    
    if (eventToDelete.endIdx !== null) {
      // Delete drag event (start and end, plus all intermediate events)
      // Delete from endIdx down to startIdx to maintain indices
      const startIdx = eventToDelete.startIdx;
      const endIdx = eventToDelete.endIdx;
      const numToDelete = endIdx - startIdx + 1;
      
      console.log(`  Deleting drag sequence: ${numToDelete} events from index ${startIdx} to ${endIdx}`);
      currentTutorial.snapshots.splice(startIdx, numToDelete);
      console.log(`  Deleted ${numToDelete} events for drag sequence`);
    } else {
      // Delete single event
      currentTutorial.snapshots.splice(eventToDelete.startIdx, 1);
      console.log(`  Deleted single event at index ${eventToDelete.startIdx}`);
    }
    
    eventDeletionModal.classList.remove('visible');
    eventToDelete = null;
    recalculateTutorialDuration();
    renderTimeline();
  });
  
  cancelEventDeletion.addEventListener('click', () => {
    eventDeletionModal.classList.remove('visible');
    eventToDelete = null;
  });
  
  eventDeletionModal.addEventListener('click', (e) => {
    if (e.target === eventDeletionModal) {
      eventDeletionModal.classList.remove('visible');
      eventToDelete = null;
    }
  });
  
  // Pause deletion modal handlers
  confirmPauseDeletion.addEventListener('click', () => {
    if (pauseToDelete === null || !currentTutorial) return;
    
    console.log('üóëÔ∏è Deleting pause at index:', pauseToDelete);
    currentTutorial.pauses.splice(pauseToDelete, 1);
    
    pauseDeletionModal.classList.remove('visible');
    pauseToDelete = null;
    recalculateTutorialDuration();
    renderTimeline();
  });
  
  cancelPauseDeletion.addEventListener('click', () => {
    pauseDeletionModal.classList.remove('visible');
    pauseToDelete = null;
  });
  
  pauseDeletionModal.addEventListener('click', (e) => {
    if (e.target === pauseDeletionModal) {
      pauseDeletionModal.classList.remove('visible');
      pauseToDelete = null;
    }
  });
  
  function makeDraggable() {
    if (!annotationBox) {
      console.error('makeDraggable: annotationBox is null');
      return;
    }
    
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    if (!iframeDoc) {
      console.error('makeDraggable: cannot get iframe document');
      return;
    }
    
    console.log('makeDraggable: Setting up drag handlers');
    
    // State variables
    let isDragging = false;
    let isResizing = false;
    let startX = 0;
    let startY = 0;
    let startWidth = 0;
    let startHeight = 0;
    let startLeft = 0;
    let startTop = 0;
    
    // Get the resize handle
    const handle = annotationBox.querySelector('.resize-handle');
    
    // Handle resize
    if (handle) {
      handle.onmousedown = function(e) {
        console.log('Resize handle mousedown');
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        startWidth = annotationBox.offsetWidth;
        startHeight = annotationBox.offsetHeight;
        e.stopPropagation();
        e.preventDefault();
      };
    }
    
    // Handle drag
    annotationBox.onmousedown = function(e) {
      if (e.target.classList.contains('resize-handle')) return;
      
      console.log('Annotation box mousedown');
      isDragging = true;
      
      // Get current position (use offsetLeft/offsetTop for iframe-document coordinates)
      startLeft = annotationBox.offsetLeft;
      startTop = annotationBox.offsetTop;
      startX = e.clientX;
      startY = e.clientY;
      
      e.preventDefault();
    };
    
    // Mouse move handler
    iframeDoc.onmousemove = function(e) {
      if (isDragging) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        annotationBox.style.transform = 'none';
        annotationBox.style.left = (startLeft + dx) + 'px';
        annotationBox.style.top = (startTop + dy) + 'px';
      } else if (isResizing) {
        const newWidth = startWidth + (e.clientX - startX);
        const newHeight = startHeight + (e.clientY - startY);
        annotationBox.style.width = Math.max(80, newWidth) + 'px';
        annotationBox.style.height = Math.max(40, newHeight) + 'px';
      }
    };
    
    // Mouse up handler
    iframeDoc.onmouseup = function() {
      if (isDragging || isResizing) {
        console.log('Mouse up - ending drag/resize');
      }
      isDragging = false;
      isResizing = false;
    };
    
    console.log('‚úì Drag handlers attached');
  }
  
  // ========== PREVIEW/PLAYBACK ==========
  
  previewRecording.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Toggle play/pause
    if (isPlaying) {
      pausePlayback();
    } else {
      // If playhead was repositioned, always start fresh from the new position
      // Otherwise resume if paused, or start from beginning
      if (playheadRepositionedTo >= 0) {
        startPlayback();
      } else if (playbackPausedAt > 0) {
        resumePlayback();
      } else {
        startPlayback();
      }
    }
  });
  
  // replayPreview button removed in v12.8
  // replayPreview.addEventListener('click', () => {
  //   if (!currentTutorial) return;
  //   
  //   // Stop if playing
  //   if (isPlaying) {
  //     stopPlayback();
  //   }
  //   
  //   // Reset pause position and start from beginning
  //   playbackPausedAt = 0;
  //   startPlayback();
  // });
  
  playPausePreview.addEventListener('click', () => {
    if (isPlaying) {
      pausePlayback();
    } else {
      resumePlayback();
    }
  });
  
  function startPlayback() {
    if (!currentTutorial) return;
    
    const api = getAPI();
    if (!api) return;
    
    // Detect if we're previewing from paused recording state
    isPreviewingFromPaused = isRecording && isPaused;
    
    // Don't hide recording controls - just add playback mode to iframe
    appFrame.classList.add('playback-mode');
    
    // Disable iframe interaction during playback
    appFrame.style.pointerEvents = 'none';
    
    // Update button states
    previewRecording.textContent = '|| Pause';
    previewRecording.title = 'Pause';
    previewRecording.classList.add('playing');
    replayPreview.style.display = 'none';
    addAnnotation.disabled = true;
    addPause.disabled = true;
    addAnnotationAtPause.style.display = 'none';
    // Keep recordAgain and exportRecording visible and enabled
    
    api.setState(currentTutorial.initialState);
    
    // Hide any visible annotation before starting
    if (annotationBox) {
      annotationBox.classList.remove('visible');
    }
    if (annotationTimeout) {
      clearTimeout(annotationTimeout);
      annotationTimeout = null;
    }
    currentAnnotationIndex = -1;
    
    isPlaying = true;
    
    // Start playback at the earliest timestamp (0, first annotation, or first snapshot)
    // UNLESS the playhead was repositioned while paused
    let startOffset = 0;
    
    if (playheadRepositionedTo >= 0) {
      // Playhead was repositioned - start from there
      startOffset = playheadRepositionedTo;
      playheadRepositionedTo = -1; // Reset after using
      console.log('‚ñ∂Ô∏è Starting playback from repositioned playhead at:', (startOffset / 1000).toFixed(2) + 's');
    } else {
      // Normal logic: Check if there are annotations before the first snapshot
      if (currentTutorial.annotations.length > 0) {
        const firstAnnTimestamp = Math.min(...currentTutorial.annotations.map(ann => ann.timestamp));
        if (currentTutorial.snapshots.length > 0) {
          const firstSnapshotTimestamp = currentTutorial.snapshots[0].timestamp;
          // Start at whichever comes first: annotation or snapshot
          startOffset = Math.min(firstAnnTimestamp, firstSnapshotTimestamp);
        } else {
          // No snapshots, just annotations
          startOffset = firstAnnTimestamp;
        }
        console.log('‚ñ∂Ô∏è Starting playback at first event:', (startOffset / 1000).toFixed(2) + 's');
      } else if (currentTutorial.snapshots.length > 0) {
        // No annotations, start at first snapshot
        startOffset = currentTutorial.snapshots[0].timestamp;
        console.log('‚ñ∂Ô∏è Starting playback at first event:', (startOffset / 1000).toFixed(2) + 's');
      }
      // If neither snapshots nor annotations exist, startOffset stays 0
    }
    
    playbackStartTime = Date.now() - startOffset;
    playbackPausedAt = 0;
    
    playPausePreview.textContent = '‚è∏ Pause Preview';
    
    requestAnimationFrame(playbackLoop);
    
    console.log('‚ñ∂Ô∏è Playback started');
  }
  
  function pausePlayback() {
    if (!isPlaying) return;
    
    isPlaying = false;
    playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
    
    // Enable iframe interaction when paused
    appFrame.style.pointerEvents = 'auto';
    
    previewRecording.textContent = '‚ñ∂ Play';
    previewRecording.title = 'Play';
    previewRecording.classList.remove('playing');
    playPausePreview.textContent = '‚ñ∂ Resume Preview';
    addAnnotation.disabled = false;
    addPause.disabled = false;
    addAnnotationAtPause.style.display = 'inline-block';
    // Keep all buttons visible
    
    console.log('‚è∏ Playback paused at', playbackPausedAt.toFixed(1) + 's');
  }
  
  function resumePlayback() {
    if (isPlaying) return;
    
    isPlaying = true;
    playbackStartTime = Date.now() - (playbackPausedAt * 1000);
    
    // Disable iframe interaction during playback
    appFrame.style.pointerEvents = 'none';
    
    previewRecording.textContent = '|| Pause';
    previewRecording.title = 'Pause';
    previewRecording.classList.add('playing');
    playPausePreview.textContent = '‚è∏ Pause Preview';
    addAnnotation.disabled = true;
    addPause.disabled = true;
    addAnnotationAtPause.style.display = 'none';
    // Keep recordAgain and exportRecording visible and enabled
    
    requestAnimationFrame(playbackLoop);
    
    console.log('‚ñ∂Ô∏è Playback resumed');
  }
  
  // addAnnotationAtPause button removed in v12.8
  // addAnnotationAtPause.addEventListener('click', () => {
  //   if (isPlaying) return; // Should only work when paused
  //   
  //   // Open annotation modal with timestamp set to current playback position
  //   const currentTime = playbackPausedAt * 1000; // Convert to ms
  //   
  //   annTitle.value = '';
  //   annText.value = '';
  //   annDuration.value = 5;
  //   annotationEditorModal.classList.add('visible');
  //   
  //   // Override the createAnnotation handler to use the paused time
  //   const originalHandler = createAnnotation.onclick;
  //   createAnnotation.onclick = () => {
  //     const title = annTitle.value.trim();
  //     const text = annText.value.trim();
  //     const duration = parseFloat(annDuration.value) * 1000;
  //     
  //     if (!title || !text) {
  //       alert('Please enter both title and text');
  //       return;
  //     }
  //     
  //     const annotation = {
  //       timestamp: currentTime,
  //       title: title,
  //       text: text,
  //       duration: duration,
  //       position: null
  //     };
  //     
  //     currentTutorial.annotations.push(annotation);
  //     
  //     annotationEditorModal.classList.remove('visible');
  //     
  //     // Show annotation for positioning
  //     showAnnotationForPositioning(annotation, currentTutorial.annotations.length - 1);
  //     
  //     // Restore original handler
  //     createAnnotation.onclick = originalHandler;
  //   };
  // });
  
  function playbackLoop() {
    if (!isPlaying || !currentTutorial) return;
    
    const api = getAPI();
    if (!api) {
      stopPlayback();
      return;
    }
    
    const elapsed = (Date.now() - playbackStartTime) / 1000;
    const elapsedMs = elapsed * 1000;
    
    // Update timeline playhead (adjusted for timeline start offset)
    const timelineStartOffset = getTimelineStartOffset();
    const timelineElapsed = (elapsedMs - timelineStartOffset) / 1000;
    const playheadLeft = timelineElapsed * timelineScale + 60;
    timelinePlayhead.style.display = 'block';
    timelinePlayhead.style.left = playheadLeft + 'px';
    
    // Find the most recent snapshot that should be active at this time
    let targetSnapshot = null;
    for (let i = currentTutorial.snapshots.length - 1; i >= 0; i--) {
      if (currentTutorial.snapshots[i].timestamp <= elapsedMs) {
        targetSnapshot = currentTutorial.snapshots[i];
        break;
      }
    }
    
    // Apply the most recent applicable snapshot BEFORE checking if finished
    if (targetSnapshot) {
      // Use a simple flag to avoid re-applying the same snapshot
      if (!playbackLoop.lastAppliedTimestamp || 
          targetSnapshot.timestamp !== playbackLoop.lastAppliedTimestamp) {
        api.setState(targetSnapshot.state);
        playbackLoop.lastAppliedTimestamp = targetSnapshot.timestamp;
        
        // Log important state changes
        if (targetSnapshot.event.action === 'simulate') {
          console.log('‚ñ∂Ô∏è Applying simulate event - data length:', targetSnapshot.state.data.length, 'currentN:', targetSnapshot.state.currentN);
        }
      }
    }
    
    // Handle annotations
    let annotationShowing = false;
    for (let i = 0; i < currentTutorial.annotations.length; i++) {
      const ann = currentTutorial.annotations[i];
      const annStart = ann.timestamp;
      const annEnd = ann.timestamp + ann.duration;
      
      // Check if annotation should be visible at current time
      if (elapsedMs >= annStart && elapsedMs <= annEnd) {
        annotationShowing = true;
        if (currentAnnotationIndex !== i) {
          console.log(`üìç Showing annotation "${ann.title}" at ${(elapsedMs / 1000).toFixed(2)}s (should be ${(annStart / 1000).toFixed(2)}s-${(annEnd / 1000).toFixed(2)}s)`);
          showAnnotation(ann);
          currentAnnotationIndex = i;
        }
        break;
      }
    }
    
    // Hide annotation if no longer in range
    if (!annotationShowing && currentAnnotationIndex >= 0) {
      if (annotationBox) {
        annotationBox.classList.remove('visible');
      }
      currentAnnotationIndex = -1;
    }
    
    // Check for pause events - track which have been triggered
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      // Initialize the Set if it doesn't exist
      if (!playbackLoop.triggeredPauses) {
        playbackLoop.triggeredPauses = new Set();
      }
      
      for (let i = 0; i < currentTutorial.pauses.length; i++) {
        const pause = currentTutorial.pauses[i];
        const pauseKey = `pause_${i}_${pause.timestamp}`;
        
        // Check if we've reached this pause and haven't triggered it yet
        if (elapsedMs >= pause.timestamp && !playbackLoop.triggeredPauses.has(pauseKey)) {
          playbackLoop.triggeredPauses.add(pauseKey);
          console.log('‚è∏ Pause reached at', (pause.timestamp / 1000).toFixed(2) + 's - pausing playback');
          
          // Position playhead at pause marker center (with same -6px offset as pause marker)
          const timelineStartOffset = getTimelineStartOffset();
          const pauseTimelinePosition = ((pause.timestamp - timelineStartOffset) / 1000) * timelineScale + 60;
          timelinePlayhead.style.left = (pauseTimelinePosition - 6) + 'px'; // Match pause marker centering
          console.log('üìç Positioned playhead at pause marker center:', (pauseTimelinePosition - 6) + 'px');
          
          // Check if this pause is the final element (no snapshots or annotations after it)
          let pauseIsFinalElement = true;
          
          if (currentTutorial.snapshots.length > 0) {
            const lastSnapshotTime = currentTutorial.snapshots[currentTutorial.snapshots.length - 1].timestamp;
            if (lastSnapshotTime > pause.timestamp) pauseIsFinalElement = false;
          }
          
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > pause.timestamp) pauseIsFinalElement = false;
          }
          
          // Check if there are other pauses after this one
          for (let j = i + 1; j < currentTutorial.pauses.length; j++) {
            if (currentTutorial.pauses[j].timestamp > pause.timestamp) {
              pauseIsFinalElement = false;
              break;
            }
          }
          
          if (pauseIsFinalElement) {
            // This is the final element - stop playback instead of pausing to avoid double-pause
            console.log('‚è∏ Pause is final element - stopping playback');
            stopPlayback();
          } else {
            // Pause in the middle - just pause naturally at the timestamp
            pausePlayback();
          }
          return;
        }
      }
    }
    
    // Check if finished AFTER applying all state/annotations/pauses
    // This ensures the last snapshot gets applied before stopping
    if (elapsedMs >= currentTutorial.duration) {
      console.log(`‚èπ Stopping playback: elapsed=${(elapsedMs / 1000).toFixed(3)}s duration=${(currentTutorial.duration / 1000).toFixed(3)}s`);
      stopPlayback();
      return;
    }
    
    requestAnimationFrame(playbackLoop);
  }
  
  function showAnnotation(ann) {
    console.log('üîç SHOW ANNOTATION (PLAYBACK) - Called with annotation:', JSON.stringify(ann, null, 2));
    
    if (!annotationBox) return;
    
    annotationTitle.innerHTML = ann.title;
    annotationText.innerHTML = ann.text;
    
    if (ann.position) {
      console.log('üîç SHOW ANNOTATION (PLAYBACK) - Setting position from saved data:');
      console.log('  ann.position.left:', ann.position.left);
      console.log('  ann.position.top:', ann.position.top);
      console.log('  ann.position.width:', ann.position.width);
      console.log('  ann.position.height:', ann.position.height);
      console.log('  Fixed iframe dimensions: 1000x800px - no scaling needed');
      
      annotationBox.className = 'annotation-box visible custom-position';
      
      // Annotation box is INSIDE the iframe, so use iframe-document coordinates directly
      annotationBox.style.left = ann.position.left + 'px';
      annotationBox.style.top = ann.position.top + 'px';
      annotationBox.style.width = ann.position.width + 'px';
      annotationBox.style.height = ann.position.height + 'px';
      annotationBox.style.transform = 'none';
      
      console.log('üîç SHOW ANNOTATION (PLAYBACK) - Applied styles:');
      console.log('  style.left:', annotationBox.style.left);
      console.log('  style.top:', annotationBox.style.top);
      console.log('  style.width:', annotationBox.style.width);
      console.log('  style.height:', annotationBox.style.height);
    }
    
    // Render MathJax
    if (window.MathJax && window.MathJax.typesetPromise) {
      window.MathJax.typesetPromise([annotationBox]).catch(err => console.error('MathJax error:', err));
    }
  }
  
  function stopPlayback() {
    isPlaying = false;
    playbackPausedAt = 0;
    
    // Save the preview context before resetting
    const wasPreviewingFromPaused = isPreviewingFromPaused;
    isPreviewingFromPaused = false;
    
    playbackLoop.lastAppliedTimestamp = null; // Reset the flag
    playbackLoop.triggeredPauses = null; // Reset triggered pauses for replay
    
    // Check if tutorial ends with an annotation (within 100ms tolerance)
    let tutorialEndsWithAnnotation = false;
    if (currentTutorial && currentTutorial.annotations.length > 0) {
      const lastAnn = currentTutorial.annotations[currentTutorial.annotations.length - 1];
      const annEnd = lastAnn.timestamp + lastAnn.duration;
      const tolerance = 100; // 100ms tolerance
      
      if (Math.abs(annEnd - currentTutorial.duration) < tolerance) {
        tutorialEndsWithAnnotation = true;
        // Show the last annotation
        showAnnotation(lastAnn);
        currentAnnotationIndex = currentTutorial.annotations.length - 1;
        console.log('‚úì Tutorial ends with annotation - keeping it visible');
      }
    }
    
    // Hide annotation only if tutorial doesn't end with one
    if (annotationBox && !tutorialEndsWithAnnotation) {
      annotationBox.classList.remove('visible');
      currentAnnotationIndex = -1;
    }
    
    if (annotationTimeout) {
      clearTimeout(annotationTimeout);
      annotationTimeout = null;
    }
    
    appFrame.classList.remove('playback-mode');
    
    // Restore iframe interaction
    appFrame.style.pointerEvents = 'auto';
    
    // If we were previewing from paused, just restore the preview button
    if (wasPreviewingFromPaused) {
      previewRecording.textContent = '‚ñ∂ Play';
      previewRecording.title = 'Play';
      previewRecording.classList.remove('playing');
      replayPreview.style.display = 'none';
      
      // Apply current state from last snapshot
      const api = getAPI();
      if (api && currentTutorial && currentTutorial.snapshots.length > 0) {
        const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
        api.setState(lastSnapshot.state);
      }
      
      // Restore paused recording button states
      addAnnotation.style.display = 'inline-block';
      addAnnotation.disabled = false;
      addPause.style.display = 'inline-block';
      addPause.disabled = false;
      addAnnotationAtPause.style.display = 'none';
      exportRecording.style.display = 'inline-block';
      recordAgain.style.display = 'inline-block';
      
      // Update pauseStartTime so preview time doesn't count as pause time
      pauseStartTime = Date.now();
      
      console.log('‚èπ Preview finished - returned to paused state');
    } else {
      // Was previewing from finished recording - show final state with playhead
      if (currentTutorial) {
        const timelineStartOffset = getTimelineStartOffset();
        let timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
        
        // Add pixel adjustments based on final element type (using current timelineScale)
        // This matches how annotations adjust width at render time
        if (currentTutorial.snapshots.length > 0) {
          const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
          const action = lastSnapshot.event.action;
          const lastIsSingleEvent = !action.includes('End') && !action.includes('drag') && !action.includes('Drag');
          
          // Check if annotation or pause extends past last snapshot
          let snapshotIsLastElement = true;
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > lastSnapshot.timestamp) snapshotIsLastElement = false;
          }
          if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
            const lastPause = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
            if (lastPause > lastSnapshot.timestamp) snapshotIsLastElement = false;
          }
          
          // Add pixel adjustment for single events to reach visual right edge
          // Empirically determined: 50px needed
          if (lastIsSingleEvent && snapshotIsLastElement) {
            timelineEndPosition += 50;
          }
        }
        
        // Check if pause is the final element
        if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
          const lastPauseTime = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
          let pauseIsLastElement = true;
          
          if (currentTutorial.snapshots.length > 0) {
            const lastSnapshotTime = currentTutorial.snapshots[currentTutorial.snapshots.length - 1].timestamp;
            if (lastSnapshotTime > lastPauseTime) pauseIsLastElement = false;
          }
          if (currentTutorial.annotations.length > 0) {
            const lastAnnEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
            if (lastAnnEnd > lastPauseTime) pauseIsLastElement = false;
          }
          
          // Add pixel adjustment for pause to reach visual center of diamond
          // Empirically determined: 26px needed
          if (pauseIsLastElement) {
            timelineEndPosition += 26;
          }
        }
        
        timelinePlayhead.style.left = timelineEndPosition + 'px';
        timelinePlayhead.style.display = 'block';
      }
      
      previewRecording.style.display = 'inline-block';
      previewRecording.textContent = '‚ñ∂ Play';
      previewRecording.title = 'Play';
      previewRecording.classList.remove('playing');
      playPausePreview.style.display = 'none';
      replayPreview.style.display = 'inline-block';
      addAnnotationAtPause.style.display = 'none';
      recordAgain.style.display = 'inline-block';
      exportRecording.style.display = 'inline-block';
      
      playPausePreview.textContent = '‚è∏ Pause Preview';
      
      // Apply final state
      const api = getAPI();
      if (api && currentTutorial && currentTutorial.snapshots.length > 0) {
        const finalSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
        api.setState(finalSnapshot.state);
      }
      
      console.log('‚èπ Playback stopped');
    }
  }
  
  recordAgain.addEventListener('click', () => {
    // Finalize recording if still in recording mode
    if (isRecording || isPaused) {
      finalizeRecording();
    }
    
    // Try to reset the app to initial state before clearing everything
    const api = getAPI();
    if (api && currentTutorial && currentTutorial.initialState) {
      console.log('Resetting app to initial state before clearing');
      try {
        api.setState(currentTutorial.initialState);
      } catch (e) {
        console.error('Error resetting state:', e);
      }
    }
    
    // Clear current tutorial
    currentTutorial = null;
    importedDurationOffset = 0; // Reset offset
    
    // Reset UI
    startRecording.style.display = 'inline-block';
    startRecording.textContent = '‚è∫ Record';
    startRecording.classList.remove('recording-active');
    startRecording.className = 'record';
    playPauseRecording.style.display = 'none';
    addAnnotation.style.display = 'none';
    addPause.style.display = 'none';
    previewRecording.style.display = 'none';
    previewRecording.disabled = true;
    playPausePreview.style.display = 'none';
    replayPreview.style.display = 'none';
    addAnnotationAtPause.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    
    // Hide these buttons - they should not appear
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
    loadJSON.style.display = 'inline-block';
    
    // Hide playhead
    timelinePlayhead.style.display = 'none';
    
    // Hide timeline container
    timelineContainer.classList.remove('visible');
    
    // Clear timeline
    renderTimeline();
    
    // Reload the iframe to start completely fresh
    const currentUrl = appFrame.src;
    if (currentUrl) {
      console.log('üîÑ Reloading app:', currentUrl);
      apiReady = false;
      isAppLoaded = false;
      
      // Force a complete reload by clearing src first, then setting it again
      appFrame.src = 'about:blank';
      setTimeout(() => {
        appFrame.src = currentUrl;
      }, 50);
    }
    
    console.log('üîÑ Starting over - tutorial cleared');
  });
  
  
  // ========== TIMELINE ==========
  
  function replayToTimestamp(timestamp) {
    // Replay all events from the beginning up to the given timestamp
    // This ensures proper context when editing annotations
    const api = getAPI();
    if (!api || !currentTutorial) return;
    
    // Start with initial state
    api.setState(currentTutorial.initialState);
    
    // Apply all snapshots up to the target timestamp in sequence
    for (let i = 0; i < currentTutorial.snapshots.length; i++) {
      const snapshot = currentTutorial.snapshots[i];
      if (snapshot.timestamp <= timestamp) {
        api.setState(snapshot.state);
      } else {
        break; // Past our target time, stop
      }
    }
    
    // Handle annotations - show any that should be visible at this timestamp
    let annotationShowing = false;
    for (let i = 0; i < currentTutorial.annotations.length; i++) {
      const ann = currentTutorial.annotations[i];
      const annStart = ann.timestamp;
      const annEnd = ann.timestamp + ann.duration;
      
      // Check if annotation should be visible at target time
      if (timestamp >= annStart && timestamp <= annEnd) {
        annotationShowing = true;
        console.log(`üìç Showing annotation "${ann.title}" at replayed timestamp ${(timestamp / 1000).toFixed(2)}s`);
        showAnnotation(ann);
        currentAnnotationIndex = i;
        break; // Only show one annotation at a time
      }
    }
    
    // Hide annotation if none should be visible
    if (!annotationShowing) {
      if (annotationBox) {
        annotationBox.classList.remove('visible');
      }
      currentAnnotationIndex = -1;
    }
    
    console.log('‚è≠Ô∏è Replayed events up to', (timestamp / 1000).toFixed(2) + 's');
  }
  
  function renderTimeline() {
    if (!currentTutorial) {
      timelineRuler.innerHTML = '';
      eventsTrack.innerHTML = '';
      annotationsTrack.innerHTML = '';
      return;
    }
    
    // Calculate timeline start offset (first event or annotation)
    const timelineStartOffset = getTimelineStartOffset();
    
    const duration = (currentTutorial.duration - timelineStartOffset) / 1000;
    
    // Calculate dynamic scale to fit timeline in available width
    // Account for the 60px label offset
    const containerWidth = timelineContainer.offsetWidth || 1200; // Fallback to 1200px
    const availableWidth = containerWidth - 80; // Leave some padding
    const minScale = 20; // Minimum pixels per second (very zoomed out)
    const maxScale = 100; // Maximum pixels per second (very zoomed in)
    
    // Calculate scale to fit duration in available width
    if (duration > 0) {
      const calculatedScale = availableWidth / duration;
      timelineScale = Math.max(minScale, Math.min(maxScale, calculatedScale));
    } else {
      timelineScale = 50; // Default for empty timeline
    }
    
    const timelineWidth = Math.max(duration * timelineScale, 200); // Minimum 200px
    
    console.log('üìä Timeline render - Duration:', duration.toFixed(2) + 's', 'Scale:', timelineScale.toFixed(1) + 'px/s', 'Snapshots:', currentTutorial.snapshots.length);
    
    if (currentTutorial.snapshots.length > 0) {
      const firstTime = (currentTutorial.snapshots[0].timestamp / 1000).toFixed(2);
      const lastTime = (currentTutorial.snapshots[currentTutorial.snapshots.length - 1].timestamp / 1000).toFixed(2);
      console.log('üìä First snapshot:', firstTime + 's', 'Last snapshot:', lastTime + 's');
    }
    
    // Set the width of timeline tracks
    timelineRuler.style.minWidth = timelineWidth + 'px';
    eventsTrack.parentElement.style.minWidth = timelineWidth + 'px';
    annotationsTrack.parentElement.style.minWidth = timelineWidth + 'px';
    
    // Render time ticks with adaptive interval
    timelineRuler.innerHTML = '';
    
    // Choose tick interval based on duration to avoid crowding
    let tickInterval = 1; // Default: every second
    if (duration > 60) tickInterval = 5;      // Over 1 min: every 5 seconds
    if (duration > 180) tickInterval = 10;    // Over 3 min: every 10 seconds
    if (duration > 600) tickInterval = 30;    // Over 10 min: every 30 seconds
    if (duration > 1800) tickInterval = 60;   // Over 30 min: every minute
    
    for (let t = 0; t <= duration; t += tickInterval) {
      const tick = document.createElement('div');
      tick.className = 'timeline-tick';
      tick.style.left = (t * timelineScale) + 'px';
      tick.textContent = t + 's';
      timelineRuler.appendChild(tick);
    }
    
    // Render event markers - group drag sequences (dragStart -> drag... -> dragEnd) into spans
    eventsTrack.innerHTML = '';
    
    console.log('üìä Rendering', currentTutorial.snapshots.length, 'snapshots to timeline');
    
    // Group events by drag sequences
    let i = 0;
    while (i < currentTutorial.snapshots.length) {
      const snapshot = currentTutorial.snapshots[i];
      const action = snapshot.event.action;
      
      // Check if this is the start of a drag sequence
      const isDragStart = action === 'dragStart' || action === 'dragBetaStart' || action === 'dragBetaPrimeStart' || 
                         action === 'dragBStart' || action === 'dragAxisStart';
      
      if (isDragStart) {
        // Find the corresponding dragEnd
        const dragType = action.replace('Start', ''); // e.g., 'drag', 'dragBeta', etc.
        const dragEndAction = dragType + 'End';
        
        let endIdx = i;
        // Look for the dragEnd event - only count drag-related snapshots
        let dragSnapshotCount = 1; // Count the dragStart
        for (let j = i + 1; j < currentTutorial.snapshots.length; j++) {
          const jAction = currentTutorial.snapshots[j].event.action;
          
          // Check if this snapshot is part of the drag sequence (drag-related action)
          const isDragRelated = jAction.includes('drag') || jAction.includes('Drag');
          
          if (jAction === dragEndAction) {
            endIdx = j;
            dragSnapshotCount++;
            break;
          } else if (isDragRelated) {
            dragSnapshotCount++;
          }
          // If it's not drag-related, we DON'T increment dragSnapshotCount
          // This means non-drag events inserted between dragStart and dragEnd won't be grouped
        }
        
        // Create a span from dragStart to dragEnd
        const startTime = (currentTutorial.snapshots[i].timestamp - timelineStartOffset) / 1000;
        const trueEndTime = (currentTutorial.snapshots[endIdx].timestamp - timelineStartOffset) / 1000;
        const trueDuration = trueEndTime - startTime;
        
        // Calculate visual end time (accounting for the 18px width reduction)
        const visualEndAdjustment = (18 / timelineScale); // in seconds
        const visualEndTime = trueEndTime - visualEndAdjustment;
        const visualDuration = visualEndTime - startTime;
        
        console.log('  üìç Grouped drag:', dragType, 'from', startTime.toFixed(2) + 's', 'to', visualEndTime.toFixed(2) + 's (visual)', `(${dragSnapshotCount} drag events)`);
        
        const span = document.createElement('div');
        span.className = 'timeline-event drag-event';
        span.style.left = (startTime * timelineScale) + 'px';
        span.style.width = Math.max(8, visualDuration * timelineScale) + 'px'; // Use visual duration directly
        span.title = `${dragType} (${startTime.toFixed(2)}s - ${visualEndTime.toFixed(2)}s) - Double-click to delete`;
        span.dataset.startIdx = i;
        span.dataset.endIdx = endIdx;
        
        // Double-click to delete
        span.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          e.preventDefault();
          const startIdx = parseInt(span.dataset.startIdx);
          const endIdx = parseInt(span.dataset.endIdx);
          console.log('üñ±Ô∏è Double-clicked drag event for deletion:', { startIdx, endIdx, dragType });
          console.log('  eventDeletionModal:', eventDeletionModal);
          console.log('  eventDeletionText:', eventDeletionText);
          
          eventToDelete = { startIdx, endIdx };
          eventDeletionText.textContent = `Delete "${dragType}" drag event (${startTime.toFixed(2)}s - ${visualEndTime.toFixed(2)}s)?`;
          eventDeletionModal.classList.add('visible');
          console.log('  Modal should now be visible');
        });
        
        // Make drag event draggable (will move start and end together)
        // Use dataset values to avoid closure issues with loop variable
        span.addEventListener('mousedown', (e) => {
          const startIdx = parseInt(span.dataset.startIdx);
          const endIdx = parseInt(span.dataset.endIdx);
          startEventDrag(e, startIdx, endIdx);
        });
        
        eventsTrack.appendChild(span);
        
        // Check for any non-drag events that fell between dragStart and dragEnd
        // These need to be rendered as separate single events
        for (let j = i + 1; j < endIdx; j++) {
          const jSnapshot = currentTutorial.snapshots[j];
          const jAction = jSnapshot.event.action;
          const isDragRelated = jAction.includes('drag') || jAction.includes('Drag');
          
          if (!isDragRelated) {
            // This is a non-drag event that fell within the drag's timestamp range
            // Render it as a single event marker
            const eventTime = (jSnapshot.timestamp - timelineStartOffset) / 1000;
            const eventLeft = eventTime * timelineScale;
            console.log(`  üìç Single event (within drag range): ${jAction} at ${eventTime.toFixed(3)}s, left=${eventLeft.toFixed(1)}px`);
            
            const marker = document.createElement('div');
            marker.className = 'timeline-event';
            marker.style.left = eventLeft + 'px';
            marker.title = jAction + ' at ' + eventTime.toFixed(2) + 's - Double-click to delete';
            marker.dataset.snapshotIdx = j;
            
            // Double-click to delete
            marker.addEventListener('dblclick', (e) => {
              e.stopPropagation();
              const snapshotIdx = parseInt(marker.dataset.snapshotIdx);
              console.log('üñ±Ô∏è Double-clicked single event for deletion:', { snapshotIdx, action: jAction });
              
              eventToDelete = { startIdx: snapshotIdx, endIdx: null };
              eventDeletionText.textContent = `Delete "${jAction}" event at ${eventTime.toFixed(2)}s?`;
              eventDeletionModal.classList.add('visible');
            });
            
            // Make event draggable - use dataset value to avoid closure issues
            marker.addEventListener('mousedown', (e) => {
              const snapshotIdx = parseInt(marker.dataset.snapshotIdx);
              startEventDrag(e, snapshotIdx, null);
            });
            
            eventsTrack.appendChild(marker);
          }
        }
        
        i = endIdx + 1; // Skip to after dragEnd
      } else if (action.includes('drag') || action.includes('Drag')) {
        // Skip intermediate drag events that weren't part of a Start/End sequence
        console.log('  ‚ö†Ô∏è Orphan drag event:', action, 'at', (snapshot.timestamp / 1000).toFixed(2) + 's');
        i++;
      } else {
        // Single event marker (simulate, changeBeta, etc.)
        const eventTime = (snapshot.timestamp - timelineStartOffset) / 1000;
        const eventLeft = eventTime * timelineScale;
        console.log(`  üìç Single event: ${action} at ${eventTime.toFixed(3)}s, left=${eventLeft.toFixed(1)}px (within track, absolute would be ${(eventLeft + 60).toFixed(1)}px)`);
        const marker = document.createElement('div');
        marker.className = 'timeline-event';
        marker.style.left = eventLeft + 'px';
        marker.title = action + ' at ' + eventTime.toFixed(2) + 's - Double-click to delete';
        marker.dataset.snapshotIdx = i;
        
        // Double-click to delete
        marker.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const snapshotIdx = parseInt(marker.dataset.snapshotIdx);
          console.log('üñ±Ô∏è Double-clicked single event for deletion:', { snapshotIdx, action });
          
          eventToDelete = { startIdx: snapshotIdx, endIdx: null };
          eventDeletionText.textContent = `Delete "${action}" event at ${eventTime.toFixed(2)}s?`;
          eventDeletionModal.classList.add('visible');
        });
        
        // Make event draggable - use dataset value to avoid closure issues
        marker.addEventListener('mousedown', (e) => {
          const snapshotIdx = parseInt(marker.dataset.snapshotIdx);
          startEventDrag(e, snapshotIdx, null);
        });
        
        eventsTrack.appendChild(marker);
        i++;
      }
    }
    
    // Render pauses (diamond markers on events track)
    if (currentTutorial.pauses) {
      currentTutorial.pauses.forEach((pause, i) => {
        const pauseTime = (pause.timestamp - timelineStartOffset) / 1000;
        const pauseLeft = pauseTime * timelineScale;
        
        const pauseEl = document.createElement('div');
        pauseEl.className = 'timeline-pause';
        pauseEl.style.left = (pauseLeft - 6) + 'px'; // Center the diamond (12px wide / 2 = 6px offset)
        pauseEl.title = `Pause at ${pauseTime.toFixed(2)}s - Double-click to delete`;
        pauseEl.dataset.pauseIdx = i;
        
        // Double-click to delete
        pauseEl.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const pauseIdx = parseInt(pauseEl.dataset.pauseIdx);
          console.log('üñ±Ô∏è Double-clicked pause for deletion:', { pauseIdx, pauseTime });
          
          pauseDeletionText.textContent = `Are you sure you want to delete pause at ${pauseTime.toFixed(2)}s?`;
          pauseToDelete = pauseIdx;
          pauseDeletionModal.classList.add('visible');
        });
        
        // Make pause draggable
        pauseEl.addEventListener('mousedown', (e) => {
          const pauseIdx = parseInt(pauseEl.dataset.pauseIdx);
          startPauseDrag(e, pauseIdx);
        });
        
        eventsTrack.appendChild(pauseEl);
        console.log(`  ‚è∏ Pause: left=${pauseLeft}px (${pauseTime.toFixed(2)}s)`);
        
        // Debug: Log actual rendered position
        setTimeout(() => {
          const rect = pauseEl.getBoundingClientRect();
          const trackRect = eventsTrack.getBoundingClientRect();
          const containerRect = timelineContainer.getBoundingClientRect();
          console.log(`  ‚è∏ Pause rendered: track-relative=${pauseEl.style.left}, screen-absolute=${rect.left}px, container-relative=${rect.left - containerRect.left}px`);
        }, 0);
      });
    }
    
    // Render annotations
    annotationsTrack.innerHTML = '';
    currentTutorial.annotations.forEach((ann, i) => {
      const annEl = document.createElement('div');
      annEl.className = 'timeline-annotation';
      const leftPos = ((ann.timestamp - timelineStartOffset) / 1000) * timelineScale;
      // Subtract padding + border + box-shadow + border-radius visual effects = 30px total
      const width = ((ann.duration / 1000) * timelineScale) - 30;
      annEl.style.left = leftPos + 'px';
      annEl.style.width = width + 'px';
      console.log(`  üìä Annotation "${ann.title}": left=${leftPos}px (${(ann.timestamp / 1000).toFixed(2)}s) width=${width}px (${(ann.duration / 1000).toFixed(2)}s) visual-end=${leftPos + width + 30}px (${((ann.timestamp + ann.duration) / 1000).toFixed(2)}s)`);
      annEl.textContent = ann.title;
      annEl.title = ann.title + ' (double-click to edit)';
      
      // Double-click to edit - directly show moveable/resizable box
      annEl.addEventListener('dblclick', () => {
        console.log('üñ±Ô∏è Double-clicked annotation in timeline, opening positioning overlay for index:', i);
        
        // Replay all events up to the annotation's timestamp so user can see context
        replayToTimestamp(ann.timestamp);
        
        // Move playhead to annotation timestamp
        const timelineStartOffset = getTimelineStartOffset();
        const timelinePosition = ((ann.timestamp - timelineStartOffset) / 1000) * timelineScale + 60;
        timelinePlayhead.style.left = timelinePosition + 'px';
        timelinePlayhead.style.display = 'block';
        
        // Store the editing index for the save handler
        editingAnnotationIndex = i;
        
        // Show the moveable/resizable box directly
        showAnnotationForPositioning(ann, i);
      });
      
      // Drag to move
      annEl.addEventListener('mousedown', (e) => startAnnotationDrag(e, i));
      
      // Resize edges
      const leftEdge = document.createElement('div');
      leftEdge.className = 'resize-edge left';
      leftEdge.addEventListener('mousedown', (e) => startAnnotationResize(e, i, 'left'));
      
      const rightEdge = document.createElement('div');
      rightEdge.className = 'resize-edge right';
      rightEdge.addEventListener('mousedown', (e) => startAnnotationResize(e, i, 'right'));
      
      annEl.appendChild(leftEdge);
      annEl.appendChild(rightEdge);
      
      annotationsTrack.appendChild(annEl);
    });
    
    // Set up event trimming handlers
    setupEventTrimming();
  }
  
  // ========== EVENT DRAGGING ==========
  
  let draggingEvent = null;
  
  function startEventDrag(e, startIdx, endIdx) {
    // endIdx is null for single events, or the end snapshot index for drag events
    const isDragEvent = endIdx !== null;
    
    console.log('üñ±Ô∏è startEventDrag called:', { startIdx, endIdx, isDragEvent });
    
    // Bounds check
    if (!currentTutorial || !currentTutorial.snapshots[startIdx]) {
      console.error('‚ùå Invalid startIdx:', startIdx);
      return;
    }
    if (isDragEvent && !currentTutorial.snapshots[endIdx]) {
      console.error('‚ùå Invalid endIdx:', endIdx);
      return;
    }
    
    // Store original timestamps for all snapshots in the drag sequence
    const originalTimestamps = {};
    if (isDragEvent) {
      for (let i = startIdx; i <= endIdx; i++) {
        originalTimestamps[i] = currentTutorial.snapshots[i].timestamp;
      }
    }
    
    draggingEvent = {
      startIdx: startIdx,
      endIdx: endIdx,
      isDragEvent: isDragEvent,
      startX: e.clientX,
      originalTimestamp: currentTutorial.snapshots[startIdx].timestamp,
      originalEndTimestamp: isDragEvent ? currentTutorial.snapshots[endIdx].timestamp : null,
      originalTimestamps: originalTimestamps, // Store all original timestamps
      hasMoved: false
    };
    
    document.addEventListener('mousemove', doEventDrag);
    document.addEventListener('mouseup', stopEventDrag);
    e.preventDefault();
    e.stopPropagation();
  }
  
  function doEventDrag(e) {
    if (!draggingEvent) return;
    
    draggingEvent.hasMoved = true;
    
    const dx = e.clientX - draggingEvent.startX;
    const dt = (dx / timelineScale) * 1000; // Convert pixels to ms
    
    let newTimestamp = Math.max(0, draggingEvent.originalTimestamp + dt);
    
    console.log('üìç doEventDrag: dx=' + dx + 'px, dt=' + dt + 'ms, newTimestamp=' + newTimestamp);
    
    // Minimum separation between events - constant 2px visual space regardless of scale
    // Convert 2 pixels to time based on current timelineScale
    // But enforce a minimum of 10ms to prevent floating point issues
    const MIN_SEPARATION = Math.max(10, (2 / timelineScale) * 1000); // At least 10ms or 2px in milliseconds
    console.log('  MIN_SEPARATION =', MIN_SEPARATION.toFixed(1), 'ms (2px at scale', timelineScale, 'px/s)');
    
    // Calculate the duration of the event being dragged
    let draggedEventDuration = 0;
    if (draggingEvent.isDragEvent) {
      draggedEventDuration = draggingEvent.originalEndTimestamp - draggingEvent.originalTimestamp;
    } else {
      // Single events have visual width (8px marker)
      draggedEventDuration = (8 / timelineScale) * 1000;
    }
    const draggedEventEnd = newTimestamp + draggedEventDuration;
    
    // Find all other events (excluding the one being dragged)
    // Build array of event ranges with CURRENT positions
    const otherEvents = [];
    let i = 0;
    while (i < currentTutorial.snapshots.length) {
      // Skip if this is part of the event being dragged
      if (draggingEvent.isDragEvent) {
        if (i >= draggingEvent.startIdx && i <= draggingEvent.endIdx) {
          i++;
          continue;
        }
      } else {
        if (i === draggingEvent.startIdx) {
          i++;
          continue;
        }
      }
      
      const snapshot = currentTutorial.snapshots[i];
      const action = snapshot.event.action;
      
      // Check if this is the start of a drag sequence
      const isDragStart = action === 'dragStart' || action === 'dragBetaStart' || action === 'dragBetaPrimeStart' || 
                         action === 'dragBStart' || action === 'dragAxisStart';
      
      if (isDragStart) {
        // Find the corresponding dragEnd
        const dragType = action.replace('Start', '');
        const dragEndAction = dragType + 'End';
        
        let endIdx = i;
        for (let j = i + 1; j < currentTutorial.snapshots.length; j++) {
          if (currentTutorial.snapshots[j].event.action === dragEndAction) {
            endIdx = j;
            break;
          }
        }
        
        // Drag events have -18px subtracted from their visual width (see renderTimeline)
        // So the visual end is 18 pixels before the endTime timestamp
        const visualEndAdjustment = (18 / timelineScale) * 1000; // 18px in ms
        const eventDuration = currentTutorial.snapshots[endIdx].timestamp - currentTutorial.snapshots[i].timestamp;
        
        otherEvents.push({
          startIdx: i,
          endIdx: endIdx,
          startTime: currentTutorial.snapshots[i].timestamp,
          endTime: currentTutorial.snapshots[endIdx].timestamp - visualEndAdjustment, // Visual end, not timestamp end
          duration: eventDuration,
          isDrag: true
        });
        
        i = endIdx + 1;
      } else if (!action.includes('drag') && !action.includes('Drag')) {
        // Single event (not a drag) - give it visual width for collision (8px marker)
        const visualWidth = (8 / timelineScale) * 1000; // 8px marker width in ms
        otherEvents.push({
          startIdx: i,
          endIdx: i,
          startTime: snapshot.timestamp,
          endTime: snapshot.timestamp + visualWidth,
          duration: visualWidth,
          isDrag: false
        });
        i++;
      } else {
        // Skip orphan drag events
        i++;
      }
    }
    
    // Check for collisions and implement pushing behavior with cascading
    let finalTimestamp = newTimestamp;
    const eventsPushed = [];
    const accumulatedPushes = new Map(); // Track total push amount for each event
    
    // Helper to get effective position of an event accounting for accumulated pushes
    const getEffectiveTime = (evt, isStart) => {
      const pushAmount = accumulatedPushes.get(evt.startIdx) || 0;
      return (isStart ? evt.startTime : evt.endTime) + pushAmount;
    };
    
    // Check if dragging forward (right)
    if (dt > 0) {
      // Find events that are ahead of where we're trying to move
      const nextEvents = otherEvents.filter(evt => evt.startTime >= draggingEvent.originalTimestamp);
      nextEvents.sort((a, b) => a.startTime - b.startTime);
      
      if (nextEvents.length > 0) {
        const nextEvent = nextEvents[0];
        
        // Check if our new position would overlap with next event (including MIN_SEPARATION)
        if (draggedEventEnd + MIN_SEPARATION > getEffectiveTime(nextEvent, true)) {
          // Calculate how much we're trying to push into the next event
          const overlap = draggedEventEnd + MIN_SEPARATION - getEffectiveTime(nextEvent, true);
          
          // Constrain our position to maintain MIN_SEPARATION from next event
          finalTimestamp = getEffectiveTime(nextEvent, true) - MIN_SEPARATION - draggedEventDuration;
          
          // Push the next event forward by the overlap amount
          eventsPushed.push({
            event: nextEvent,
            pushAmount: overlap
          });
          accumulatedPushes.set(nextEvent.startIdx, overlap);
          
          // Check for cascading collisions - if pushing nextEvent would cause it to hit another event
          const cascadeCheck = (pushedEvent, pushAmt) => {
            const pushedEventNewEnd = getEffectiveTime(pushedEvent, false);
            
            // Find the next event after the one being pushed
            const followingEvents = otherEvents.filter(evt => 
              evt.startIdx !== pushedEvent.startIdx && // Not the same event
              evt.startTime > pushedEvent.startTime // After the pushed event (in original position)
            );
            followingEvents.sort((a, b) => a.startTime - b.startTime);
            
            if (followingEvents.length > 0) {
              const followingEvent = followingEvents[0];
              
              // Check if the pushed event would now collide with the following event (using effective positions)
              if (pushedEventNewEnd + MIN_SEPARATION > getEffectiveTime(followingEvent, true)) {
                const cascadeOverlap = pushedEventNewEnd + MIN_SEPARATION - getEffectiveTime(followingEvent, true);
                
                // Add this event to the push list and track accumulated push
                eventsPushed.push({
                  event: followingEvent,
                  pushAmount: cascadeOverlap
                });
                const currentPush = accumulatedPushes.get(followingEvent.startIdx) || 0;
                accumulatedPushes.set(followingEvent.startIdx, currentPush + cascadeOverlap);
                
                console.log('‚è©‚è© Cascade push: event at idx', followingEvent.startIdx, 'needs push by', cascadeOverlap, 'ms (total:', (currentPush + cascadeOverlap), 'ms)');
                
                // Recursively check if this causes another collision
                cascadeCheck(followingEvent, cascadeOverlap);
              }
            }
          };
          
          cascadeCheck(nextEvent, overlap);
          
          console.log('‚è© Collision detected, pushing next event by', overlap, 'ms');
        }
      }
    }
    // Check if dragging backward (left)
    else if (dt < 0) {
      // Find events that are behind where we're trying to move
      const prevEvents = otherEvents.filter(evt => evt.endTime <= draggingEvent.originalTimestamp);
      prevEvents.sort((a, b) => b.endTime - a.endTime);
      
      console.log('üîç BACKWARD DRAG DEBUG:');
      console.log('  Dragging event idx', draggingEvent.startIdx, 'to', draggingEvent.endIdx);
      console.log('  Original timestamp:', draggingEvent.originalTimestamp.toFixed(2), 'ms');
      console.log('  New timestamp:', newTimestamp.toFixed(2), 'ms');
      console.log('  All otherEvents:');
      otherEvents.forEach(evt => {
        console.log('    idx', evt.startIdx, '-', evt.endIdx, ':', 
                    evt.isDrag ? 'DRAG' : 'CLICK',
                    'start=', evt.startTime.toFixed(2), 
                    'end=', evt.endTime.toFixed(2),
                    'duration=', evt.duration.toFixed(2));
      });
      
      if (prevEvents.length > 0) {
        const prevEvent = prevEvents[0];
        
        // Check if our new position would overlap with previous event (including MIN_SEPARATION)
        if (newTimestamp < getEffectiveTime(prevEvent, false) + MIN_SEPARATION) {
          // Calculate how much we're trying to push into the previous event
          const overlap = getEffectiveTime(prevEvent, false) + MIN_SEPARATION - newTimestamp;
          
          console.log('  Will collide with prev event idx', prevEvent.startIdx, 'overlap=', overlap.toFixed(2), 'ms');
          
          // Build the complete chain of events that need to be pushed
          const pushChain = [];
          
          // Helper function to build push chain recursively
          const buildPushChain = (pushedEvent, requiredPushAmount) => {
            pushChain.push({ event: pushedEvent, requestedPush: requiredPushAmount });
            console.log('    Chain: adding event idx', pushedEvent.startIdx, 'needs push by', requiredPushAmount.toFixed(2), 'ms');
            
            const pushedEventNewStart = pushedEvent.startTime - requiredPushAmount;
            
            // Find the preceding event
            const precedingEvents = otherEvents.filter(evt => 
              evt.startIdx !== pushedEvent.startIdx && 
              evt.endTime < pushedEvent.startTime
            );
            precedingEvents.sort((a, b) => b.endTime - a.endTime);
            
            if (precedingEvents.length > 0) {
              const precedingEvent = precedingEvents[0];
              
              // Check if pushed event would collide with preceding event
              if (pushedEventNewStart < precedingEvent.endTime + MIN_SEPARATION) {
                const cascadeOverlap = precedingEvent.endTime + MIN_SEPARATION - pushedEventNewStart;
                buildPushChain(precedingEvent, cascadeOverlap);
              }
            }
          };
          
          // Build the chain starting from prevEvent
          buildPushChain(prevEvent, overlap);
          
          console.log('  üìã Complete push chain:', pushChain.length, 'events');
          
          // Check if any event in the chain would go below MIN_SEPARATION
          // Find the leftmost event that would hit the wall
          let hitWall = false;
          let wallEvent = null;
          
          for (let i = pushChain.length - 1; i >= 0; i--) {
            const item = pushChain[i];
            const evt = item.event;
            const newStartTime = evt.startTime - item.requestedPush;
            
            console.log('    Check event idx', evt.startIdx, 'would move from', evt.startTime.toFixed(2), 
                       'to', newStartTime.toFixed(2), 'ms');
            
            if (newStartTime < MIN_SEPARATION) {
              hitWall = true;
              wallEvent = evt;
              console.log('üß± Hit wall at event idx', evt.startIdx, 'which cannot be pushed below', MIN_SEPARATION, 'ms');
              console.log('    Wall is', evt.isDrag ? 'DRAG event' : 'CLICK event');
              console.log('    Wall startTime:', evt.startTime.toFixed(2), 'ms');
              console.log('    Wall duration:', evt.duration.toFixed(2), 'ms');
              console.log('    Wall TRUE endTime:', (evt.startTime + evt.duration).toFixed(2), 'ms');
              console.log('    Wall visual endTime:', evt.endTime.toFixed(2), 'ms');
              break;
            }
          }
          
          if (hitWall) {
            // We hit a wall - need to recalculate positions
            // The wall event stays at its current position
            // All other events must be positioned to the right of it with proper spacing
            console.log('üîÑ Recalculating push chain from immovable wall event');
            
            // Clear the accumulated pushes and eventsPushed
            eventsPushed.length = 0;
            accumulatedPushes.clear();
            
            // Start positioning from the wall event (which doesn't move)
            // Wall event stays at its current position
            // Next event must start after the wall's VISUAL end (not TRUE end)
            // Use endTime which has visual adjustments already applied
            let currentPosition = wallEvent.endTime + MIN_SEPARATION;
            
            console.log('  Starting reposition from currentPosition:', currentPosition.toFixed(2), 'ms');
            console.log('    (wall VISUAL end:', wallEvent.endTime.toFixed(2), '+ MIN_SEPARATION:', MIN_SEPARATION.toFixed(2), ')');
            
            // Find wall event in the chain and process events after it (toward the right)
            const wallIndex = pushChain.findIndex(item => item.event.startIdx === wallEvent.startIdx);
            console.log('  Wall is at chain index', wallIndex, 'out of', pushChain.length, 'events');
            
            // Process events from wall toward the dragged event
            for (let i = wallIndex - 1; i >= 0; i--) {
              const item = pushChain[i];
              const evt = item.event;
              
              console.log('    Positioning event idx', evt.startIdx, '(', evt.isDrag ? 'DRAG' : 'CLICK', ')');
              console.log('      Original position:', evt.startTime.toFixed(2), 'ms');
              console.log('      New position:', currentPosition.toFixed(2), 'ms');
              console.log('      Duration:', evt.duration.toFixed(2), 'ms');
              
              // This event should start at currentPosition
              const pushAmount = currentPosition - evt.startTime;
              
              console.log('      Push amount:', pushAmount.toFixed(2), 'ms');
              
              if (Math.abs(pushAmount) > 0.001) {
                eventsPushed.push({
                  event: evt,
                  pushAmount: pushAmount
                });
                accumulatedPushes.set(evt.startIdx, pushAmount);
              }
              
              // Next event (to the right) must start after this one ends
              // Use the stored duration, not endTime - startTime (endTime has visual adjustments)
              currentPosition = currentPosition + evt.duration + MIN_SEPARATION;
              console.log('      Next event will start at:', currentPosition.toFixed(2), 'ms');
            }
            
            // The dragged event must be positioned after the last event
            finalTimestamp = currentPosition;
            
            console.log('‚úì Repositioned', (wallIndex), 'events from wall');
            console.log('  Wall event at idx', wallEvent.startIdx, 'stays at', wallEvent.startTime.toFixed(2), 'ms');
            console.log('  Dragged event will be at', finalTimestamp.toFixed(2), 'ms');
          } else {
            // Normal case - no wall hit, can push everything as planned
            finalTimestamp = getEffectiveTime(prevEvent, false) + MIN_SEPARATION;
            
            // Apply all pushes from the chain
            for (const item of pushChain.reverse()) {
              const evt = item.event;
              eventsPushed.push({
                event: evt,
                pushAmount: -item.requestedPush
              });
              accumulatedPushes.set(evt.startIdx, -item.requestedPush);
            }
            
            console.log('‚è™ Collision detected, pushing', pushChain.length, 'event(s)');
          }
        }
      }
    }
    
    // Apply the final timestamp to the dragged event
    if (draggingEvent.isDragEvent) {
      // For drag events, update ALL snapshots between start and end proportionally
      const originalDuration = draggingEvent.originalEndTimestamp - draggingEvent.originalTimestamp;
      
      console.log('üîß Updating drag sequence timestamps:');
      console.log('  Indices:', draggingEvent.startIdx, 'to', draggingEvent.endIdx);
      console.log('  Original duration:', originalDuration.toFixed(2), 'ms');
      console.log('  Final timestamp:', finalTimestamp.toFixed(2), 'ms');
      
      for (let i = draggingEvent.startIdx; i <= draggingEvent.endIdx; i++) {
        const originalTimestamp = draggingEvent.originalTimestamps[i];
        
        if (originalTimestamp === undefined) {
          console.error('‚ùå Missing originalTimestamp for index', i);
          console.error('   originalTimestamps:', draggingEvent.originalTimestamps);
          continue;
        }
        
        const relativePosition = originalDuration > 0 ? (originalTimestamp - draggingEvent.originalTimestamp) / originalDuration : 0;
        const newTimestamp = finalTimestamp + (relativePosition * originalDuration);
        const oldTimestamp = currentTutorial.snapshots[i].timestamp;
        
        currentTutorial.snapshots[i].timestamp = newTimestamp;
        console.log(`  Snapshot ${i}: ${oldTimestamp.toFixed(2)} -> ${newTimestamp.toFixed(2)} (rel: ${relativePosition.toFixed(3)})`);
      }
    } else {
      // For single events, just update the one snapshot
      currentTutorial.snapshots[draggingEvent.startIdx].timestamp = finalTimestamp;
    }
    
    // Apply pushing to other events
    console.log('üì¶ Applying', eventsPushed.length, 'pushes to other events:');
    for (const pushed of eventsPushed) {
      const evt = pushed.event;
      const pushAmount = pushed.pushAmount;
      
      console.log('  Event idx', evt.startIdx, '-', evt.endIdx, 'pushing by', pushAmount.toFixed(2), 'ms');
      
      // Push all snapshots in this event
      // No clamping needed - we already limited pushes to prevent going below MIN_SEPARATION
      for (let i = evt.startIdx; i <= evt.endIdx; i++) {
        const oldTime = currentTutorial.snapshots[i].timestamp;
        const newTime = oldTime + pushAmount;
        currentTutorial.snapshots[i].timestamp = newTime;
        console.log('    Snapshot', i, ':', oldTime.toFixed(2), '->', newTime.toFixed(2), 'ms');
      }
    }
    
    // Re-render to show the updated position
    renderTimeline();
  }
  
  // Repair broken drag sequences after sorting
  function repairDragSequences() {
    console.log('üîß Repairing drag sequences using sequenceId tags...');
    
    // Group snapshots by sequenceId
    const sequenceGroups = new Map();
    const nonSequenceSnapshots = [];
    
    for (let i = 0; i < currentTutorial.snapshots.length; i++) {
      const snapshot = currentTutorial.snapshots[i];
      
      if (snapshot.sequenceId !== undefined) {
        // This snapshot belongs to a sequence
        if (!sequenceGroups.has(snapshot.sequenceId)) {
          sequenceGroups.set(snapshot.sequenceId, []);
        }
        sequenceGroups.get(snapshot.sequenceId).push(snapshot);
      } else {
        // This snapshot is not part of a sequence
        nonSequenceSnapshots.push(snapshot);
      }
    }
    
    console.log(`  Found ${sequenceGroups.size} sequences and ${nonSequenceSnapshots.length} non-sequence events`);
    
    // Build array of sequences with their start times for sorting
    const sequences = [];
    for (const [sequenceId, snapshots] of sequenceGroups.entries()) {
      if (snapshots.length > 0) {
        sequences.push({
          sequenceId: sequenceId,
          startTime: snapshots[0].timestamp,
          snapshots: snapshots
        });
        console.log(`  Sequence ${sequenceId}: ${snapshots.length} events, start=${snapshots[0].timestamp.toFixed(0)}ms`);
      }
    }
    
    // Sort sequences by start time
    sequences.sort((a, b) => a.startTime - b.startTime);
    
    // Rebuild snapshots array: interleave sequences and non-sequence events by timestamp
    const newSnapshots = [];
    let seqIdx = 0;
    let nonSeqIdx = 0;
    
    while (seqIdx < sequences.length || nonSeqIdx < nonSequenceSnapshots.length) {
      const nextSeq = seqIdx < sequences.length ? sequences[seqIdx] : null;
      const nextNonSeq = nonSeqIdx < nonSequenceSnapshots.length ? nonSequenceSnapshots[nonSeqIdx] : null;
      
      if (!nextSeq) {
        newSnapshots.push(nextNonSeq);
        nonSeqIdx++;
      } else if (!nextNonSeq) {
        newSnapshots.push(...nextSeq.snapshots);
        seqIdx++;
      } else {
        // Add whichever comes first
        if (nextSeq.startTime <= nextNonSeq.timestamp) {
          newSnapshots.push(...nextSeq.snapshots);
          seqIdx++;
        } else {
          newSnapshots.push(nextNonSeq);
          nonSeqIdx++;
        }
      }
    }
    
    currentTutorial.snapshots = newSnapshots;
    console.log(`  ‚úì Rebuilt with ${currentTutorial.snapshots.length} snapshots (sequences preserved)`);
    
    // Clean up sequenceId tags after repair
    for (const snapshot of currentTutorial.snapshots) {
      delete snapshot.sequenceId;
    }
  }
  
  function stopEventDrag() {
    if (!draggingEvent) return;
    
    // Only do sorting and cleanup if user actually dragged
    if (!draggingEvent.hasMoved) {
      draggingEvent = null;
      document.removeEventListener('mousemove', doEventDrag);
      document.removeEventListener('mouseup', stopEventDrag);
      return;
    }
    
    // Tag all snapshots with sequenceId BEFORE sorting so we can reconstruct sequences after
    console.log('üè∑Ô∏è Tagging snapshots with sequenceId before sorting...');
    let nextSequenceId = 1;
    let i = 0;
    while (i < currentTutorial.snapshots.length) {
      const snapshot = currentTutorial.snapshots[i];
      const action = snapshot.event.action;
      
      // Check if this is a dragStart
      if (action.endsWith('Start')) {
        const dragType = action.slice(0, -5);
        const dragEndAction = dragType + 'End';
        
        // Find the matching dragEnd
        let endIdx = -1;
        for (let j = i + 1; j < currentTutorial.snapshots.length; j++) {
          if (currentTutorial.snapshots[j].event.action === dragEndAction) {
            endIdx = j;
            break;
          }
        }
        
        if (endIdx !== -1) {
          // Tag all snapshots in this sequence with the same sequenceId
          const currentSequenceId = nextSequenceId++;
          for (let k = i; k <= endIdx; k++) {
            const kAction = currentTutorial.snapshots[k].event.action;
            if (kAction.includes(dragType)) {
              currentTutorial.snapshots[k].sequenceId = currentSequenceId;
            }
          }
          console.log(`  Tagged ${dragType} sequence (idx ${i}-${endIdx}) with sequenceId ${currentSequenceId}`);
          i = endIdx + 1;
        } else {
          i++;
        }
      } else {
        // Non-sequence events don't get a sequenceId (or get their own unique one)
        i++;
      }
    }
    
    // Sort snapshots by timestamp to maintain proper order
    console.log('üì¶ Sorting snapshots...');
    console.log('  Before sort, first 5 timestamps:', currentTutorial.snapshots.slice(0, 5).map((s, idx) => `[${idx}]=${s.timestamp.toFixed(2)}`).join(', '));
    
    currentTutorial.snapshots.sort((a, b) => a.timestamp - b.timestamp);
    
    console.log('  After sort, first 5 timestamps:', currentTutorial.snapshots.slice(0, 5).map((s, idx) => `[${idx}]=${s.timestamp.toFixed(2)}`).join(', '));
    console.log('  After sort, last 5 timestamps:', currentTutorial.snapshots.slice(-5).map((s, idx) => `[${currentTutorial.snapshots.length - 5 + idx}]=${s.timestamp.toFixed(2)}`).join(', '));
    
    // Repair any broken drag sequences caused by sorting
    repairDragSequences();
    
    draggingEvent = null;
    document.removeEventListener('mousemove', doEventDrag);
    document.removeEventListener('mouseup', stopEventDrag);
    
    // Recalculate tutorial duration after moving
    recalculateTutorialDuration();
    renderTimeline();
    
    console.log('‚úì Event moved and snapshots re-sorted');
  }
  
  let draggingAnnotation = null;
  
  function startAnnotationDrag(e, index) {
    if (e.target.classList.contains('resize-edge')) return;
    
    draggingAnnotation = {
      index: index,
      startX: e.clientX,
      startTime: currentTutorial.annotations[index].timestamp,
      hasMoved: false  // Track if user actually dragged
    };
    
    document.addEventListener('mousemove', doAnnotationDrag);
    document.addEventListener('mouseup', stopAnnotationDrag);
    // Don't preventDefault here - let double-click work
  }
  
  function doAnnotationDrag(e) {
    if (!draggingAnnotation) return;
    
    const dx = e.clientX - draggingAnnotation.startX;
    
    // Only start dragging if moved more than 3 pixels
    if (!draggingAnnotation.hasMoved && Math.abs(dx) < 3) {
      return;
    }
    
    draggingAnnotation.hasMoved = true;
    
    const dt = (dx / timelineScale) * 1000;
    
    let newTime = Math.max(0, draggingAnnotation.startTime + dt);
    newTime = Math.min(newTime, currentTutorial.duration);
    
    currentTutorial.annotations[draggingAnnotation.index].timestamp = newTime;
    renderTimeline();
  }
  
  let resizingAnnotation = null;
  
  function startAnnotationResize(e, index, edge) {
    e.stopPropagation();
    
    resizingAnnotation = {
      index: index,
      edge: edge,
      startX: e.clientX,
      startTime: currentTutorial.annotations[index].timestamp,
      startDuration: currentTutorial.annotations[index].duration
    };
    
    document.addEventListener('mousemove', doAnnotationResize);
    document.addEventListener('mouseup', stopAnnotationResize);
    e.preventDefault();
  }
  
  function doAnnotationResize(e) {
    if (!resizingAnnotation) return;
    
    const dx = e.clientX - resizingAnnotation.startX;
    const dt = (dx / timelineScale) * 1000;
    
    const ann = currentTutorial.annotations[resizingAnnotation.index];
    
    if (resizingAnnotation.edge === 'left') {
      let newTime = Math.max(0, resizingAnnotation.startTime + dt);
      const diff = newTime - resizingAnnotation.startTime;
      let newDuration = resizingAnnotation.startDuration - diff;
      
      if (newDuration < 1000) {
        newDuration = 1000;
        newTime = resizingAnnotation.startTime + resizingAnnotation.startDuration - 1000;
      }
      
      ann.timestamp = newTime;
      ann.duration = newDuration;
    } else {
      let newDuration = Math.max(1000, resizingAnnotation.startDuration + dt);
      ann.duration = newDuration;
    }
    
    renderTimeline();
  }
  
  function stopAnnotationResize() {
    resizingAnnotation = null;
    document.removeEventListener('mousemove', doAnnotationResize);
    document.removeEventListener('mouseup', stopAnnotationResize);
    
    // Recalculate tutorial duration after resizing
    recalculateTutorialDuration();
  }
  
  // ========== PAUSE DRAGGING ==========
  
  let draggingPause = null;
  
  function startPauseDrag(e, index) {
    draggingPause = {
      index: index,
      startX: e.clientX,
      startTime: currentTutorial.pauses[index].timestamp,
      hasMoved: false
    };
    
    document.addEventListener('mousemove', doPauseDrag);
    document.addEventListener('mouseup', stopPauseDrag);
  }
  
  function doPauseDrag(e) {
    if (!draggingPause) return;
    
    const dx = e.clientX - draggingPause.startX;
    
    // Only start dragging if moved more than 3 pixels
    if (!draggingPause.hasMoved && Math.abs(dx) < 3) {
      return;
    }
    
    draggingPause.hasMoved = true;
    
    const dt = (dx / timelineScale) * 1000;
    
    let newTime = Math.max(0, draggingPause.startTime + dt);
    newTime = Math.min(newTime, currentTutorial.duration);
    
    currentTutorial.pauses[draggingPause.index].timestamp = newTime;
    renderTimeline();
  }
  
  function stopPauseDrag() {
    draggingPause = null;
    document.removeEventListener('mousemove', doPauseDrag);
    document.removeEventListener('mouseup', stopPauseDrag);
  }
  
  // ========== PLAYHEAD DRAGGING ==========
  
  function startPlayheadDrag(e) {
    if (!currentTutorial) return;
    
    // Only allow dragging while paused
    if (!isPaused) {
      console.log('üñ±Ô∏è Playhead dragging only allowed while paused');
      return;
    }
    
    console.log('üñ±Ô∏è Starting playhead drag while paused');
    isDraggingPlayhead = true;
    playheadDragStartX = e.clientX;
    playheadDragStartLeft = parseFloat(timelinePlayhead.style.left) || 60;
    
    // Add dragging class for visual feedback
    timelinePlayhead.classList.add('dragging');
    
    document.addEventListener('mousemove', doPlayheadDrag);
    document.addEventListener('mouseup', stopPlayheadDrag);
    e.preventDefault();
    e.stopPropagation();
  }
  
  function doPlayheadDrag(e) {
    if (!isDraggingPlayhead || !currentTutorial) return;
    
    const deltaX = e.clientX - playheadDragStartX;
    const newLeft = Math.max(60, playheadDragStartLeft + deltaX); // Minimum 60px (label offset)
    
    // Calculate corresponding timestamp
    const timelineStartOffset = getTimelineStartOffset();
    const timelinePosition = newLeft - 60; // Remove label offset
    const timeInSeconds = timelinePosition / timelineScale;
    const timestamp = (timeInSeconds * 1000) + timelineStartOffset;
    
    // Clamp to valid range
    const maxTimestamp = currentTutorial.duration;
    const clampedTimestamp = Math.max(0, Math.min(maxTimestamp, timestamp));
    const clampedLeft = ((clampedTimestamp - timelineStartOffset) / 1000) * timelineScale + 60;
    
    // Update playhead position
    timelinePlayhead.style.left = clampedLeft + 'px';
    
    console.log(`üéØ Dragging playhead to ${(clampedTimestamp / 1000).toFixed(2)}s`);
  }
  
  function stopPlayheadDrag(e) {
    if (!isDraggingPlayhead) return;
    
    // Remove dragging class
    timelinePlayhead.classList.remove('dragging');
    
    // Calculate final timestamp
    const newLeft = parseFloat(timelinePlayhead.style.left) || 60;
    const timelineStartOffset = getTimelineStartOffset();
    const timelinePosition = newLeft - 60;
    const timeInSeconds = timelinePosition / timelineScale;
    const timestamp = (timeInSeconds * 1000) + timelineStartOffset;
    
    // Store the repositioned timestamp for use by Play only
    playheadRepositionedTo = timestamp;
    
    console.log(`üéØ Playhead repositioned to ${(timestamp / 1000).toFixed(2)}s while paused`);
    
    // Replay to this timestamp to update visual state
    replayToTimestamp(timestamp);
    
    isDraggingPlayhead = false;
    document.removeEventListener('mousemove', doPlayheadDrag);
    document.removeEventListener('mouseup', stopPlayheadDrag);
  }
  
  // ========== EVENT TRIMMING ==========
  
  let trimmingEvent = null;
  
  // Set up event trimming listeners (called after rendering events)
  function setupEventTrimming() {
    const trimHandles = document.querySelectorAll('.event-trim-handle');
    trimHandles.forEach(handle => {
      handle.addEventListener('mousedown', startEventTrim);
    });
  }
  
  function startEventTrim(e) {
    e.stopPropagation();
    
    const handle = e.target;
    const eventSpan = handle.parentElement;
    const edge = handle.classList.contains('left') ? 'left' : 'right';
    const startIdx = parseInt(eventSpan.dataset.startIdx);
    const endIdx = parseInt(eventSpan.dataset.endIdx);
    
    trimmingEvent = {
      startIdx: startIdx,
      endIdx: endIdx,
      edge: edge,
      startX: e.clientX,
      originalStartTime: currentTutorial.snapshots[startIdx].timestamp,
      originalEndTime: currentTutorial.snapshots[endIdx].timestamp
    };
    
    document.addEventListener('mousemove', doEventTrim);
    document.addEventListener('mouseup', stopEventTrim);
    e.preventDefault();
  }
  
  function doEventTrim(e) {
    if (!trimmingEvent) return;
    
    const dx = e.clientX - trimmingEvent.startX;
    const dt = (dx / timelineScale) * 1000; // Convert pixels to ms
    
    // Store current mouse position for stopEventTrim
    trimmingEvent.currentX = e.clientX;
    
    if (trimmingEvent.edge === 'left') {
      // Trim from start: move start time forward
      const newStartTime = Math.max(
        trimmingEvent.originalStartTime + dt,
        trimmingEvent.originalStartTime // Can't go before original start
      );
      
      // Ensure we don't go past the end (leave at least 100ms)
      const maxStartTime = trimmingEvent.originalEndTime - 100;
      const clampedStartTime = Math.min(newStartTime, maxStartTime);
      
      // Find which snapshot index corresponds to the new start time
      let newStartIdx = trimmingEvent.startIdx;
      for (let i = trimmingEvent.startIdx; i <= trimmingEvent.endIdx; i++) {
        if (currentTutorial.snapshots[i].timestamp >= clampedStartTime) {
          newStartIdx = i;
          break;
        }
      }
      
      // Ensure at least 2 snapshots remain
      if (newStartIdx >= trimmingEvent.endIdx - 1) {
        newStartIdx = trimmingEvent.endIdx - 1;
      }
      
      // Store for stopEventTrim
      trimmingEvent.newStartIdx = newStartIdx;
      
      // Visual feedback: update the event span
      const eventSpan = document.querySelector(`.timeline-event[data-start-idx="${trimmingEvent.startIdx}"]`);
      if (eventSpan) {
        const newStartTimeSec = currentTutorial.snapshots[newStartIdx].timestamp / 1000;
        const endTimeSec = trimmingEvent.originalEndTime / 1000;
        const newWidth = Math.max(8, (endTimeSec - newStartTimeSec) * timelineScale - 18);
        eventSpan.style.left = (newStartTimeSec * timelineScale) + 'px';
        eventSpan.style.width = newWidth + 'px';
      }
    } else {
      // Trim from end: move end time backward
      const newEndTime = Math.min(
        trimmingEvent.originalEndTime + dt,
        trimmingEvent.originalEndTime // Can't go past original end
      );
      
      // Ensure we don't go before the start (leave at least 100ms)
      const minEndTime = trimmingEvent.originalStartTime + 100;
      const clampedEndTime = Math.max(newEndTime, minEndTime);
      
      // Find which snapshot index corresponds to the new end time
      let newEndIdx = trimmingEvent.endIdx;
      for (let i = trimmingEvent.endIdx; i >= trimmingEvent.startIdx; i--) {
        if (currentTutorial.snapshots[i].timestamp <= clampedEndTime) {
          newEndIdx = i;
          break;
        }
      }
      
      // Ensure at least 2 snapshots remain
      if (newEndIdx <= trimmingEvent.startIdx + 1) {
        newEndIdx = trimmingEvent.startIdx + 1;
      }
      
      // Store for stopEventTrim
      trimmingEvent.newEndIdx = newEndIdx;
      
      // Visual feedback: update the event span
      const eventSpan = document.querySelector(`.timeline-event[data-start-idx="${trimmingEvent.startIdx}"]`);
      if (eventSpan) {
        const startTimeSec = trimmingEvent.originalStartTime / 1000;
        const newEndTimeSec = currentTutorial.snapshots[newEndIdx].timestamp / 1000;
        const newWidth = Math.max(8, (newEndTimeSec - startTimeSec) * timelineScale - 18);
        eventSpan.style.width = newWidth + 'px';
      }
    }
  }
  
  function stopEventTrim() {
    if (!trimmingEvent) return;
    
    console.log('üî™ stopEventTrim called:', trimmingEvent);
    
    if (trimmingEvent.edge === 'left') {
      // Actually delete the trimmed snapshots from the start
      const newStartIdx = trimmingEvent.newStartIdx || trimmingEvent.startIdx;
      const deleteCount = newStartIdx - trimmingEvent.startIdx;
      
      console.log(`  Trimming from left: startIdx=${trimmingEvent.startIdx}, newStartIdx=${newStartIdx}, deleteCount=${deleteCount}`);
      
      if (deleteCount > 0) {
        currentTutorial.snapshots.splice(trimmingEvent.startIdx, deleteCount);
        console.log(`üî™ Trimmed ${deleteCount} snapshots from start`);
      }
    } else {
      // Actually delete the trimmed snapshots from the end
      const newEndIdx = trimmingEvent.newEndIdx || trimmingEvent.endIdx;
      const deleteCount = trimmingEvent.endIdx - newEndIdx;
      
      console.log(`  Trimming from right: endIdx=${trimmingEvent.endIdx}, newEndIdx=${newEndIdx}, deleteCount=${deleteCount}`);
      
      if (deleteCount > 0) {
        currentTutorial.snapshots.splice(newEndIdx + 1, deleteCount);
        console.log(`üî™ Trimmed ${deleteCount} snapshots from end`);
      }
    }
    
    trimmingEvent = null;
    document.removeEventListener('mousemove', doEventTrim);
    document.removeEventListener('mouseup', stopEventTrim);
    
    // Recalculate duration and re-render timeline
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  function stopAnnotationDrag() {
    if (!draggingAnnotation) return;
    
    // Only do overlap checking and re-rendering if user actually dragged
    if (!draggingAnnotation.hasMoved) {
      draggingAnnotation = null;
      document.removeEventListener('mousemove', doAnnotationDrag);
      document.removeEventListener('mouseup', stopAnnotationDrag);
      return;
    }
    
    const draggedIndex = draggingAnnotation.index;
    const draggedAnn = currentTutorial.annotations[draggedIndex];
    
    // Check for overlap with previous annotation (dragging right over left)
    if (draggedIndex > 0) {
      const prevAnn = currentTutorial.annotations[draggedIndex - 1];
      const prevEnd = prevAnn.timestamp + prevAnn.duration;
      
      if (draggedAnn.timestamp < prevEnd) {
        // Current annotation overlaps previous one
        // Shorten the previous annotation so it ends where current one starts
        const newPrevDuration = draggedAnn.timestamp - prevAnn.timestamp;
        if (newPrevDuration >= 1000) { // Minimum 1 second
          prevAnn.duration = newPrevDuration;
          console.log('‚ö†Ô∏è Shortened previous annotation to avoid overlap');
        } else {
          // If shortening would make it too small, push the dragged annotation forward instead
          draggedAnn.timestamp = prevAnn.timestamp + prevAnn.duration;
          console.log('‚ö†Ô∏è Moved annotation forward to avoid making previous one too short');
        }
      }
    }
    
    // Check for overlap with next annotation (dragging left over right)
    if (draggedIndex < currentTutorial.annotations.length - 1) {
      const nextAnn = currentTutorial.annotations[draggedIndex + 1];
      const draggedEnd = draggedAnn.timestamp + draggedAnn.duration;
      
      if (draggedEnd > nextAnn.timestamp) {
        // Dragged annotation overlaps next one
        // Move the next annotation to start where dragged one ends
        nextAnn.timestamp = draggedEnd;
        console.log('‚ö†Ô∏è Moved next annotation forward to avoid overlap');
      }
    }
    
    draggingAnnotation = null;
    document.removeEventListener('mousemove', doAnnotationDrag);
    document.removeEventListener('mouseup', stopAnnotationDrag);
    
    // Recalculate tutorial duration after moving
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  // Recalculate tutorial duration based on snapshots and annotations
  function recalculateTutorialDuration() {
    if (!currentTutorial) return;
    
    // Get last snapshot time
    let lastSnapshotTime = 0;
    let lastSnapshotIsSingleEvent = false;
    if (currentTutorial.snapshots.length > 0) {
      const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
      lastSnapshotTime = lastSnapshot.timestamp;
      
      // Check if last snapshot is a single event (not dragEnd)
      const action = lastSnapshot.event.action;
      lastSnapshotIsSingleEvent = !action.includes('End') && !action.includes('drag') && !action.includes('Drag');
    }
    
    // Get last annotation end time
    let lastAnnotationEnd = 0;
    if (currentTutorial.annotations.length > 0) {
      lastAnnotationEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
    }
    
    // Get last pause time
    let lastPauseTime = 0;
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      lastPauseTime = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
    }
    
    // Determine which element is chronologically last
    let calculatedDuration = 0;
    let durationSource = 'none';
    let lastElementType = 'none';
    
    const maxTime = Math.max(lastSnapshotTime, lastAnnotationEnd, lastPauseTime);
    
    if (maxTime === 0) {
      calculatedDuration = 0;
      durationSource = 'none';
      lastElementType = 'none';
    } else if (maxTime === lastPauseTime && lastPauseTime > 0) {
      // Pause is chronologically last
      calculatedDuration = lastPauseTime;
      durationSource = 'pause';
      lastElementType = 'pause';
    } else if (maxTime === lastAnnotationEnd) {
      // Annotation extends furthest
      calculatedDuration = lastAnnotationEnd;
      durationSource = 'annotation';
      lastElementType = 'annotation';
    } else {
      // Snapshot is last
      calculatedDuration = lastSnapshotTime;
      durationSource = 'snapshot';
      lastElementType = lastSnapshotIsSingleEvent ? 'singleEvent' : 'dragEvent';
    }
    
    // Add pixel-based buffers for visual alignment
    // Must iterate because adding buffer changes scale, which changes buffer amount
    // Only add buffer for click events (single events), NOT for pauses
    if (lastElementType === 'singleEvent') {
      const containerWidth = timelineContainer.offsetWidth || 1200;
      const availableWidth = containerWidth - 80;
      const minScale = 20;
      const maxScale = 100;
      
      // Iterate to find stable buffer (scale depends on duration, buffer depends on scale)
      let iterDuration = calculatedDuration;
      let iterScale = 50; // Initial guess
      for (let iteration = 0; iteration < 5; iteration++) {
        // Calculate what scale will be for this duration
        const durationSeconds = (iterDuration - getTimelineStartOffset()) / 1000;
        if (durationSeconds > 0) {
          const calculatedScale = availableWidth / durationSeconds;
          iterScale = Math.max(minScale, Math.min(maxScale, calculatedScale));
        }
        
        // Calculate buffer using this scale
        let bufferPixels = 26; // Click events only - empirically calibrated
        
        const bufferMs = (bufferPixels / iterScale) * 1000;
        const newDuration = calculatedDuration + bufferMs;
        
        // Check convergence
        if (Math.abs(newDuration - iterDuration) < 1) {
          iterDuration = newDuration;
          break;
        }
        
        iterDuration = newDuration;
      }
      
      calculatedDuration = iterDuration;
      console.log('üìä Added buffer for', lastElementType, ':', ((calculatedDuration - lastSnapshotTime) / 1000).toFixed(3) + 's');
    }
    
    currentTutorial.duration = calculatedDuration;
    console.log('üìä Duration recalculated:', (calculatedDuration / 1000).toFixed(2) + 's');
    console.log('  Last snapshot:', (lastSnapshotTime / 1000).toFixed(2) + 's');
    console.log('  Last annotation end:', (lastAnnotationEnd / 1000).toFixed(2) + 's');
    console.log('  Last pause:', (lastPauseTime / 1000).toFixed(2) + 's');
    console.log('  Duration determined by:', durationSource);
  }
  
  // ========== ANNOTATION EDITING ==========
  
  // ========== EXPORT/IMPORT ==========
  
  exportRecording.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Don't finalize - just export the current state
    // User can continue recording after exporting
    
    snapshotCount.textContent = currentTutorial.snapshots.length;
    annotationCount.textContent = currentTutorial.annotations.length;
    exportTextarea.value = JSON.stringify(currentTutorial, null, 2);
    exportModal.classList.add('visible');
  });
  
  downloadExport.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    const jsonStr = JSON.stringify(currentTutorial, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tutorial-' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    downloadExport.textContent = '‚úì Downloaded!';
    setTimeout(() => {
      downloadExport.textContent = 'üíæ Download JSON';
    }, 2000);
  });
  
  copyExport.addEventListener('click', () => {
    exportTextarea.select();
    document.execCommand('copy');
    copyExport.textContent = '‚úì Copied!';
    setTimeout(() => {
      copyExport.textContent = 'üìã Copy to Clipboard';
    }, 2000);
  });
  
  closeExportModal.addEventListener('click', () => {
    exportModal.classList.remove('visible');
  });
  
  loadJSON.addEventListener('click', () => {
    jsonFileInput.click();
  });
  
  jsonFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const imported = JSON.parse(event.target.result);
        
        if (!imported.initialState || !imported.snapshots || !imported.annotations) {
          throw new Error('Invalid tutorial format');
        }
        
        // Backward compatibility: add pauses array if it doesn't exist
        if (!imported.pauses) {
          imported.pauses = [];
        }
        
        currentTutorial = imported;
        
        console.log('üì§ Tutorial imported successfully');
        console.log('  Snapshots:', currentTutorial.snapshots.length);
        console.log('  Annotations:', currentTutorial.annotations.length);
        console.log('  Pauses:', currentTutorial.pauses ? currentTutorial.pauses.length : 0);
        if (currentTutorial.annotations.length > 0) {
          console.log('  Annotation details:', currentTutorial.annotations.map(a => 
            `"${a.title}" at ${a.timestamp}ms for ${a.duration}ms`
          ));
        }
        
        // Load the app if not already loaded
        if (!isAppLoaded && imported.initialState) {
          // We can't auto-load without a URL, so just inform user
          alert('Tutorial loaded! Please load the app first using "Load App", then the tutorial will be ready to edit.');
        } else if (isAppLoaded) {
          const api = getAPI();
          if (api) {
            // Apply the last snapshot's state instead of initial state
            // This shows the final state with all settings that were active at the end
            if (currentTutorial.snapshots.length > 0) {
              const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
              api.setState(lastSnapshot.state);
            } else {
              api.setState(currentTutorial.initialState);
            }
          }
          
          // Set up recording state as if we just paused
          isRecording = true;
          isPaused = true;
          recordingStartTime = Date.now(); // Start recording from NOW
          pauseStartTime = Date.now(); // Set pause start time for correct resume calculation
          totalPausedTime = 0;
          importedDurationOffset = currentTutorial.duration || 0; // Offset new events by imported duration
          
          // Set up event listener (so we can continue recording)
          eventListener = (event) => {
            const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
            const snapshot = {
              timestamp: timestamp,
              event: event,
              state: api.getState()
            };
            currentTutorial.snapshots.push(snapshot);
            renderTimeline();
          };
          api.onAction(eventListener);
          
          // Show paused recording UI
          startRecording.style.display = 'inline-block';
          startRecording.textContent = '‚è∫ Record';
          startRecording.classList.remove('recording-active');
          startRecording.className = 'record';
          loadJSON.style.display = 'none';
          playPauseRecording.style.display = 'none';
          recordingIndicator.style.display = 'none';
          pausedIndicator.style.display = 'none';
          addAnnotation.style.display = 'inline-block';
          addAnnotation.disabled = false;
          addAnnotationAtPause.style.display = 'none';
          addPause.style.display = 'inline-block';
          addPause.disabled = false;
          previewRecording.style.display = 'inline-block';
          previewRecording.disabled = false;
          recordAgain.style.display = 'inline-block';
          recordAgain.disabled = false;
          exportRecording.style.display = 'inline-block';
          exportRecording.disabled = false;
          
          renderTimeline();
          
          // Position playhead at the end of the imported tutorial
          const timelineStartOffset = getTimelineStartOffset();
          const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
          timelinePlayhead.style.left = timelineEndPosition + 'px';
          timelinePlayhead.style.display = 'block';
          
          alert('‚úì Tutorial loaded!\n\nYou can now:\n‚Ä¢ Preview it\n‚Ä¢ Resume recording to add more\n‚Ä¢ Add/edit annotations\n‚Ä¢ Export when done');
        }
        
        console.log('üì§ Tutorial imported');
      } catch (err) {
        alert('Error importing tutorial: ' + err.message);
        console.error('Import error:', err);
      }
    };
    
    reader.readAsText(file);
    jsonFileInput.value = '';
  });
  
  // ========== HELP ==========
  
  helpBtn.addEventListener('click', () => {
    helpModal.classList.add('visible');
  });
  
  closeHelpModal.addEventListener('click', () => {
    helpModal.classList.remove('visible');
  });
  
  helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
      helpModal.classList.remove('visible');
    }
  });
  
  exportModal.addEventListener('click', (e) => {
    if (e.target === exportModal) {
      exportModal.classList.remove('visible');
    }
  });
  
  annotationEditorModal.addEventListener('click', (e) => {
    if (e.target === annotationEditorModal) {
      annotationEditorModal.classList.remove('visible');
    }
  });
  
  // Window resize handler - simplified for fixed iframe width
  window.addEventListener('resize', () => {
    console.log('üîç WINDOW RESIZE - Fixed iframe width (1000px), no scaling needed');
    console.log('  Browser dimensions:', {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    });
    console.log('  Iframe remains fixed at 1000x800px - annotations maintain exact positioning');
  });
  
  // Add playhead drag event listener
  timelinePlayhead.addEventListener('mousedown', startPlayheadDrag);
  
  console.log('Tutorial Creator v13.11 initialized - Added draggable playhead functionality');
})();
</script>
</body>
</html>
