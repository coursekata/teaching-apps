current mouse position for stopEventTrim
    trimmingEvent.currentX = e.clientX;
    
    if (trimmingEvent.edge === 'left') {
      // Trim from start: move start time forward
      const newStartTime = Math.max(
        trimmingEvent.originalStartTime + dt,
        trimmingEvent.originalStartTime // Can't go before original start
      );
      
      // Ensure we don't go past the end (leave at least 100ms)
      const maxStartTime = trimmingEvent.originalEndTime - 100;
      const clampedStartTime = Math.min(newStartTime, maxStartTime);
      
      // Find which snapshot index corresponds to the new start time
      let newStartIdx = trimmingEvent.startIdx;
      for (let i = trimmingEvent.startIdx; i <= trimmingEvent.endIdx; i++) {
        if (currentTutorial.snapshots[i].timestamp >= clampedStartTime) {
          newStartIdx = i;
          break;
        }
      }
      
      // Ensure at least 2 snapshots remain
      if (newStartIdx >= trimmingEvent.endIdx - 1) {
        newStartIdx = trimmingEvent.endIdx - 1;
      }
      
      // Store for stopEventTrim
      trimmingEvent.newStartIdx = newStartIdx;
      
      // Visual feedback: update the event span
      const eventSpan = document.querySelector(`.timeline-event[data-start-idx="${trimmingEvent.startIdx}"]`);
      if (eventSpan) {
        const newStartTimeSec = currentTutorial.snapshots[newStartIdx].timestamp / 1000;
        const endTimeSec = trimmingEvent.originalEndTime / 1000;
        const newWidth = Math.max(8, (endTimeSec - newStartTimeSec) * timelineScale - 18);
        eventSpan.style.left = (newStartTimeSec * timelineScale) + 'px';
        eventSpan.style.width = newWidth + 'px';
      }
    } else {
      // Trim from end: move end time backward
      const newEndTime = Math.min(
        trimmingEvent.originalEndTime + dt,
        trimmingEvent.originalEndTime // Can't go past original end
      );
      
      // Ensure we don't go before the start (leave at least 100ms)
      const minEndTime = trimmingEvent.originalStartTime + 100;
      const clampedEndTime = Math.max(newEndTime, minEndTime);
      
      // Find which snapshot index corresponds to the new end time
      let newEndIdx = trimmingEvent.endIdx;
      for (let i = trimmingEvent.endIdx; i >= trimmingEvent.startIdx; i--) {
        if (currentTutorial.snapshots[i].timestamp <= clampedEndTime) {
          newEndIdx = i;
          break;
        }
      }
      
      // Ensure at least 2 snapshots remain
      if (newEndIdx <= trimmingEvent.startIdx + 1) {
        newEndIdx = trimmingEvent.startIdx + 1;
      }
      
      // Store for stopEventTrim
      trimmingEvent.newEndIdx = newEndIdx;
      
      // Visual feedback: update the event span
      const eventSpan = document.querySelector(`.timeline-event[data-start-idx="${trimmingEvent.startIdx}"]`);
      if (eventSpan) {
        const startTimeSec = trimmingEvent.originalStartTime / 1000;
        const newEndTimeSec = currentTutorial.snapshots[newEndIdx].timestamp / 1000;
        const newWidth = Math.max(8, (newEndTimeSec - startTimeSec) * timelineScale - 18);
        eventSpan.style.width = newWidth + 'px';
      }
    }
  }
  
  function stopEventTrim() {
    if (!trimmingEvent) return;
    
    console.log('üî™ stopEventTrim called:', trimmingEvent);
    
    if (trimmingEvent.edge === 'left') {
      // Actually delete the trimmed snapshots from the start
      const newStartIdx = trimmingEvent.newStartIdx || trimmingEvent.startIdx;
      const deleteCount = newStartIdx - trimmingEvent.startIdx;
      
      console.log(`  Trimming from left: startIdx=${trimmingEvent.startIdx}, newStartIdx=${newStartIdx}, deleteCount=${deleteCount}`);
      
      if (deleteCount > 0) {
        currentTutorial.snapshots.splice(trimmingEvent.startIdx, deleteCount);
        console.log(`üî™ Trimmed ${deleteCount} snapshots from start`);
      }
    } else {
      // Actually delete the trimmed snapshots from the end
      const newEndIdx = trimmingEvent.newEndIdx || trimmingEvent.endIdx;
      const deleteCount = trimmingEvent.endIdx - newEndIdx;
      
      console.log(`  Trimming from right: endIdx=${trimmingEvent.endIdx}, newEndIdx=${newEndIdx}, deleteCount=${deleteCount}`);
      
      if (deleteCount > 0) {
        currentTutorial.snapshots.splice(newEndIdx + 1, deleteCount);
        console.log(`üî™ Trimmed ${deleteCount} snapshots from end`);
      }
    }
    
    trimmingEvent = null;
    document.removeEventListener('mousemove', doEventTrim);
    document.removeEventListener('mouseup', stopEventTrim);
    
    // Recalculate duration and re-render timeline
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  function stopAnnotationDrag() {
    if (!draggingAnnotation) return;
    
    // Only do overlap checking and re-rendering if user actually dragged
    if (!draggingAnnotation.hasMoved) {
      draggingAnnotation = null;
      document.removeEventListener('mousemove', doAnnotationDrag);
      document.removeEventListener('mouseup', stopAnnotationDrag);
      return;
    }
    
    const draggedIndex = draggingAnnotation.index;
    const draggedAnn = currentTutorial.annotations[draggedIndex];
    
    // Check for overlap with previous annotation (dragging right over left)
    if (draggedIndex > 0) {
      const prevAnn = currentTutorial.annotations[draggedIndex - 1];
      const prevEnd = prevAnn.timestamp + prevAnn.duration;
      
      if (draggedAnn.timestamp < prevEnd) {
        // Current annotation overlaps previous one
        // Shorten the previous annotation so it ends where current one starts
        const newPrevDuration = draggedAnn.timestamp - prevAnn.timestamp;
        if (newPrevDuration >= 1000) { // Minimum 1 second
          prevAnn.duration = newPrevDuration;
          console.log('‚ö†Ô∏è Shortened previous annotation to avoid overlap');
        } else {
          // If shortening would make it too small, push the dragged annotation forward instead
          draggedAnn.timestamp = prevAnn.timestamp + prevAnn.duration;
          console.log('‚ö†Ô∏è Moved annotation forward to avoid making previous one too short');
        }
      }
    }
    
    // Check for overlap with next annotation (dragging left over right)
    if (draggedIndex < currentTutorial.annotations.length - 1) {
      const nextAnn = currentTutorial.annotations[draggedIndex + 1];
      const draggedEnd = draggedAnn.timestamp + draggedAnn.duration;
      
      if (draggedEnd > nextAnn.timestamp) {
        // Dragged annotation overlaps next one
        // Move the next annotation to start where dragged one ends
        nextAnn.timestamp = draggedEnd;
        console.log('‚ö†Ô∏è Moved next annotation forward to avoid overlap');
      }
    }
    
    draggingAnnotation = null;
    document.removeEventListener('mousemove', doAnnotationDrag);
    document.removeEventListener('mouseup', stopAnnotationDrag);
    
    // Recalculate tutorial duration after moving
    recalculateTutorialDuration();
    renderTimeline();
  }
  
  // Recalculate tutorial duration based on snapshots and annotations
  function recalculateTutorialDuration() {
    if (!currentTutorial) return;
    
    let calculatedDuration = 0;
    let durationSource = 'none';
    
    // Get last snapshot time
    let lastSnapshotTime = 0;
    let lastSnapshotIsSingleEvent = false;
    if (currentTutorial.snapshots.length > 0) {
      const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
      lastSnapshotTime = lastSnapshot.timestamp;
      calculatedDuration = lastSnapshotTime;
      durationSource = 'snapshot';
      
      // Check if last snapshot is a single event (not dragEnd)
      const action = lastSnapshot.event.action;
      lastSnapshotIsSingleEvent = !action.includes('End') && !action.includes('drag') && !action.includes('Drag');
    }
    
    // Get last annotation end time
    let lastAnnotationEnd = 0;
    if (currentTutorial.annotations.length > 0) {
      lastAnnotationEnd = Math.max(...currentTutorial.annotations.map(ann => ann.timestamp + ann.duration));
      if (lastAnnotationEnd > calculatedDuration) {
        calculatedDuration = lastAnnotationEnd;
        durationSource = 'annotation';
        lastSnapshotIsSingleEvent = false; // Override if annotation extends further
      }
    }
    
    // Get last pause time
    let lastPauseTime = 0;
    if (currentTutorial.pauses && currentTutorial.pauses.length > 0) {
      lastPauseTime = Math.max(...currentTutorial.pauses.map(p => p.timestamp));
      if (lastPauseTime > calculatedDuration) {
        calculatedDuration = lastPauseTime;
        durationSource = 'pause';
        lastSnapshotIsSingleEvent = false; // Override if pause extends further
      }
    }
    
    // Add small buffer for single events so playhead aligns with right edge of visual marker
    // Single events are rendered as 8px wide markers, so add buffer for visual consistency
    if (lastSnapshotIsSingleEvent) {
      calculatedDuration += 200; // Add 200ms buffer (8px at ~40-50 px/s scale)
      console.log('üìä Added visual buffer for single event ending');
    }
    
    currentTutorial.duration = calculatedDuration;
    console.log('üìä Duration recalculated:', (calculatedDuration / 1000).toFixed(2) + 's');
    console.log('  Last snapshot:', (lastSnapshotTime / 1000).toFixed(2) + 's');
    console.log('  Last annotation end:', (lastAnnotationEnd / 1000).toFixed(2) + 's');
    console.log('  Last pause:', (lastPauseTime / 1000).toFixed(2) + 's');
    console.log('  Duration determined by:', durationSource);
  }
  
  // ========== ANNOTATION EDITING ==========
  
  // ========== EXPORT/IMPORT ==========
  
  exportRecording.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    // Don't finalize - just export the current state
    // User can continue recording after exporting
    
    snapshotCount.textContent = currentTutorial.snapshots.length;
    annotationCount.textContent = currentTutorial.annotations.length;
    exportTextarea.value = JSON.stringify(currentTutorial, null, 2);
    exportModal.classList.add('visible');
  });
  
  downloadExport.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    const jsonStr = JSON.stringify(currentTutorial, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tutorial-' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    downloadExport.textContent = '‚úì Downloaded!';
    setTimeout(() => {
      downloadExport.textContent = 'üíæ Download JSON';
    }, 2000);
  });
  
  copyExport.addEventListener('click', () => {
    exportTextarea.select();
    document.execCommand('copy');
    copyExport.textContent = '‚úì Copied!';
    setTimeout(() => {
      copyExport.textContent = 'üìã Copy to Clipboard';
    }, 2000);
  });
  
  closeExportModal.addEventListener('click', () => {
    exportModal.classList.remove('visible');
  });
  
  loadJSON.addEventListener('click', () => {
    jsonFileInput.click();
  });
  
  jsonFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const imported = JSON.parse(event.target.result);
        
        if (!imported.initialState || !imported.snapshots || !imported.annotations) {
          throw new Error('Invalid tutorial format');
        }
        
        // Backward compatibility: add pauses array if it doesn't exist
        if (!imported.pauses) {
          imported.pauses = [];
        }
        
        currentTutorial = imported;
        
        // Load the app if not already loaded
        if (!isAppLoaded && imported.initialState) {
          // We can't auto-load without a URL, so just inform user
          alert('Tutorial loaded! Please load the app first using "Load App", then the tutorial will be ready to edit.');
        } else if (isAppLoaded) {
          const api = getAPI();
          if (api) {
            // Apply the last snapshot's state instead of initial state
            // This shows the final state with all settings that were active at the end
            if (currentTutorial.snapshots.length > 0) {
              const lastSnapshot = currentTutorial.snapshots[currentTutorial.snapshots.length - 1];
              api.setState(lastSnapshot.state);
            } else {
              api.setState(currentTutorial.initialState);
            }
          }
          
          // Set up recording state as if we just paused
          isRecording = true;
          isPaused = true;
          recordingStartTime = Date.now(); // Start recording from NOW
          pauseStartTime = Date.now(); // Set pause start time for correct resume calculation
          totalPausedTime = 0;
          importedDurationOffset = currentTutorial.duration || 0; // Offset new events by imported duration
          
          // Set up event listener (so we can continue recording)
          eventListener = (event) => {
            const timestamp = Date.now() - recordingStartTime - totalPausedTime + importedDurationOffset;
            const snapshot = {
              timestamp: timestamp,
              event: event,
              state: api.getState()
            };
            currentTutorial.snapshots.push(snapshot);
            renderTimeline();
          };
          api.onAction(eventListener);
          
          // Show paused recording UI
          startRecording.style.display = 'inline-block';
          startRecording.textContent = '‚è∫ Record';
          startRecording.classList.remove('recording-active');
          startRecording.className = 'record';
          loadJSON.style.display = 'none';
          playPauseRecording.style.display = 'none';
          recordingIndicator.style.display = 'none';
          pausedIndicator.style.display = 'none';
          addAnnotation.style.display = 'inline-block';
          addAnnotation.disabled = false;
          addAnnotationAtPause.style.display = 'none';
          addPause.style.display = 'inline-block';
          addPause.disabled = false;
          previewRecording.style.display = 'inline-block';
          previewRecording.disabled = false;
          recordAgain.style.display = 'inline-block';
          recordAgain.disabled = false;
          exportRecording.style.display = 'inline-block';
          exportRecording.disabled = false;
          
          renderTimeline();
          
          // Position playhead at the end of the imported tutorial
          const timelineStartOffset = getTimelineStartOffset();
          const timelineEndPosition = ((currentTutorial.duration - timelineStartOffset) / 1000) * timelineScale + 60;
          timelinePlayhead.style.left = timelineEndPosition + 'px';
          timelinePlayhead.style.display = 'block';
          
          alert('‚úì Tutorial loaded!\n\nYou can now:\n‚Ä¢ Preview it\n‚Ä¢ Resume recording to add more\n‚Ä¢ Add/edit annotations\n‚Ä¢ Export when done');
        }
        
        console.log('üì§ Tutorial imported');
      } catch (err) {
        alert('Error importing tutorial: ' + err.message);
        console.error('Import error:', err);
      }
    };
    
    reader.readAsText(file);
    jsonFileInput.value = '';
  });
  
  // ========== HELP ==========
  
  helpBtn.addEventListener('click', () => {
    helpModal.classList.add('visible');
  });
  
  closeHelpModal.addEventListener('click', () => {
    helpModal.classList.remove('visible');
  });
  
  helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
      helpModal.classList.remove('visible');
    }
  });
  
  exportModal.addEventListener('click', (e) => {
    if (e.target === exportModal) {
      exportModal.classList.remove('visible');
    }
  });
  
  annotationEditorModal.addEventListener('click', (e) => {
    if (e.target === annotationEditorModal) {
      annotationEditorModal.classList.remove('visible');
    }
  });
  
  console.log('Tutorial Creator v12.21 initialized');
})();
</script>
</body>
</html>
