<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Tutorial Creator - v7</title>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    },
    startup: {
      ready: () => {
        MathJax.startup.defaultReady();
      }
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  :root{
    --accent:#2563eb;
    --record:#ef4444;
    --success:#10b981;
    --warning:#f59e0b;
  }
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#111;
    background:#f5f5f5;
  }
  
  .tutorial-header{
    position: sticky;
    top: 0;
    background:#fff;
    border-bottom:2px solid #ddd;
    padding:12px 20px;
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
    z-index: 100;
  }
  
  .tutorial-controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  .mode-toggle{
    display:flex;
    gap:8px;
    padding:4px;
    background:#f0f0f0;
    border-radius:8px;
  }
  
  .mode-toggle button{
    padding:8px 16px;
    border-radius:6px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-weight:600;
    font-size:13px;
  }
  
  .mode-toggle button.active{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button{
    padding:8px 14px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:13px;
  }
  
  button:hover:not(:disabled):not(.primary):not(.record):not(.success):not(.warning){
    background:#f9f9f9;
  }
  
  button:disabled{
    opacity:0.5;
    cursor:not-allowed;
  }
  
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button.record{
    background:var(--record);
    color:#fff;
    border-color:var(--record);
  }
  
  button.success{
    background:var(--success);
    color:#fff;
    border-color:var(--success);
  }
  
  button.warning{
    background:var(--warning);
    color:#fff;
    border-color:var(--warning);
  }
  
  button.record.recording{
    animation:pulse 1.5s infinite;
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.6}
  }
  
  .recording-indicator{
    background:var(--record);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
    animation:pulse 1.5s infinite;
  }
  
  .paused-indicator{
    background:var(--warning);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
  }
  
  .playback-controls{
    display:flex;
    gap:8px;
    align-items:center;
    background:#f0f0f0;
    padding:8px;
    border-radius:8px;
  }
  
  .playback-timeline{
    flex:1;
    min-width:200px;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  
  .playback-timeline input[type=range]{
    width:100%;
    accent-color:var(--accent);
  }
  
  .time-display{
    font-size:11px;
    color:#666;
    text-align:center;
  }
  
  .app-container{
    position:relative;
    width:100%;
    height:600px;
    overflow:hidden;
  }
  
  iframe{
    width:100%;
    height:100%;
    border:none;
  }
  
  iframe.playback-mode{
    pointer-events:none;
  }
  
  /* Timeline Editor */
  .timeline-container{
    background:#fff;
    border-top:2px solid #ddd;
    padding:4px 20px 6px 20px;
    display:none;
    position:relative;
  }
  
  .timeline-container.visible{
    display:block;
  }
  
  .timeline-ruler{
    height:14px;
    position:relative;
    margin-bottom:0px;
    margin-left:60px;
    overflow:hidden;
  }
  
  .timeline-tick{
    position:absolute;
    width:1px;
    height:100%;
    background:#ddd;
  }
  
  .timeline-tick.major{
    height:100%;
    background:#999;
  }
  
  .timeline-tick-label{
    position:absolute;
    font-size:10px;
    color:#666;
    transform:translateX(-50%);
    top:-2px;
  }
  
  .timeline-playhead{
    position:absolute;
    width:2px;
    height:100%;
    background:var(--record);
    pointer-events:none;
    z-index:10;
    display:none;
  }
  
  .timeline-playhead::before{
    content:'';
    position:absolute;
    top:-8px;
    left:50%;
    transform:translateX(-50%);
    width:12px;
    height:12px;
    background:var(--record);
    border-radius:50%;
    cursor:pointer;
    pointer-events:all;
  }
  
  .timeline-track{
    position:relative;
    height:50px;
    margin-left:60px;
    margin-top:8px;
    margin-bottom:8px;
  }
  
  .timeline-item{
    position:absolute;
    height:40px;
    background:#e0f2fe;
    border:2px solid var(--accent);
    border-radius:8px;
    cursor:move;
    display:flex;
    align-items:center;
    padding:0 8px;
    overflow:hidden;
  }
  
  .timeline-item-content{
    flex:1;
    overflow:hidden;
  }
  
  .timeline-item-title{
    font-size:12px;
    font-weight:600;
    color:var(--accent);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  
  .timeline-item-duration{
    font-size:10px;
    color:#666;
  }
  
  .timeline-item-edge{
    position:absolute;
    width:8px;
    height:100%;
    cursor:ew-resize;
    background:transparent;
  }
  
  .timeline-item-edge.left{
    left:0;
  }
  
  .timeline-item-edge.right{
    right:0;
  }
  
  .timeline-item-edge:hover{
    background:rgba(37,99,235,0.3);
  }
  
  .timeline-label{
    position:absolute;
    left:0;
    width:50px;
    font-size:11px;
    font-weight:600;
    color:#666;
    display:flex;
    align-items:center;
    justify-content:flex-end;
    padding-right:8px;
  }
  
  /* Modal styles */
  .modal-overlay{
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.5);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:1000;
  }
  
  .modal-overlay.visible{
    display:flex;
  }
  
  .modal-content{
    background:#fff;
    border-radius:12px;
    padding:24px;
    max-width:500px;
    width:90%;
    max-height:80vh;
    overflow-y:auto;
  }
  
  .modal-header{
    margin-bottom:20px;
  }
  
  .modal-header h2{
    margin:0;
    color:var(--accent);
    font-size:20px;
  }
  
  .modal-body{
    display:flex;
    flex-direction:column;
    gap:16px;
  }
  
  .form-group{
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  
  .form-group label{
    font-weight:600;
    font-size:13px;
    color:#444;
  }
  
  .form-group input,
  .form-group textarea{
    padding:8px;
    border:1px solid #ddd;
    border-radius:6px;
    font-size:14px;
    font-family:inherit;
  }
  
  .form-group textarea{
    min-height:100px;
    resize:vertical;
  }
  
  .modal-footer{
    margin-top:20px;
    display:flex;
    gap:8px;
    justify-content:flex-end;
  }
  
  .position-editor-overlay{
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.3);
    display:none;
    z-index:999;
  }
  
  .position-editor-controls{
    position:fixed;
    top:20px;
    right:20px;
    background:#fff;
    padding:16px;
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,0.2);
    z-index:1001;
  }
  
  .controls-divider{
    width:2px;
    height:24px;
    background:#ddd;
  }
</style>
</head>
<body>

<div class="tutorial-header">
  <div class="tutorial-controls">
    <!-- Mode Toggle -->
    <div class="mode-toggle">
      <button id="recordMode" class="active">üìù Record</button>
      <button id="previewMode">‚ñ∂Ô∏è Preview</button>
    </div>
    
    <!-- Record Mode Controls -->
    <div id="recordControls" style="display:flex;gap:12px;align-items:center;">
      <button id="startRecord" class="record">‚óè Start Recording</button>
      <button id="pauseRecord" class="warning" style="display:none;">‚è∏ Pause</button>
      <button id="resumeRecord" class="success" style="display:none;">‚ñ∂ Resume</button>
      <button id="stopRecord" class="primary" style="display:none;">‚èπ Stop</button>
      <div id="recordingStatus"></div>
      <button id="addAnnotation" style="display:none;">üí¨ Add Annotation</button>
    </div>
    
    <!-- Preview Mode Controls -->
    <div id="previewControls" style="display:none;gap:12px;align-items:center;">
      <button id="playPreview" class="primary">‚ñ∂ Play Tutorial</button>
      <button id="playPausePreview" class="warning" style="display:none;">‚è∏ Pause Preview</button>
      <button id="stopPreview" style="display:none;">‚èπ Stop Preview</button>
      <button id="restartPreview" style="display:none;">üîÑ Restart</button>
    </div>
    
    <div class="controls-divider"></div>
    
    <button id="saveTutorial" style="display:none;">üíæ Save Tutorial</button>
    <button id="loadTutorial">üìÇ Load Tutorial</button>
    <button id="toggleTimeline" style="display:none;">üìä Timeline Editor</button>
    <input type="file" id="tutorialFileInput" accept=".json" style="display:none;"/>
  </div>
</div>

<div class="app-container">
  <iframe id="appFrame" src=""></iframe>
</div>

<!-- Timeline Editor -->
<div class="timeline-container" id="timelineContainer">
  <div class="timeline-label" style="top:4px;">Timeline</div>
  <div class="timeline-ruler" id="timelineRuler">
    <div class="timeline-playhead" id="timelinePlayhead"></div>
  </div>
  <div class="timeline-label" style="top:30px;">Annotations</div>
  <div class="timeline-track" id="timelineTrack"></div>
</div>

<!-- Annotation Edit Modal -->
<div class="modal-overlay" id="annotationEditModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Edit Annotation</h2>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Title</label>
        <input type="text" id="editAnnTitle" placeholder="Annotation title"/>
      </div>
      <div class="form-group">
        <label>Text (supports LaTeX with $ delimiters)</label>
        <textarea id="editAnnText" placeholder="Annotation text..."></textarea>
      </div>
      <div class="form-group">
        <label>Duration (seconds)</label>
        <input type="number" id="editAnnDuration" min="1" step="0.5" value="5"/>
      </div>
      <div class="form-group">
        <label>Timestamp (seconds)</label>
        <input type="number" id="editAnnTimestamp" min="0" step="0.1" readonly/>
      </div>
    </div>
    <div class="modal-footer">
      <button id="cancelEditAnnotation">Cancel</button>
      <button id="deleteAnnotation" class="record">Delete</button>
      <button id="repositionAnnotation" class="warning">Reposition</button>
      <button id="resizeAnnotation" class="warning">Resize</button>
      <button id="saveEditAnnotation" class="success">Save Changes</button>
    </div>
  </div>
</div>

<!-- Position Editor Overlay -->
<div class="position-editor-overlay" id="positionEditorOverlay">
  <div class="position-editor-controls">
    <p style="margin:0 0 12px;font-weight:600;">Position the annotation box</p>
    <p style="margin:0 0 12px;font-size:12px;color:#666;">Drag to move, use corner handle to resize</p>
    <button id="savePosition" class="success">üíæ Save Position</button>
  </div>
</div>

<script>
(function(){
  'use strict';
  
  // DOM Elements
  const appFrame = document.getElementById('appFrame');
  const recordMode = document.getElementById('recordMode');
  const previewMode = document.getElementById('previewMode');
  const recordControls = document.getElementById('recordControls');
  const previewControls = document.getElementById('previewControls');
  const startRecord = document.getElementById('startRecord');
  const pauseRecord = document.getElementById('pauseRecord');
  const resumeRecord = document.getElementById('resumeRecord');
  const stopRecord = document.getElementById('stopRecord');
  const recordingStatus = document.getElementById('recordingStatus');
  const addAnnotation = document.getElementById('addAnnotation');
  const playPreview = document.getElementById('playPreview');
  const playPausePreview = document.getElementById('playPausePreview');
  const stopPreview = document.getElementById('stopPreview');
  const restartPreview = document.getElementById('restartPreview');
  const saveTutorial = document.getElementById('saveTutorial');
  const loadTutorial = document.getElementById('loadTutorial');
  const tutorialFileInput = document.getElementById('tutorialFileInput');
  const toggleTimeline = document.getElementById('toggleTimeline');
  const timelineContainer = document.getElementById('timelineContainer');
  const timelineRuler = document.getElementById('timelineRuler');
  const timelineTrack = document.getElementById('timelineTrack');
  
  // Annotation edit modal
  const annotationEditModal = document.getElementById('annotationEditModal');
  const editAnnTitle = document.getElementById('editAnnTitle');
  const editAnnText = document.getElementById('editAnnText');
  const editAnnDuration = document.getElementById('editAnnDuration');
  const editAnnTimestamp = document.getElementById('editAnnTimestamp');
  const saveEditAnnotation = document.getElementById('saveEditAnnotation');
  const deleteAnnotation = document.getElementById('deleteAnnotation');
  const repositionAnnotation = document.getElementById('repositionAnnotation');
  const resizeAnnotation = document.getElementById('resizeAnnotation');
  const cancelEditAnnotation = document.getElementById('cancelEditAnnotation');
  const positionEditorOverlay = document.getElementById('positionEditorOverlay');
  const savePosition = document.getElementById('savePosition');
  
  // State
  let currentMode = 'record';
  let isRecording = false;
  let isPaused = false;
  let recordingStartTime = null;
  let pauseStartTime = null;
  let totalPausedTime = 0;
  let recordedEvents = [];
  let currentTutorial = null;
  let pendingAnnotation = null;
  let eventQueue = [];
  let isPlaying = false;
  let playbackStartTime = null;
  let playbackPausedAt = 0;
  let currentAnnotationIndex = -1;
  let editingAnnotationIndex = -1;
  let timelineVisible = false;
  let timelineScale = 100; // pixels per second
  let draggingTimelineItem = null;
  let resizingTimelineItem = null;
  
  // References to annotation box in iframe
  let iframeAnnotationBox = null;
  let iframeAnnotationTitle = null;
  let iframeAnnotationText = null;
  
  // App URL prompt
  const defaultAppUrl = prompt('Enter the URL of the app to create a tutorial for:', 'https://jimrandomh.github.io/ci-demo/ci-demo-v10.html');
  if (!defaultAppUrl) {
    alert('No URL provided. Please reload to try again.');
  } else {
    appFrame.src = defaultAppUrl;
  }
  
  // Wait for iframe to load before setting up annotation box
  appFrame.addEventListener('load', initializeAnnotationBox);
  
  function initializeAnnotationBox() {
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      
      // Check if annotation box already exists
      if (iframeDoc.getElementById('tutorialAnnotationBox')) {
        iframeAnnotationBox = iframeDoc.getElementById('tutorialAnnotationBox');
        iframeAnnotationTitle = iframeDoc.getElementById('tutorialAnnotationTitle');
        iframeAnnotationText = iframeDoc.getElementById('tutorialAnnotationText');
        return;
      }
      
      // Inject CSS into iframe
      const style = iframeDoc.createElement('style');
      style.textContent = `
        .tutorial-annotation-box {
          position: absolute;
          width: 250px;
          max-width: 500px;
          background: rgba(255, 255, 255, 0.98);
          border: 3px solid #2563eb;
          border-radius: 12px;
          padding: 20px;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
          z-index: 10000;
          display: none;
          overflow-y: auto;
          overflow-x: hidden;
          box-sizing: border-box;
        }
        
        .tutorial-annotation-box.custom-position {
          max-width: none;
        }
        
        .tutorial-annotation-box.draggable {
          overflow: hidden;
          cursor: move;
          border-color: #f59e0b;
          border-style: dashed;
        }
        
        .tutorial-annotation-box.visible {
          display: block;
          animation: tutorialSlideIn 0.3s ease-out;
        }
        
        .tutorial-annotation-box h3 {
          margin: 0 0 12px;
          color: #2563eb;
          font-size: 18px;
        }
        
        .tutorial-annotation-box p {
          margin: 0;
          line-height: 1.6;
          font-size: 15px;
        }
        
        .tutorial-annotation-box .resize-handle {
          position: absolute;
          bottom: 0;
          right: 0;
          width: 20px;
          height: 20px;
          background: #f59e0b;
          cursor: nwse-resize;
          border-top-left-radius: 4px;
          border-bottom-right-radius: 12px;
        }
        
        .tutorial-annotation-box .resize-handle::after {
          content: '‚ã∞';
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          color: #fff;
          font-size: 14px;
          line-height: 1;
        }
        
        @keyframes tutorialSlideIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
      `;
      iframeDoc.head.appendChild(style);
      
      // Create annotation box in iframe
      iframeAnnotationBox = iframeDoc.createElement('div');
      iframeAnnotationBox.id = 'tutorialAnnotationBox';
      iframeAnnotationBox.className = 'tutorial-annotation-box';
      
      iframeAnnotationTitle = iframeDoc.createElement('h3');
      iframeAnnotationTitle.id = 'tutorialAnnotationTitle';
      
      iframeAnnotationText = iframeDoc.createElement('p');
      iframeAnnotationText.id = 'tutorialAnnotationText';
      
      iframeAnnotationBox.appendChild(iframeAnnotationTitle);
      iframeAnnotationBox.appendChild(iframeAnnotationText);
      
      iframeDoc.body.appendChild(iframeAnnotationBox);
      
      console.log('‚úì Annotation box injected into iframe');
    } catch (err) {
      console.error('Error initializing annotation box:', err);
    }
  }
  
  // Mode Toggle
  recordMode.addEventListener('click', () => {
    currentMode = 'record';
    recordMode.classList.add('active');
    previewMode.classList.remove('active');
    recordControls.style.display = 'flex';
    previewControls.style.display = 'none';
    appFrame.classList.remove('playback-mode');
    
    if (iframeAnnotationBox) {
      iframeAnnotationBox.classList.remove('visible');
    }
  });
  
  previewMode.addEventListener('click', () => {
    if (!currentTutorial) {
      alert('No tutorial recorded yet! Switch to Record mode first.');
      return;
    }
    
    currentMode = 'preview';
    previewMode.classList.add('active');
    recordMode.classList.remove('active');
    recordControls.style.display = 'none';
    previewControls.style.display = 'flex';
    appFrame.classList.add('playback-mode');
  });
  
  // Recording Controls
  startRecord.addEventListener('click', () => {
    isRecording = true;
    isPaused = false;
    recordingStartTime = Date.now();
    totalPausedTime = 0;
    recordedEvents = [];
    
    startRecord.style.display = 'none';
    pauseRecord.style.display = 'inline-block';
    stopRecord.style.display = 'inline-block';
    addAnnotation.style.display = 'inline-block';
    recordingStatus.innerHTML = '<span class="recording-indicator">‚óè Recording</span>';
    
    // Reload iframe to start fresh
    appFrame.src = appFrame.src;
    appFrame.addEventListener('load', setupRecordingListeners, { once: true });
  });
  
  pauseRecord.addEventListener('click', () => {
    isPaused = true;
    pauseStartTime = Date.now();
    
    pauseRecord.style.display = 'none';
    resumeRecord.style.display = 'inline-block';
    recordingStatus.innerHTML = '<span class="paused-indicator">‚è∏ Paused</span>';
  });
  
  resumeRecord.addEventListener('click', () => {
    isPaused = false;
    totalPausedTime += (Date.now() - pauseStartTime);
    pauseStartTime = null;
    
    resumeRecord.style.display = 'none';
    pauseRecord.style.display = 'inline-block';
    recordingStatus.innerHTML = '<span class="recording-indicator">‚óè Recording</span>';
  });
  
  stopRecord.addEventListener('click', () => {
    isRecording = false;
    isPaused = false;
    
    const duration = Date.now() - recordingStartTime - totalPausedTime;
    
    currentTutorial = {
      version: '2.0',
      appUrl: appFrame.src,
      duration: duration,
      events: recordedEvents,
      annotations: [],
      tutorialStartOffset: recordingStartTime
    };
    
    startRecord.style.display = 'inline-block';
    pauseRecord.style.display = 'none';
    resumeRecord.style.display = 'none';
    stopRecord.style.display = 'none';
    addAnnotation.style.display = 'none';
    recordingStatus.innerHTML = '';
    
    saveTutorial.style.display = 'inline-block';
    toggleTimeline.style.display = 'inline-block';
    
    alert(`‚úì Recording stopped! Duration: ${(duration/1000).toFixed(1)}s\n${recordedEvents.length} events captured`);
    
    // Reset iframe interaction
    appFrame.contentWindow.location.reload();
  });
  
  function setupRecordingListeners() {
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    const iframeWin = appFrame.contentWindow;
    
    // Capture all events
    const eventTypes = ['click', 'input', 'change', 'scroll', 'keydown', 'keyup', 'mousemove'];
    
    eventTypes.forEach(type => {
      iframeDoc.addEventListener(type, (e) => {
        if (!isRecording || isPaused) return;
        
        const eventTime = Date.now();
        const relativeTime = eventTime - recordingStartTime - totalPausedTime;
        
        const eventData = {
          type: e.type,
          timestamp: relativeTime,
          target: getElementPath(e.target),
          value: e.target.value,
          checked: e.target.checked,
          key: e.key,
          keyCode: e.keyCode,
          clientX: e.clientX,
          clientY: e.clientY,
          scrollX: iframeWin.scrollX,
          scrollY: iframeWin.scrollY
        };
        
        recordedEvents.push(eventData);
      }, true);
    });
  }
  
  function getElementPath(element) {
    if (!element || element === document) return '';
    
    const path = [];
    while (element && element !== document.body) {
      let selector = element.tagName.toLowerCase();
      
      if (element.id) {
        selector += '#' + element.id;
        path.unshift(selector);
        break;
      }
      
      if (element.className && typeof element.className === 'string') {
        const classes = element.className.trim().split(/\s+/).join('.');
        if (classes) selector += '.' + classes;
      }
      
      const parent = element.parentElement;
      if (parent) {
        const siblings = Array.from(parent.children).filter(e => e.tagName === element.tagName);
        if (siblings.length > 1) {
          const index = siblings.indexOf(element);
          selector += `:nth-of-type(${index + 1})`;
        }
      }
      
      path.unshift(selector);
      element = parent;
    }
    
    return path.join(' > ');
  }
  
  // Annotation Controls
  addAnnotation.addEventListener('click', () => {
    const title = prompt('Annotation Title:', '');
    if (!title) return;
    
    const text = prompt('Annotation Text (supports LaTeX with $ delimiters):', '');
    if (!text) return;
    
    const duration = parseFloat(prompt('Duration (seconds):', '5'));
    if (isNaN(duration) || duration <= 0) return;
    
    const currentTime = Date.now() - recordingStartTime - totalPausedTime;
    
    pendingAnnotation = {
      title: title,
      text: text,
      timestamp: currentTime,
      duration: duration * 1000,
      position: null
    };
    
    // Show annotation for positioning
    if (!iframeAnnotationBox) {
      initializeAnnotationBox();
    }
    
    if (iframeAnnotationBox) {
      iframeAnnotationBox.className = 'tutorial-annotation-box visible draggable custom-position';
      iframeAnnotationBox.style.left = '50px';
      iframeAnnotationBox.style.top = '100px';
      iframeAnnotationBox.style.width = '400px';
      iframeAnnotationBox.style.height = 'auto';
      iframeAnnotationTitle.innerHTML = title;
      iframeAnnotationText.innerHTML = text;
      
      makeDraggable();
      positionEditorOverlay.style.display = 'block';
    }
  });
  
  savePosition.addEventListener('click', () => {
    if (!pendingAnnotation || !iframeAnnotationBox) return;
    
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    const rect = iframeAnnotationBox.getBoundingClientRect();
    const iframeRect = iframeDoc.documentElement.getBoundingClientRect();
    
    pendingAnnotation.position = {
      left: rect.left - iframeRect.left + iframeDoc.documentElement.scrollLeft,
      top: rect.top - iframeRect.top + iframeDoc.documentElement.scrollTop,
      width: rect.width,
      height: rect.height
    };
    
    console.log('üíæ Saving annotation position:', pendingAnnotation.position);
    
    if (!currentTutorial) {
      currentTutorial = {
        version: '2.0',
        appUrl: appFrame.src,
        duration: 0,
        events: recordedEvents,
        annotations: [],
        tutorialStartOffset: recordingStartTime
      };
    }
    
    currentTutorial.annotations.push(pendingAnnotation);
    pendingAnnotation = null;
    
    positionEditorOverlay.style.display = 'none';
    iframeAnnotationBox.classList.remove('visible', 'draggable');
    
    const handles = iframeAnnotationBox.querySelectorAll('.resize-handle');
    handles.forEach(h => h.remove());
    
    saveTutorial.style.display = 'inline-block';
    toggleTimeline.style.display = 'inline-block';
    
    if (timelineVisible) renderTimeline();
    
    alert('‚úì Annotation added!');
  });
  
  function makeDraggable() {
    if (!iframeAnnotationBox) return;
    
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    
    let isDragging = false;
    let isResizing = false;
    let startX, startY, startLeft, startTop, startWidth, startHeight;
    
    // Remove old handle if exists
    const oldHandle = iframeAnnotationBox.querySelector('.resize-handle');
    if (oldHandle) oldHandle.remove();
    
    // Add resize handle
    const handle = iframeDoc.createElement('div');
    handle.className = 'resize-handle';
    iframeAnnotationBox.appendChild(handle);
    
    // Dragging
    iframeAnnotationBox.addEventListener('mousedown', (e) => {
      if (e.target === handle) return;
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      startLeft = iframeAnnotationBox.offsetLeft;
      startTop = iframeAnnotationBox.offsetTop;
      e.preventDefault();
    });
    
    // Resizing
    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startY = e.clientY;
      startWidth = iframeAnnotationBox.offsetWidth;
      startHeight = iframeAnnotationBox.offsetHeight;
      e.stopPropagation();
      e.preventDefault();
    });
    
    iframeDoc.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        iframeAnnotationBox.style.left = (startLeft + dx) + 'px';
        iframeAnnotationBox.style.top = (startTop + dy) + 'px';
      } else if (isResizing) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        iframeAnnotationBox.style.width = Math.max(200, startWidth + dx) + 'px';
        iframeAnnotationBox.style.height = Math.max(50, startHeight + dy) + 'px';
      }
    });
    
    iframeDoc.addEventListener('mouseup', () => {
      isDragging = false;
      isResizing = false;
    });
  }
  
  // Preview Controls
  playPreview.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    console.log('‚ñ∂ Starting preview...');
    
    playPreview.style.display = 'none';
    playPausePreview.style.display = 'inline-block';
    playPausePreview.textContent = '‚è∏ Pause Preview';
    stopPreview.style.display = 'inline-block';
    restartPreview.style.display = 'inline-block';
    
    // Reload iframe to reset state
    appFrame.src = currentTutorial.appUrl;
    appFrame.addEventListener('load', () => {
      // Reinitialize annotation box after reload
      initializeAnnotationBox();
      
      eventQueue = [...currentTutorial.events];
      isPlaying = true;
      playbackStartTime = Date.now();
      playbackPausedAt = 0;
      currentAnnotationIndex = -1;
      
      requestAnimationFrame(playbackLoop);
    }, { once: true });
  });
  
  playPausePreview.addEventListener('click', () => {
    if (isPlaying) {
      // Pause
      isPlaying = false;
      playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
      playPausePreview.textContent = '‚ñ∂ Resume Preview';
      console.log('‚è∏ Paused at:', playbackPausedAt.toFixed(2) + 's');
    } else {
      // Resume
      isPlaying = true;
      playbackStartTime = Date.now() - (playbackPausedAt * 1000);
      playPausePreview.textContent = '‚è∏ Pause Preview';
      console.log('‚ñ∂ Resumed from:', playbackPausedAt.toFixed(2) + 's');
      requestAnimationFrame(playbackLoop);
    }
  });
  
  stopPreview.addEventListener('click', () => {
    isPlaying = false;
    eventQueue = [];
    currentAnnotationIndex = -1;
    
    if (iframeAnnotationBox) {
      iframeAnnotationBox.classList.remove('visible');
    }
    
    playPreview.style.display = 'inline-block';
    playPausePreview.style.display = 'none';
    stopPreview.style.display = 'none';
    restartPreview.style.display = 'none';
    
    appFrame.src = currentTutorial.appUrl;
    appFrame.addEventListener('load', initializeAnnotationBox, { once: true });
  });
  
  restartPreview.addEventListener('click', () => {
    playPreview.click();
  });
  
  function playbackLoop() {
    if (!isPlaying) return;
    
    const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
    const iframeWin = appFrame.contentWindow;
    
    if (!iframeDoc || !iframeWin) {
      console.warn('Iframe not ready');
      requestAnimationFrame(playbackLoop);
      return;
    }
    
    const elapsed = Date.now() - playbackStartTime;
    
    // Process events
    while (eventQueue.length > 0 && eventQueue[0].timestamp <= elapsed) {
      const event = eventQueue.shift();
      replayEvent(event, iframeDoc, iframeWin);
    }
    
    // Handle annotations
    if (currentTutorial.annotations) {
      for (let i = 0; i < currentTutorial.annotations.length; i++) {
        const ann = currentTutorial.annotations[i];
        const annStart = ann.timestamp;
        const annEnd = ann.timestamp + ann.duration;
        
        if (elapsed >= annStart && elapsed < annEnd) {
          if (currentAnnotationIndex !== i) {
            showAnnotation(ann);
            currentAnnotationIndex = i;
          }
          break;
        } else if (elapsed >= annEnd && currentAnnotationIndex === i) {
          hideAnnotation();
          currentAnnotationIndex = -1;
        }
      }
    }
    
    // Check if done
    if (eventQueue.length === 0 && elapsed >= currentTutorial.duration) {
      console.log('‚úì Playback complete');
      isPlaying = false;
      hideAnnotation();
      playPreview.style.display = 'inline-block';
      playPausePreview.style.display = 'none';
      stopPreview.style.display = 'none';
      return;
    }
    
    requestAnimationFrame(playbackLoop);
  }
  
  function replayEvent(event, iframeDoc, iframeWin) {
    try {
      const element = iframeDoc.querySelector(event.target);
      if (!element) {
        console.warn('Element not found:', event.target);
        return;
      }
      
      switch (event.type) {
        case 'click':
          element.click();
          break;
        
        case 'input':
        case 'change':
          if (element.type === 'checkbox' || element.type === 'radio') {
            element.checked = event.checked;
          } else {
            element.value = event.value;
          }
          element.dispatchEvent(new Event(event.type, { bubbles: true }));
          break;
        
        case 'keydown':
        case 'keyup':
          const keyEvent = new KeyboardEvent(event.type, {
            key: event.key,
            keyCode: event.keyCode,
            bubbles: true
          });
          element.dispatchEvent(keyEvent);
          break;
        
        case 'scroll':
          iframeWin.scrollTo(event.scrollX, event.scrollY);
          break;
      }
    } catch (err) {
      console.error('Error replaying event:', err);
    }
  }
  
  function showAnnotation(ann) {
    if (!iframeAnnotationBox) {
      initializeAnnotationBox();
    }
    
    if (!iframeAnnotationBox) {
      console.warn('Annotation box not available');
      return;
    }
    
    console.log('üìù Showing annotation:', ann.title);
    
    iframeAnnotationBox.className = 'tutorial-annotation-box visible custom-position';
    iframeAnnotationBox.style.left = (ann.position?.left || 50) + 'px';
    iframeAnnotationBox.style.top = (ann.position?.top || 100) + 'px';
    iframeAnnotationBox.style.width = (ann.position?.width || 400) + 'px';
    
    if (ann.position?.height) {
      iframeAnnotationBox.style.height = ann.position.height + 'px';
    } else {
      iframeAnnotationBox.style.height = 'auto';
    }
    
    iframeAnnotationTitle.innerHTML = ann.title;
    iframeAnnotationText.innerHTML = ann.text;
    
    // Typeset LaTeX if present
    if (window.MathJax && (ann.title.includes('$') || ann.text.includes('$'))) {
      const iframeWin = appFrame.contentWindow;
      if (iframeWin.MathJax) {
        iframeWin.MathJax.typesetPromise([iframeAnnotationBox]).catch(err => console.error('MathJax error:', err));
      }
    }
  }
  
  function hideAnnotation() {
    if (iframeAnnotationBox) {
      iframeAnnotationBox.classList.remove('visible');
    }
  }
  
  // Save/Load Tutorial
  saveTutorial.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    const json = JSON.stringify(currentTutorial, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tutorial-' + Date.now() + '.json';
    a.click();
    URL.revokeObjectURL(url);
  });
  
  loadTutorial.addEventListener('click', () => {
    tutorialFileInput.click();
  });
  
  tutorialFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        currentTutorial = JSON.parse(e.target.result);
        alert('‚úì Tutorial loaded successfully!');
        saveTutorial.style.display = 'inline-block';
        toggleTimeline.style.display = 'inline-block';
        
        // Switch to preview mode
        previewMode.click();
      } catch (err) {
        alert('Error loading tutorial: ' + err.message);
      }
    };
    reader.readAsText(file);
  });
  
  // Timeline Editor
  toggleTimeline.addEventListener('click', () => {
    timelineVisible = !timelineVisible;
    timelineContainer.classList.toggle('visible', timelineVisible);
    
    if (timelineVisible) {
      renderTimeline();
    }
  });
  
  function renderTimeline() {
    if (!currentTutorial) return;
    
    const duration = currentTutorial.duration / 1000; // Convert to seconds
    
    // Clear existing content
    timelineRuler.innerHTML = '<div class="timeline-playhead" id="timelinePlayhead"></div>';
    timelineTrack.innerHTML = '';
    
    // Calculate scale to fit
    const availableWidth = timelineRuler.offsetWidth;
    timelineScale = Math.max(50, availableWidth / duration);
    
    // Draw time ruler
    const interval = duration > 60 ? 10 : duration > 30 ? 5 : 1;
    for (let t = 0; t <= duration; t += interval) {
      const tick = document.createElement('div');
      tick.className = 'timeline-tick major';
      tick.style.left = (t * timelineScale) + 'px';
      
      const label = document.createElement('div');
      label.className = 'timeline-tick-label';
      label.style.left = (t * timelineScale) + 'px';
      label.textContent = t + 's';
      
      timelineRuler.appendChild(tick);
      timelineRuler.appendChild(label);
    }
    
    // Draw annotation blocks
    currentTutorial.annotations.forEach((ann, index) => {
      const item = document.createElement('div');
      item.className = 'timeline-item';
      item.style.left = ((ann.timestamp / 1000) * timelineScale) + 'px';
      item.style.width = ((ann.duration / 1000) * timelineScale) + 'px';
      item.dataset.index = index;
      
      const content = document.createElement('div');
      content.className = 'timeline-item-content';
      
      const title = document.createElement('div');
      title.className = 'timeline-item-title';
      title.textContent = ann.title;
      
      const duration = document.createElement('div');
      duration.className = 'timeline-item-duration';
      duration.textContent = (ann.duration / 1000).toFixed(1) + 's';
      
      content.appendChild(title);
      content.appendChild(duration);
      item.appendChild(content);
      
      // Resize handles
      const leftEdge = document.createElement('div');
      leftEdge.className = 'timeline-item-edge left';
      leftEdge.dataset.index = index;
      leftEdge.dataset.edge = 'left';
      leftEdge.addEventListener('mousedown', startTimelineResize);
      
      const rightEdge = document.createElement('div');
      rightEdge.className = 'timeline-item-edge right';
      rightEdge.dataset.index = index;
      rightEdge.dataset.edge = 'right';
      rightEdge.addEventListener('mousedown', startTimelineResize);
      
      item.appendChild(leftEdge);
      item.appendChild(rightEdge);
      
      // Make draggable
      item.addEventListener('mousedown', startTimelineDrag);
      
      // Double-click to edit
      item.addEventListener('dblclick', () => openAnnotationEditor(index));
      
      timelineTrack.appendChild(item);
    });
  }
  
  function startTimelineDrag(e) {
    if (e.target.classList.contains('timeline-item-edge')) return;
    
    const index = parseInt(e.currentTarget.dataset.index);
    
    draggingTimelineItem = {
      index: index,
      startX: e.clientX,
      startTime: currentTutorial.annotations[index].timestamp
    };
    
    document.addEventListener('mousemove', doTimelineDrag);
    document.addEventListener('mouseup', stopTimelineDrag);
    e.preventDefault();
  }
  
  function doTimelineDrag(e) {
    if (!draggingTimelineItem) return;
    
    const dx = e.clientX - draggingTimelineItem.startX;
    const dt = (dx / timelineScale) * 1000; // Convert to milliseconds
    
    let newTime = Math.max(0, draggingTimelineItem.startTime + dt);
    newTime = Math.min(newTime, currentTutorial.duration);
    
    currentTutorial.annotations[draggingTimelineItem.index].timestamp = newTime;
    renderTimeline();
  }
  
  function stopTimelineDrag(e) {
    draggingTimelineItem = null;
    document.removeEventListener('mousemove', doTimelineDrag);
    document.removeEventListener('mouseup', stopTimelineDrag);
  }
  
  function startTimelineResize(e) {
    e.stopPropagation();
    
    const index = parseInt(e.target.dataset.index);
    const edge = e.target.dataset.edge;
    
    resizingTimelineItem = {
      index: index,
      edge: edge,
      startX: e.clientX,
      startTime: currentTutorial.annotations[index].timestamp,
      startDuration: currentTutorial.annotations[index].duration
    };
    
    document.addEventListener('mousemove', doTimelineResize);
    document.addEventListener('mouseup', stopTimelineResize);
    e.preventDefault();
  }
  
  function doTimelineResize(e) {
    if (!resizingTimelineItem) return;
    
    const dx = e.clientX - resizingTimelineItem.startX;
    const dt = (dx / timelineScale) * 1000;
    
    const ann = currentTutorial.annotations[resizingTimelineItem.index];
    
    if (resizingTimelineItem.edge === 'left') {
      // Adjust start time and duration
      let newTime = Math.max(0, resizingTimelineItem.startTime + dt);
      const diff = newTime - resizingTimelineItem.startTime;
      let newDuration = resizingTimelineItem.startDuration - diff;
      
      if (newDuration < 1000) {
        newDuration = 1000;
        newTime = resizingTimelineItem.startTime + resizingTimelineItem.startDuration - 1000;
      }
      
      ann.timestamp = newTime;
      ann.duration = newDuration;
    } else {
      // Adjust duration only
      let newDuration = Math.max(1000, resizingTimelineItem.startDuration + dt);
      ann.duration = newDuration;
    }
    
    renderTimeline();
  }
  
  function stopTimelineResize(e) {
    resizingTimelineItem = null;
    document.removeEventListener('mousemove', doTimelineResize);
    document.removeEventListener('mouseup', stopTimelineResize);
  }
  
  function seekToTime(seekTime) {
    if (!currentTutorial) return;
    
    console.log('Seeking to:', seekTime.toFixed(2) + 's');
    
    // Pause if playing
    const wasPlaying = isPlaying;
    isPlaying = false;
    
    // Set playback position
    playbackPausedAt = seekTime;
    playbackStartTime = Date.now() - seekTime * 1000;
    
    // Rebuild event queue from this point
    const tutorialStartOffset = currentTutorial.tutorialStartOffset || 0;
    const absoluteTime = seekTime * 1000 + tutorialStartOffset;
    
    // Filter events that should play from this point forward
    eventQueue = currentTutorial.events.filter(e => e.timestamp >= absoluteTime);
    
    console.log('Event queue rebuilt:', eventQueue.length, 'events from', seekTime.toFixed(2) + 's');
    
    // Update playhead position
    const playhead = document.getElementById('timelinePlayhead');
    if (playhead) {
      playhead.style.display = 'block';
      playhead.style.left = (seekTime * timelineScale) + 'px';
    }
    
    // Clear current annotation
    hideAnnotation();
    currentAnnotationIndex = -1;
    
    // Update button text
    if (playPausePreview.style.display !== 'none') {
      playPausePreview.textContent = '‚ñ∂ Resume Preview';
    }
    
    // Resume if was playing
    if (wasPlaying) {
      isPlaying = true;
      playPausePreview.textContent = '‚è∏ Pause Preview';
      requestAnimationFrame(playbackLoop);
    }
  }
  
  // Annotation editing
  function openAnnotationEditor(index) {
    if (!currentTutorial || !currentTutorial.annotations[index]) return;
    
    editingAnnotationIndex = index;
    const ann = currentTutorial.annotations[index];
    
    editAnnTitle.value = ann.title;
    editAnnText.value = ann.text;
    editAnnDuration.value = ann.duration / 1000;
    editAnnTimestamp.value = (ann.timestamp / 1000).toFixed(1);
    
    annotationEditModal.classList.add('visible');
  }
  
  saveEditAnnotation.addEventListener('click', () => {
    if (editingAnnotationIndex < 0 || !currentTutorial) return;
    
    const ann = currentTutorial.annotations[editingAnnotationIndex];
    ann.title = editAnnTitle.value.trim();
    ann.text = editAnnText.value.trim();
    ann.duration = parseFloat(editAnnDuration.value) * 1000;
    ann.timestamp = parseFloat(editAnnTimestamp.value) * 1000;
    
    annotationEditModal.classList.remove('visible');
    editingAnnotationIndex = -1;
    renderTimeline();
    
    alert('‚úì Annotation updated!');
  });
  
  deleteAnnotation.addEventListener('click', () => {
    if (editingAnnotationIndex < 0 || !currentTutorial) return;
    
    if (confirm('Delete this annotation?')) {
      currentTutorial.annotations.splice(editingAnnotationIndex, 1);
      annotationEditModal.classList.remove('visible');
      editingAnnotationIndex = -1;
      renderTimeline();
      alert('‚úì Annotation deleted!');
    }
  });
  
  repositionAnnotation.addEventListener('click', () => {
    if (editingAnnotationIndex < 0 || !currentTutorial) return;
    
    const ann = currentTutorial.annotations[editingAnnotationIndex];
    
    // Close edit modal
    annotationEditModal.classList.remove('visible');
    
    // Make sure iframe is loaded
    if (!iframeAnnotationBox) {
      initializeAnnotationBox();
    }
    
    // Show annotation for repositioning
    if (iframeAnnotationBox) {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      
      iframeAnnotationBox.className = 'tutorial-annotation-box visible draggable custom-position';
      iframeAnnotationBox.style.left = (ann.position?.left || 50) + 'px';
      iframeAnnotationBox.style.top = (ann.position?.top || 100) + 'px';
      iframeAnnotationBox.style.width = (ann.position?.width || 400) + 'px';
      iframeAnnotationBox.style.height = (ann.position?.height || 100) + 'px';
      iframeAnnotationTitle.innerHTML = ann.title;
      iframeAnnotationText.innerHTML = ann.text;
      
      // Enable dragging
      makeDraggable();
      
      // Show save button
      positionEditorOverlay.style.display = 'block';
      
      // Override savePosition to update existing annotation
      const originalSaveHandler = savePosition.onclick;
      savePosition.onclick = () => {
        const rect = iframeAnnotationBox.getBoundingClientRect();
        const iframeRect = iframeDoc.documentElement.getBoundingClientRect();
        
        ann.position = {
          left: rect.left - iframeRect.left + iframeDoc.documentElement.scrollLeft,
          top: rect.top - iframeRect.top + iframeDoc.documentElement.scrollTop,
          width: rect.width,
          height: rect.height
        };
        
        console.log('üíæ Updating annotation position:', ann.position);
        
        positionEditorOverlay.style.display = 'none';
        iframeAnnotationBox.classList.remove('visible', 'draggable');
        
        const handles = iframeAnnotationBox.querySelectorAll('.resize-handle');
        handles.forEach(h => h.remove());
        
        savePosition.onclick = originalSaveHandler;
        editingAnnotationIndex = -1;
        
        alert('‚úì Position updated!');
      };
    }
  });
  
  resizeAnnotation.addEventListener('click', () => {
    // Same as reposition but emphasize resize
    repositionAnnotation.click();
    alert('Drag the orange corner handle to resize, then Save Position');
  });
  
  cancelEditAnnotation.addEventListener('click', () => {
    annotationEditModal.classList.remove('visible');
    editingAnnotationIndex = -1;
  });
  
  // Close edit modal on outside click
  annotationEditModal.addEventListener('click', (e) => {
    if (e.target === annotationEditModal) {
      annotationEditModal.classList.remove('visible');
      editingAnnotationIndex = -1;
    }
  });
  
  // Playhead dragging
  let draggingPlayhead = false;
  
  document.addEventListener('mousedown', (e) => {
    const playhead = document.getElementById('timelinePlayhead');
    if (!playhead || !timelineVisible || !currentTutorial) return;
    
    // Check if clicking on playhead handle (the ::before pseudo-element)
    const rect = playhead.getBoundingClientRect();
    const handleX = rect.left;
    const handleY = rect.top - 8;
    const handleSize = 12;
    
    if (e.clientX >= handleX - handleSize/2 && 
        e.clientX <= handleX + handleSize/2 &&
        e.clientY >= handleY && 
        e.clientY <= handleY + handleSize) {
      draggingPlayhead = true;
      
      // Pause playback if playing
      if (isPlaying) {
        isPlaying = false;
        playPausePreview.textContent = '‚ñ∂ Resume Preview';
      }
      
      e.preventDefault();
    }
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!draggingPlayhead || !currentTutorial) return;
    
    const rulerRect = timelineRuler.getBoundingClientRect();
    const x = e.clientX - rulerRect.left;
    const seekTime = Math.max(0, Math.min(x / timelineScale, currentTutorial.duration / 1000));
    
    seekToTime(seekTime);
  });
  
  document.addEventListener('mouseup', () => {
    if (draggingPlayhead) {
      draggingPlayhead = false;
      
      // Update button text to Resume
      if (playPausePreview.style.display !== 'none') {
        playPausePreview.textContent = '‚ñ∂ Resume Preview';
      }
    }
  });
  
  // Update playhead during preview
  const originalPlaybackLoop = playbackLoop;
  function playbackLoopWithTimeline() {
    originalPlaybackLoop();
    
    if (isPlaying && timelineVisible && currentTutorial) {
      const playhead = document.getElementById('timelinePlayhead');
      if (playhead) {
        playhead.style.display = 'block';
        let realElapsed = (Date.now() - playbackStartTime) / 1000;
        playhead.style.left = (realElapsed * timelineScale) + 'px';
      }
    }
  }
})();
</script>
</body>
</html>
