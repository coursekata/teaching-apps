<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Interactive Tutorial System - Advanced</title>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [['$$', '$$']]
    },
    startup: {
      ready: () => {
        MathJax.startup.defaultReady();
      }
    }
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
  :root{
    --accent:#2563eb;
    --record:#ef4444;
    --success:#10b981;
    --warning:#f59e0b;
  }
  body{
    margin:0;
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#111;
    background:#f5f5f5;
    display:flex;
    flex-direction:column;
    height:100vh;
  }
  
  .tutorial-header{
    background:#fff;
    border-bottom:2px solid #ddd;
    padding:12px 20px;
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
  }
  
  .tutorial-controls{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }
  
  .mode-toggle{
    display:flex;
    gap:8px;
    padding:4px;
    background:#f0f0f0;
    border-radius:8px;
  }
  
  .mode-toggle button{
    padding:8px 16px;
    border-radius:6px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-weight:600;
    font-size:13px;
  }
  
  .mode-toggle button.active{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button{
    padding:8px 14px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:13px;
  }
  
  button:hover:not(:disabled):not(.primary):not(.record):not(.success):not(.warning){
    background:#f9f9f9;
  }
  
  button:disabled{
    opacity:0.5;
    cursor:not-allowed;
  }
  
  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }
  
  button.record{
    background:var(--record);
    color:#fff;
    border-color:var(--record);
  }
  
  button.success{
    background:var(--success);
    color:#fff;
    border-color:var(--success);
  }
  
  button.warning{
    background:var(--warning);
    color:#fff;
    border-color:var(--warning);
  }
  
  button.record.recording{
    animation:pulse 1.5s infinite;
  }
  
  @keyframes pulse{
    0%,100%{opacity:1}
    50%{opacity:0.6}
  }
  
  .recording-indicator{
    background:var(--record);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
    animation:pulse 1.5s infinite;
  }
  
  .paused-indicator{
    background:var(--warning);
    color:#fff;
    padding:6px 12px;
    border-radius:20px;
    font-weight:600;
    font-size:13px;
  }
  
  .playback-controls{
    display:flex;
    gap:8px;
    align-items:center;
    background:#f0f0f0;
    padding:8px;
    border-radius:8px;
  }
  
  .playback-timeline{
    flex:1;
    min-width:200px;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  
  .playback-timeline input[type=range]{
    width:100%;
    accent-color:var(--accent);
  }
  
  .time-display{
    font-size:11px;
    color:#666;
    text-align:center;
  }
  
  .app-container{
    flex:1;
    position:relative;
    overflow:hidden;
  }
  
  iframe{
    width:100%;
    height:100%;
    border:none;
  }
  
  .annotation-box{
    position:absolute;
    max-width:500px;
    background:rgba(255,255,255,0.98);
    border:3px solid var(--accent);
    border-radius:12px;
    padding:20px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15);
    z-index:100;
    display:none;
  }
  
  .annotation-box.visible{
    display:block;
    animation:slideIn 0.3s ease-out;
  }
  
  /* Position variants */
  .annotation-box.pos-top{top:20px;left:50%;transform:translateX(-50%);}
  .annotation-box.pos-bottom{bottom:20px;left:50%;transform:translateX(-50%);}
  .annotation-box.pos-left{top:50%;left:20px;transform:translateY(-50%);max-width:350px;}
  .annotation-box.pos-right{top:50%;right:20px;transform:translateY(-50%);max-width:350px;}
  .annotation-box.pos-center{top:50%;left:50%;transform:translate(-50%, -50%);}
  .annotation-box.pos-top-left{top:20px;left:20px;transform:none;max-width:400px;}
  .annotation-box.pos-top-right{top:20px;right:20px;transform:none;max-width:400px;}
  .annotation-box.pos-bottom-left{bottom:20px;left:20px;transform:none;max-width:400px;}
  .annotation-box.pos-bottom-right{bottom:20px;right:20px;transform:none;max-width:400px;}
  
  /* Draggable annotation editor */
  .annotation-box.draggable{
    cursor:move;
    border-color:var(--warning);
    border-style:dashed;
  }
  
  .annotation-box.custom-position{
    transform:none !important;
  }
  
  @keyframes slideIn{
    from{opacity:0;}
    to{opacity:1;}
  }
  
  .annotation-box h3{
    margin:0 0 12px;
    color:var(--accent);
    font-size:18px;
  }
  
  .annotation-box p{
    margin:0;
    line-height:1.6;
    font-size:15px;
  }
  
  .modal-overlay{
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(0,0,0,0.5);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:1000;
  }
  
  .modal-overlay.visible{
    display:flex;
  }
  
  .modal{
    background:#fff;
    border-radius:12px;
    padding:24px;
    max-width:700px;
    width:90%;
    max-height:80vh;
    overflow-y:auto;
    box-shadow:0 8px 32px rgba(0,0,0,0.2);
  }
  
  .modal h2{
    margin:0 0 16px;
    color:#111;
  }
  
  .modal textarea{
    width:100%;
    min-height:300px;
    max-height:400px;
    font-family:monospace;
    font-size:12px;
    padding:12px;
    border:1px solid #ddd;
    border-radius:8px;
    resize:vertical;
    overflow-y:auto;
  }
  
  .modal input[type=text]{
    width:100%;
    padding:8px 12px;
    border:1px solid #ddd;
    border-radius:8px;
    font-size:14px;
    margin-bottom:12px;
  }
  
  .modal-buttons{
    display:flex;
    gap:8px;
    margin-top:16px;
    justify-content:flex-end;
  }
  
  .help-text{
    font-size:13px;
    color:#666;
    margin:8px 0;
    line-height:1.5;
  }
  
  ol.help-text{
    margin-left:20px;
    padding-left:0;
  }
  
  ol.help-text li{
    margin:6px 0;
  }
  
  select{
    padding:6px 10px;
    border-radius:6px;
    border:1px solid #ddd;
    background:#fff;
    font-size:13px;
  }
  
  .control-group{
    display:flex;
    gap:8px;
    align-items:center;
  }
  
  label{
    font-size:12px;
    color:#666;
    display:flex;
    align-items:center;
    gap:6px;
  }
  
  input[type=text]{
    padding:6px 10px;
    border-radius:6px;
    border:1px solid #ddd;
    font-size:13px;
    width:300px;
  }
  
  .info-box{
    background:#e0f2fe;
    border:1px solid #0284c7;
    border-radius:8px;
    padding:12px;
    margin:12px 0;
    font-size:13px;
    color:#0c4a6e;
  }
  
  .info-box strong{
    color:#075985;
  }
  
  .warning-box{
    background:#fef3c7;
    border:1px solid #f59e0b;
    border-radius:8px;
    padding:12px;
    margin:12px 0;
    font-size:13px;
    color:#92400e;
  }
  
  .annotation-list{
    background:#f9fafb;
    border:1px solid #e5e7eb;
    border-radius:8px;
    padding:12px;
    margin:12px 0;
    max-height:200px;
    overflow-y:auto;
  }
  
  .annotation-item{
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:6px;
    padding:10px;
    margin-bottom:8px;
    display:flex;
    justify-content:space-between;
    align-items:center;
  }
  
  .annotation-item:last-child{
    margin-bottom:0;
  }
  
  .annotation-item-info{
    flex:1;
  }
  
  .annotation-item-title{
    font-weight:600;
    color:#111;
    margin-bottom:4px;
  }
  
  .annotation-item-meta{
    font-size:11px;
    color:#666;
  }
  
  .annotation-item-actions{
    display:flex;
    gap:6px;
  }
  
  .annotation-item-actions button{
    padding:4px 8px;
    font-size:11px;
  }
  
  .form-group{
    margin-bottom:16px;
  }
  
  .form-group label{
    display:block;
    margin-bottom:6px;
    font-weight:600;
    color:#374151;
  }
  
  .form-group textarea{
    width:100%;
    min-height:100px;
    padding:8px 12px;
    border:1px solid #ddd;
    border-radius:8px;
    font-size:14px;
    font-family:inherit;
    resize:vertical;
  }
</style>
</head>
<body>
  <div class="tutorial-header">
    <div class="tutorial-controls">
      <div class="mode-toggle">
        <button id="modeRecord" class="active">Record</button>
        <button id="modePlayback">Playback</button>
      </div>
      
      <div id="recordingControls" class="control-group">
        <label>
          App URL:
          <input type="text" id="appUrl" placeholder="Enter your app URL" value=""/>
        </label>
        <button id="loadApp" class="primary">Load App</button>
        <!-- Record Again button reloads the app completely -->
        <button id="startRecording" class="record" style="display:none;">‚è∫ Start Recording</button>
        <button id="stopRecording" class="record" style="display:none;">‚èπ Stop Recording</button>
        <button id="pauseRecording" class="warning" style="display:none;">‚è∏ Pause</button>
        <button id="resumeRecording" class="success" style="display:none;">‚ñ∂ Resume</button>
        <button id="addAnnotation" class="primary" style="display:none;" disabled>‚ûï Add Annotation</button>
        <span id="recordingIndicator" class="recording-indicator" style="display:none;">‚è∫ REC</span>
        <span id="pausedIndicator" class="paused-indicator" style="display:none;">‚è∏ PAUSED</span>
        <button id="previewRecording" class="primary" style="display:none;">üëÅ Preview</button>
        <button id="playPausePreview" class="primary" style="display:none;">‚è∏ Pause Preview</button>
        <button id="recordAgain" class="record" style="display:none;">üîÑ Record Again</button>
        <button id="exportRecording" class="success" style="display:none;">üíæ Export Tutorial</button>
      </div>
      
      <div id="playbackControls" class="playback-controls" style="display:none;">
        <button id="loadTutorialBtn" class="primary">üìÇ Load Tutorial</button>
        <button id="playBtn" style="display:none;">‚ñ∂ Play</button>
        <button id="pauseBtn" style="display:none;">‚è∏ Pause</button>
        <button id="restartBtn" style="display:none;">‚Üª Restart</button>
        <div class="playback-timeline" style="display:none;">
          <input type="range" id="timelineSlider" min="0" max="100" value="0"/>
          <div class="time-display">
            <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
          </div>
        </div>
        <label style="display:none;">
          Speed:
          <select id="playbackSpeed">
            <option value="0.5">0.5x</option>
            <option value="1" selected>1x</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x</option>
          </select>
        </label>
      </div>
      
      <div style="margin-left:auto;display:flex;gap:8px;">
        <button id="helpBtn">‚ùì Help</button>
      </div>
    </div>
  </div>
  
  <div class="app-container">
    <iframe id="appFrame" sandbox="allow-scripts allow-same-origin"></iframe>
    
    <div id="annotationBox" class="annotation-box">
      <h3 id="annotationTitle"></h3>
      <p id="annotationText"></p>
    </div>
  </div>
  
  <!-- Annotation Editor Modal -->
  <div id="annotationEditorModal" class="modal-overlay">
    <div class="modal">
      <h2>Add Annotation</h2>
      
      <div class="info-box">
        <strong>üìù Instructions:</strong> Fill in the fields below and click "Create Annotation". The annotation will appear on screen where you can drag it to position it perfectly.
      </div>
      
      <div class="form-group">
        <label>Title</label>
        <input type="text" id="annTitle" placeholder="Enter annotation title..."/>
      </div>
      
      <div class="form-group">
        <label>Text</label>
        <textarea id="annText" placeholder="Enter annotation description..."></textarea>
      </div>
      
      <div class="form-group">
        <label>Duration (seconds)</label>
        <input type="number" id="annDuration" value="5" min="1" max="60" style="width:100px;"/>
      </div>
      
      <div class="modal-buttons">
        <button id="cancelAnnotation">Cancel</button>
        <button id="createAnnotation" class="primary">‚ú® Create Annotation</button>
      </div>
    </div>
  </div>
  
  <!-- Position Editor Overlay -->
  <div id="positionEditorOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.3);z-index:99;pointer-events:none;">
    <div style="position:absolute;top:20px;left:50%;transform:translateX(-50%);background:#fff;padding:16px 24px;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.15);pointer-events:auto;">
      <div style="font-weight:600;margin-bottom:8px;color:#111;">üìç Position Your Annotation</div>
      <div style="font-size:13px;color:#666;margin-bottom:12px;">Drag the annotation box to where you want it, then click Save Position</div>
      <div style="display:flex;gap:8px;">
        <button id="savePosition" class="success">üíæ Save Position</button>
        <button id="cancelPosition">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Export Modal -->
  <div id="exportModal" class="modal-overlay">
    <div class="modal">
      <h2>Export Tutorial</h2>
      
      <div class="info-box">
        <strong>‚úì Recording Complete!</strong><br>
        Your tutorial has been recorded with <strong id="eventCount">0</strong> events and <strong id="annotationCount">0</strong> annotations.
      </div>
      
      <div id="annotationsList" class="annotation-list" style="display:none;">
        <strong style="display:block;margin-bottom:8px;">Annotations in this recording:</strong>
      </div>
      
      <p class="help-text">Copy the JSON below to save your tutorial. You can load it later using the "Load Tutorial" button.</p>
      
      <textarea id="exportTextarea" readonly></textarea>
      
      <div class="modal-buttons">
        <button id="copyExport" class="primary">üìã Copy to Clipboard</button>
        <button id="closeExportModal">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Load Modal -->
  <div id="loadModal" class="modal-overlay">
    <div class="modal">
      <h2>Load Tutorial</h2>
      
      <p class="help-text">Paste your tutorial JSON below and click "Load Tutorial".</p>
      
      <textarea id="loadTextarea" placeholder="Paste tutorial JSON here..."></textarea>
      
      <div id="loadError" class="warning-box" style="display:none;"></div>
      
      <div class="modal-buttons">
        <button id="loadTutorialSubmit" class="primary">Load Tutorial</button>
        <button id="closeLoadModal">Cancel</button>
      </div>
    </div>
  </div>
  
  <!-- Help Modal -->
  <div id="helpModal" class="modal-overlay">
    <div class="modal">
      <h2>How to Use</h2>
      
      <h3>Recording Mode:</h3>
      <ol class="help-text">
        <li><strong>Enter App URL</strong> - Type the URL of the web app you want to create a tutorial for</li>
        <li><strong>Load App</strong> - Click "Load App" to load the app in the iframe. Background recording starts automatically!</li>
        <li><strong>Set Up Your Demo</strong> - Interact with the app normally to get it ready for your tutorial (e.g., click "Simulate", set parameters, etc.). All actions are being captured!</li>
        <li><strong>Start Recording</strong> - When you're ready to begin the tutorial portion, click "‚è∫ Start Recording". This marks where the tutorial begins.</li>
        <li><strong>Interact Normally</strong> - Continue using your app. All interactions continue to be captured</li>
        <li><strong>Pause Recording</strong> - Click "‚è∏ Pause" to pause and add annotations</li>
        <li><strong>Add Annotations</strong> - While paused:
          <ul style="margin-left:20px;">
            <li>Click "‚ûï Add Annotation"</li>
            <li>Enter title, text, and duration</li>
            <li>Click "‚ú® Create Annotation"</li>
            <li>Drag the annotation box to position it exactly where you want</li>
            <li>Click "üíæ Save Position" when ready</li>
          </ul>
        </li>
        <li><strong>Resume Recording</strong> - Click "‚ñ∂ Resume" to continue recording</li>
        <li><strong>Add More Annotations</strong> - Pause again to add additional annotations as needed</li>
        <li><strong>Stop Recording</strong> - Click "‚èπ Stop Recording" when done</li>
        <li><strong>Preview</strong> - Click "üëÅ Preview" to watch the full replay (including setup actions) with annotations</li>
        <li><strong>Export</strong> - Click "üíæ Export Tutorial" to get the JSON, then copy it to save</li>
      </ol>
      
      <h3>Playback Mode:</h3>
      <ol class="help-text">
        <li><strong>Switch to Playback</strong> - Click the "Playback" tab</li>
        <li><strong>Load Tutorial</strong> - Click "üìÇ Load Tutorial" and paste your saved JSON</li>
        <li><strong>Play</strong> - Click "‚ñ∂ Play" to watch the tutorial replay with all interactions and annotations</li>
        <li><strong>Controls</strong> - Use pause, restart, timeline, and speed controls as needed</li>
      </ol>
      
      <h3>‚≠ê Best Practices:</h3>
      <ul class="help-text" style="background:#fffbeb;padding:12px;border-radius:8px;border:1px solid #fbbf24;">
        <li><strong>Set Up First:</strong> After loading the app, set it up how you want it (run simulations, set parameters, etc.) BEFORE clicking "Start Recording"</li>
        <li><strong>Mark Tutorial Start:</strong> Click "Start Recording" when you're ready to begin the instructional portion of your tutorial</li>
        <li><strong>Everything is Captured:</strong> All interactions from "Load App" onward are recorded, so your preview will show the complete workflow including setup</li>
        <li><strong>Test Your Preview:</strong> Always use "üëÅ Preview" to verify your recording plays back correctly before exporting</li>
      </ul>
      
      <div class="modal-buttons">
        <button id="closeHelpModal" class="primary">Got it!</button>
      </div>
    </div>
  </div>
  
<script>
(function() {
  'use strict';
  
  // DOM Elements
  const modeRecord = document.getElementById('modeRecord');
  const modePlayback = document.getElementById('modePlayback');
  const recordingControls = document.getElementById('recordingControls');
  const playbackControls = document.getElementById('playbackControls');
  const appUrl = document.getElementById('appUrl');
  const appFrame = document.getElementById('appFrame');
  
  const loadApp = document.getElementById('loadApp');
  const startRecording = document.getElementById('startRecording');
  const pauseRecording = document.getElementById('pauseRecording');
  const resumeRecording = document.getElementById('resumeRecording');
  const addAnnotation = document.getElementById('addAnnotation');
  const stopRecording = document.getElementById('stopRecording');
  const previewRecording = document.getElementById('previewRecording');
  const playPausePreview = document.getElementById('playPausePreview');
  const recordAgain = document.getElementById('recordAgain');
  const exportRecording = document.getElementById('exportRecording');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const pausedIndicator = document.getElementById('pausedIndicator');
  
  const annotationBox = document.getElementById('annotationBox');
  const annotationTitle = document.getElementById('annotationTitle');
  const annotationText = document.getElementById('annotationText');
  
  const annotationEditorModal = document.getElementById('annotationEditorModal');
  const annTitle = document.getElementById('annTitle');
  const annText = document.getElementById('annText');
  const annDuration = document.getElementById('annDuration');
  const createAnnotation = document.getElementById('createAnnotation');
  const cancelAnnotation = document.getElementById('cancelAnnotation');
  
  const positionEditorOverlay = document.getElementById('positionEditorOverlay');
  const savePosition = document.getElementById('savePosition');
  const cancelPosition = document.getElementById('cancelPosition');
  
  const exportModal = document.getElementById('exportModal');
  const exportTextarea = document.getElementById('exportTextarea');
  const eventCount = document.getElementById('eventCount');
  const annotationCount = document.getElementById('annotationCount');
  const annotationsList = document.getElementById('annotationsList');
  const copyExport = document.getElementById('copyExport');
  const closeExportModal = document.getElementById('closeExportModal');
  
  const loadModal = document.getElementById('loadModal');
  const loadTextarea = document.getElementById('loadTextarea');
  const loadError = document.getElementById('loadError');
  const loadTutorialBtn = document.getElementById('loadTutorialBtn');
  const loadTutorialSubmit = document.getElementById('loadTutorialSubmit');
  const closeLoadModal = document.getElementById('closeLoadModal');
  
  const helpModal = document.getElementById('helpModal');
  const helpBtn = document.getElementById('helpBtn');
  const closeHelpModal = document.getElementById('closeHelpModal');
  
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const timelineSlider = document.getElementById('timelineSlider');
  const currentTimeEl = document.getElementById('currentTime');
  const totalTimeEl = document.getElementById('totalTime');
  const playbackSpeedSelect = document.getElementById('playbackSpeed');
  
  // State
  let currentMode = 'record';
  let isRecording = false;
  let isPaused = false;
  let recordingStartTime = 0;
  let pausedTime = 0;
  let totalPausedDuration = 0;
  let recordedEvents = [];
  let recordedAnnotations = [];
  let currentAnnotation = null;
  let draggingAnnotation = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let initialInputValues = {}; // Capture input values at start of recording
  
  // Always-on recording state
  let alwaysRecording = false;
  let alwaysRecordedEvents = [];
  let appLoadTime = 0;
  let tutorialStartTime = 0; // When user clicks "Start Recording"
  
  let currentTutorial = null;
  let isPlaying = false;
  let playbackStartTime = 0;
  let playbackPausedAt = 0;
  let playbackSpeed = 1;
  let eventQueue = [];
  let currentAnnotationIndex = -1;
  
  // Mode switching
  modeRecord.addEventListener('click', () => {
    currentMode = 'record';
    modeRecord.classList.add('active');
    modePlayback.classList.remove('active');
    recordingControls.style.display = 'flex';
    playbackControls.style.display = 'none';
  });
  
  modePlayback.addEventListener('click', () => {
    currentMode = 'playback';
    modePlayback.classList.add('active');
    modeRecord.classList.remove('active');
    recordingControls.style.display = 'none';
    playbackControls.style.display = 'flex';
  });
  
  // Recording controls
  loadApp.addEventListener('click', () => {
    const url = appUrl.value.trim();
    if (!url) {
      alert('Please enter an app URL first!');
      return;
    }
    
    // Load the app
    appFrame.src = url;
    
    // Wait for iframe to load, then start always-on recording
    appFrame.onload = () => {
      appLoadTime = Date.now();
      alwaysRecordedEvents = [];
      alwaysRecording = true;
      
      // Start capturing events immediately
      setTimeout(() => {
        setupEventListeners();
        console.log('‚úì App loaded - background recording started');
      }, 500);
    };
    
    // Update UI
    loadApp.style.display = 'none';
    startRecording.style.display = 'inline-block';
    appUrl.disabled = true;
    
    console.log('‚úì Loading app:', url);
  });
  
  
  startRecording.addEventListener('click', () => {
    if (!alwaysRecording) {
      alert('Please load an app first!');
      return;
    }
    
    // Mark this as the tutorial start point
    tutorialStartTime = Date.now();
    
    // Reset tutorial-specific state
    recordedAnnotations = [];
    totalPausedDuration = 0;
    isRecording = true;
    isPaused = false;
    recordingStartTime = tutorialStartTime;
    
    console.log('‚úì Tutorial start marked -', alwaysRecordedEvents.length, 'events already captured');
    console.log('  Time since app load:', (tutorialStartTime - appLoadTime) / 1000, 'seconds');
    
    // Update UI
    startRecording.style.display = 'none';
    pauseRecording.style.display = 'inline-block';
    stopRecording.style.display = 'inline-block';
    recordingIndicator.style.display = 'inline-block';
    
    console.log('‚úì Tutorial recording started (annotations and pauses will be tracked from here)');
  });
  
  pauseRecording.addEventListener('click', () => {
    isPaused = true;
    pausedTime = Date.now();
    
    pauseRecording.style.display = 'none';
    resumeRecording.style.display = 'inline-block';
    addAnnotation.style.display = 'inline-block';
    addAnnotation.disabled = false;
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'inline-block';
    
    console.log('‚è∏ Recording paused');
  });
  
  resumeRecording.addEventListener('click', () => {
    const pauseDuration = Date.now() - pausedTime;
    totalPausedDuration += pauseDuration;
    isPaused = false;
    
    resumeRecording.style.display = 'none';
    pauseRecording.style.display = 'inline-block';
    addAnnotation.style.display = 'none';
    pausedIndicator.style.display = 'none';
    recordingIndicator.style.display = 'inline-block';
    
    // If annotation is already visible (from save position), just keep it visible
    // Otherwise show the most recent annotation
    if (recordedAnnotations.length > 0 && !annotationBox.classList.contains('visible')) {
      const mostRecentAnn = recordedAnnotations[recordedAnnotations.length - 1];
      
      // Display the annotation
      showAnnotation(mostRecentAnn);
      
      // Hide it after its duration
      setTimeout(() => {
        annotationBox.classList.remove('visible');
      }, mostRecentAnn.duration);
      
      console.log('‚ñ∂ Recording resumed - showing annotation for', mostRecentAnn.duration, 'ms');
    } else if (annotationBox.classList.contains('visible')) {
      // Annotation already visible, set timer to hide it after duration
      const mostRecentAnn = recordedAnnotations[recordedAnnotations.length - 1];
      setTimeout(() => {
        annotationBox.classList.remove('visible');
      }, mostRecentAnn.duration);
      
      console.log('‚ñ∂ Recording resumed - annotation already visible, will hide after', mostRecentAnn.duration, 'ms');
    } else {
      console.log('‚ñ∂ Recording resumed (paused for', pauseDuration, 'ms)');
    }
  });
  
  stopRecording.addEventListener('click', () => {
    isRecording = false;
    isPaused = false;
    alwaysRecording = false; // Stop capturing new events
    
    // Close annotation positioning overlay if active (don't save incomplete annotation)
    if (positionEditorOverlay.style.display !== 'none') {
      positionEditorOverlay.style.display = 'none';
      annotationBox.classList.remove('visible', 'draggable');
      pendingAnnotation = null;
      console.log('‚ö† Discarded unsaved annotation due to stop recording');
    }
    
    // Clean up any active drag capture
    if (isDragging) {
      isDragging = false;
      if (dragCheckInterval) {
        cancelAnimationFrame(dragCheckInterval);
        dragCheckInterval = null;
      }
      if (mouseUpHandler) {
        try {
          const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
          if (iframeDoc) iframeDoc.removeEventListener('mouseup', mouseUpHandler, true);
          document.removeEventListener('mouseup', mouseUpHandler, true);
        } catch (e) {
          console.warn('Error cleaning up listeners:', e);
        }
        mouseUpHandler = null;
      }
      dragElement = null;
      dragStartSnapshot = null;
    }
    
    // Calculate tutorial start offset (time from app load to "Start Recording" click)
    const tutorialStartOffset = tutorialStartTime - appLoadTime;
    
    // Calculate tutorial duration (from "Start Recording" to "Stop Recording")
    const tutorialDuration = Date.now() - tutorialStartTime - totalPausedDuration;
    
    pauseRecording.style.display = 'none';
    resumeRecording.style.display = 'none';
    addAnnotation.style.display = 'none';
    stopRecording.style.display = 'none';
    startRecording.style.display = 'none';
    previewRecording.style.display = 'inline-block';
    recordAgain.style.display = 'inline-block';
    exportRecording.style.display = 'inline-block';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    // reloadApp stays visible
    
    // Build tutorial JSON with ALL events (from app load) and tutorial start marker
    const tutorial = {
      appUrl: appUrl.value.trim(),
      tutorialStartOffset: tutorialStartOffset,  // When to start showing annotations
      duration: tutorialDuration,  // Duration from Start to Stop
      events: alwaysRecordedEvents,  // ALL events from app load
      annotations: recordedAnnotations
    };
    
    currentTutorial = tutorial;
    
    console.log('‚úì Recording stopped.');
    console.log('  Total events captured:', alwaysRecordedEvents.length);
    console.log('  Events before tutorial start:', alwaysRecordedEvents.filter(e => e.timestamp < tutorialStartOffset).length);
    console.log('  Tutorial start offset:', tutorialStartOffset, 'ms');
    console.log('  Tutorial duration:', tutorialDuration, 'ms');
    console.log('  Annotations:', recordedAnnotations.length);
  });
  
  recordAgain.addEventListener('click', () => {
    // Stop any active playback
    isPlaying = false;
    
    // Hide any visible annotations
    annotationBox.classList.remove('visible');
    currentAnnotationIndex = -1;
    
    // Reload the app to go back to clean state
    const url = appFrame.src;
    if (!url || url === 'about:blank') {
      console.warn('No URL to reload');
      return;
    }
    
    console.log('üîÑ Record Again - reloading app to start fresh');
    
    // Clear tutorial-specific data
    recordedAnnotations = [];
    currentTutorial = null;
    totalPausedDuration = 0;
    
    // Reload iframe
    appFrame.src = '';
    
    setTimeout(() => {
      appFrame.src = url;
      
      // Setup onload to restart always-on recording
      appFrame.onload = () => {
        appLoadTime = Date.now();
        alwaysRecordedEvents = [];
        alwaysRecording = true;
        
        setTimeout(() => {
          setupEventListeners();
          console.log('‚úì App reloaded - ready to record again from beginning');
        }, 500);
      };
    }, 100);
    
    // Reset UI for new recording
    startRecording.style.display = 'inline-block';
    stopRecording.style.display = 'none';
    pauseRecording.style.display = 'none';
    resumeRecording.style.display = 'none';
    addAnnotation.style.display = 'none';
    recordingIndicator.style.display = 'none';
    pausedIndicator.style.display = 'none';
    previewRecording.style.display = 'none';
    playPausePreview.style.display = 'none';
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
  });
  
  exportRecording.addEventListener('click', () => {
    if (!currentTutorial) {
      alert('No recording to export!');
      return;
    }
    
    // Show export modal
    const json = JSON.stringify(currentTutorial, null, 2);
    exportTextarea.value = json;
    eventCount.textContent = currentTutorial.events.length;
    annotationCount.textContent = currentTutorial.annotations.length;
    
    // Show annotation list
    if (currentTutorial.annotations && currentTutorial.annotations.length > 0) {
      annotationsList.style.display = 'block';
      annotationsList.innerHTML = '<strong style="display:block;margin-bottom:8px;">Annotations in this recording:</strong>';
      currentTutorial.annotations.forEach((ann, idx) => {
        const item = document.createElement('div');
        item.className = 'annotation-item';
        const posText = ann.position ? `(${Math.round(ann.position.left)}, ${Math.round(ann.position.top)})` : 'custom';
        item.innerHTML = `
          <div class="annotation-item-info">
            <div class="annotation-item-title">${ann.title}</div>
            <div class="annotation-item-meta">At ${formatTime(ann.timestamp / 1000)} ‚Ä¢ ${ann.duration / 1000}s ‚Ä¢ Position ${posText}</div>
          </div>
        `;
        annotationsList.appendChild(item);
      });
    } else {
      annotationsList.style.display = 'none';
    }
    
    exportModal.classList.add('visible');
  });
  
  // Annotation authoring
  let pendingAnnotation = null;
  
  // Preview functionality
  
  playPausePreview.addEventListener('click', () => {
    if (!currentTutorial) return;
    
    if (!isPlaying) {
      // Start/resume playback
      isPlaying = true;
      
      if (playbackPausedAt > 0) {
        playbackStartTime = Date.now() - playbackPausedAt * 1000;
      } else {
        playbackStartTime = Date.now();
        eventQueue = [...currentTutorial.events];
      }
      
      requestAnimationFrame(playbackLoop);
      console.log('‚ñ∂ Preview playing');
    } else {
      // Pause playback
      isPlaying = false;
      playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
      console.log('‚è∏ Preview paused');
    }
  });
  
  addAnnotation.addEventListener('click', () => {
    // Reset form
    annTitle.value = '';
    annText.value = '';
    annDuration.value = '5';
    
    annotationEditorModal.classList.add('visible');
  });
  
  createAnnotation.addEventListener('click', () => {
    const title = annTitle.value.trim();
    const text = annText.value.trim();
    const duration = parseInt(annDuration.value) * 1000;
    
    if (!title || !text) {
      alert('Please enter both title and text for the annotation!');
      return;
    }
    
    // Calculate timestamp relative to tutorial start
    // This is: pausedTime - tutorialStartTime - totalPausedDuration
    const timestamp = pausedTime - tutorialStartTime - totalPausedDuration;
    
    // Create pending annotation
    pendingAnnotation = {
      timestamp: timestamp,
      title: title,
      text: text,
      duration: duration,
      position: null
    };
    
    // Close modal
    annotationEditorModal.classList.remove('visible');
    
    // Show annotation in center of screen for positioning
    annotationBox.className = 'annotation-box visible draggable custom-position';
    annotationBox.style.left = '50%';
    annotationBox.style.top = '50%';
    annotationBox.style.transform = 'translate(-50%, -50%)';
    annotationTitle.innerHTML = title;
    annotationText.innerHTML = text;
    
    // Trigger MathJax to process the preview
    if (typeof MathJax !== 'undefined') {
      if (MathJax.typesetPromise) {
        MathJax.typesetPromise([annotationBox]).catch((err) => console.warn('MathJax error:', err));
      } else if (MathJax.typeset) {
        MathJax.typeset([annotationBox]);
      }
    }
    
    // Show positioning overlay
    positionEditorOverlay.style.display = 'block';
    
    // Enable dragging
    makeDraggable();
    
    console.log('‚úì Annotation created at timestamp:', timestamp, 'ms - now position it...');
  });
  
  cancelAnnotation.addEventListener('click', () => {
    annotationEditorModal.classList.remove('visible');
  });
  
  savePosition.addEventListener('click', () => {
    if (!pendingAnnotation) return;
    
    // Get current position
    const containerRect = appFrame.getBoundingClientRect();
    const rect = annotationBox.getBoundingClientRect();
    
    pendingAnnotation.position = {
      left: rect.left - containerRect.left,
      top: rect.top - containerRect.top
    };
    
    // Save to recordings
    recordedAnnotations.push(pendingAnnotation);
    
    console.log('‚úì Annotation saved:', pendingAnnotation);
    
    // Clean up positioning overlay but KEEP annotation visible
    positionEditorOverlay.style.display = 'none';
    annotationBox.classList.remove('draggable'); // Remove draggable but keep visible
    pendingAnnotation = null;
    
    // Keep showing Resume button (don't auto-resume)
    // User can click Resume when ready
    
    alert(`‚úì Annotation "${recordedAnnotations[recordedAnnotations.length - 1].title}" saved! Click Resume to continue recording.`);
  });
  
  cancelPosition.addEventListener('click', () => {
    positionEditorOverlay.style.display = 'none';
    annotationBox.classList.remove('visible', 'draggable');
    pendingAnnotation = null;
    console.log('Annotation positioning cancelled');
  });
  
  // Preview functionality
  previewRecording.addEventListener('click', async () => {
    if (!currentTutorial) {
      alert('No recording to preview!');
      return;
    }
    
    // Stop any active playback
    isPlaying = false;
    
    // Hide any visible annotations and reset annotation state
    annotationBox.classList.remove('visible');
    currentAnnotationIndex = -1;
    
    // Show preview controls
    previewRecording.style.display = 'none';
    playPausePreview.style.display = 'inline-block';
    playPausePreview.textContent = '‚è∏ Pause Preview';
    recordAgain.style.display = 'none';
    exportRecording.style.display = 'none';
    
    // Reload the iframe to reset to clean state
    const appUrl = currentTutorial.appUrl;
    appFrame.src = '';
    
    await new Promise(resolve => {
      setTimeout(() => {
        appFrame.src = appUrl;
        
        appFrame.onload = async () => {
          console.log('‚úì App reloaded for preview');
          
          // Wait for app to initialize
          await new Promise(r => setTimeout(r, 500));
          
          console.log('‚úì Starting preview - will replay ALL', currentTutorial.events.length, 'events from app load');
          console.log('  Tutorial starts at:', currentTutorial.tutorialStartOffset, 'ms');
          console.log('  Annotations will appear from that point forward');
          
          // Start playback of ALL events from beginning
          fastForwardComplete = false;
          isPlaying = true;
          playbackPausedAt = 0;
          playbackStartTime = Date.now();
          eventQueue = [...currentTutorial.events];
          requestAnimationFrame(playbackLoop);
          
          resolve();
        };
      }, 100);
    });
  });
  
  playPausePreview.addEventListener('click', () => {
    if (isPlaying) {
      // Pause preview
      isPlaying = false;
      playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
      playPausePreview.textContent = '‚ñ∂ Resume Preview';
      console.log('‚è∏ Preview paused');
    } else {
      // Resume preview
      isPlaying = true;
      playbackStartTime = Date.now() - playbackPausedAt * 1000;
      playPausePreview.textContent = '‚è∏ Pause Preview';
      requestAnimationFrame(playbackLoop);
      console.log('‚ñ∂ Preview resumed');
    }
  });
  
  // Dragging functionality
  function makeDraggable() {
    annotationBox.addEventListener('mousedown', startDrag);
  }
  
  function startDrag(e) {
    if (!annotationBox.classList.contains('draggable')) return;
    
    draggingAnnotation = true;
    const rect = annotationBox.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;
    
    document.addEventListener('mousemove', doDrag);
    document.addEventListener('mouseup', stopDrag);
    
    e.preventDefault();
  }
  
  function doDrag(e) {
    if (!draggingAnnotation) return;
    
    const containerRect = appFrame.getBoundingClientRect();
    let x = e.clientX - containerRect.left - dragOffsetX;
    let y = e.clientY - containerRect.top - dragOffsetY;
    
    // Keep within bounds
    x = Math.max(0, Math.min(x, containerRect.width - annotationBox.offsetWidth));
    y = Math.max(0, Math.min(y, containerRect.height - annotationBox.offsetHeight));
    
    annotationBox.style.left = x + 'px';
    annotationBox.style.top = y + 'px';
    annotationBox.style.transform = 'none';
    
    e.preventDefault();
  }
  
  function stopDrag(e) {
    draggingAnnotation = false;
    document.removeEventListener('mousemove', doDrag);
    document.removeEventListener('mouseup', stopDrag);
  }
  
  // Event recording setup
  function setupEventListeners() {
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      
      iframeDoc.addEventListener('click', handleClick, true);
      iframeDoc.addEventListener('input', handleInput, true);
      iframeDoc.addEventListener('change', handleChange, true);
      iframeDoc.addEventListener('mousedown', handleMouseDown, true);
      
      console.log('‚úì Event listeners attached to iframe');
    } catch (e) {
      console.error('Failed to attach event listeners:', e);
      alert('Could not access the app. Make sure it allows embedding and doesn\'t have cross-origin restrictions.');
    }
  }
  
  function getTimestamp() {
    return Date.now() - appLoadTime;
  }
  
  function handleClick(e) {
    if (!alwaysRecording) return;
    
    // Skip clicks that will be handled by drag - check if this is on a draggable SVG element
    let element = e.target;
    let isDraggableClick = false;
    
    while (element && element !== e.currentTarget) {
      // Check for SVG draggable elements only
      if (element.tagName === 'circle' || 
          element.tagName === 'rect' || 
          element.tagName === 'line' ||
          element.tagName === 'path' ||
          element.classList.contains('draggable-veil')) {
        isDraggableClick = true;
        break;
      }
      element = element.parentElement;
    }
    
    if (isDraggableClick) {
      console.log('Skipping click on draggable SVG element');
      return; // Skip - this will be handled by drag recording
    }
    
    // Find the actual interactive element (button, input, etc.)
    // Walk up the tree to find BUTTON or element with onclick or ID
    let targetElement = e.target;
    while (targetElement && targetElement !== e.currentTarget) {
      if (targetElement.tagName === 'BUTTON' || 
          targetElement.tagName === 'INPUT' ||
          targetElement.tagName === 'SELECT' ||
          targetElement.tagName === 'A' ||
          targetElement.id) { // Stop if we find an element with an ID
        // Found the interactive element
        break;
      }
      targetElement = targetElement.parentElement;
    }
    
    // If we didn't find a specific interactive element, use the original target
    if (!targetElement || targetElement === e.currentTarget) {
      targetElement = e.target;
    }
    
    const selector = generateSelector(targetElement);
    if (!selector) return;
    
    alwaysRecordedEvents.push({
      type: 'click',
      timestamp: getTimestamp(),
      target: selector
    });
    
    console.log('‚úì Recorded click on:', targetElement.tagName, targetElement.id || targetElement.className, '‚Üí selector:', selector);
  }
  
  function handleInput(e) {
    if (!alwaysRecording) return;
    
    const selector = generateSelector(e.target);
    if (!selector) return;
    
    alwaysRecordedEvents.push({
      type: 'input',
      timestamp: getTimestamp(),
      target: selector,
      detail: { value: e.target.value }
    });
  }
  
  function handleChange(e) {
    if (!alwaysRecording) return;
    
    const selector = generateSelector(e.target);
    if (!selector) return;
    
    alwaysRecordedEvents.push({
      type: 'change',
      timestamp: getTimestamp(),
      target: selector,
      detail: { value: e.target.value }
    });
  }
  
  let dragElement = null;
  let dragStartTime = 0;
  let dragStartSnapshot = null;
  let dragCheckInterval = null;
  let isDragging = false;
  let mouseUpHandler = null;
  
  function handleMouseDown(e) {
    if (!alwaysRecording) return;
    
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      if (!iframeDoc) return;
      
      // Check if the target or any parent is draggable
      let element = e.target;
      let draggable = null;
      
      while (element && element !== iframeDoc.body) {
        // Check for various draggable indicators
        const computedStyle = window.getComputedStyle(element);
        const cursor = computedStyle.cursor;
        
        if (element.draggable || 
            element.classList.contains('draggable-veil') ||
            element.tagName === 'circle' || 
            element.tagName === 'rect' || 
            element.tagName === 'line' ||
            element.tagName === 'path' ||
            element.tagName === 'g' && (cursor === 'grab' || cursor === 'move' || cursor === 'pointer')) {
          draggable = element;
          break;
        }
        element = element.parentElement;
      }
      
      if (!draggable) return;
      
      isDragging = true;
      dragElement = draggable;
      dragStartTime = Date.now();
      
      // Take snapshots continuously during the drag
      dragStartSnapshot = {
        startX: e.clientX,
        startY: e.clientY,
        frames: [
          {
            time: 0,
            x: e.clientX,
            y: e.clientY,
            html: iframeDoc.body.innerHTML
          }
        ]
      };
      
      // Track mouse position during drag
      let lastMouseX = e.clientX;
      let lastMouseY = e.clientY;
      
      // Capture mousemove events to track position
      const trackMouseMove = (moveEvent) => {
        if (isDragging) {
          lastMouseX = moveEvent.clientX;
          lastMouseY = moveEvent.clientY;
        }
      };
      iframeDoc.addEventListener('mousemove', trackMouseMove, true);
      
      // Use requestAnimationFrame to capture smooth continuous frames during drag
      let animationFrameId;
      const captureFrame = () => {
        if (isDragging) {
          const currentTime = Date.now() - dragStartTime;
          dragStartSnapshot.frames.push({
            time: currentTime,
            x: lastMouseX,
            y: lastMouseY,
            html: iframeDoc.body.innerHTML
          });
          animationFrameId = requestAnimationFrame(captureFrame);
        }
      };
      
      // Start capturing frames continuously
      animationFrameId = requestAnimationFrame(captureFrame);
      
      // Store the animation frame ID so we can cancel it on mouseup
      dragCheckInterval = animationFrameId;
      
      console.log('üñ±Ô∏è Drag started on', dragElement.tagName, dragElement.className, '- capturing animation frames...');
      
      // Create mouseup handler function
      mouseUpHandler = function handleMouseUp(upEvent) {
        console.log('üñ±Ô∏è mouseup detected, isDragging:', isDragging);
        
        if (!isDragging || !dragElement) return;
        
        // Stop capturing frames - cancel the animation frame
        if (dragCheckInterval) {
          cancelAnimationFrame(dragCheckInterval);
          dragCheckInterval = null;
        }
        
        // CRITICAL: Capture the current recording state NOW
        const capturedDragElement = dragElement;
        const capturedSnapshot = dragStartSnapshot;
        const capturedStartTime = dragStartTime;
        
        // Clear drag state immediately
        isDragging = false;
        dragElement = null;
        dragStartSnapshot = null;
        
        // Remove listeners
        iframeDoc.removeEventListener('mouseup', mouseUpHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        iframeDoc.removeEventListener('mousemove', trackMouseMove, true);
        mouseUpHandler = null;
        
        if (!capturedSnapshot) {
          console.log('Drag ended but no snapshot');
          return;
        }
        
        try {
          // Add final frame with mouseup position
          capturedSnapshot.frames.push({
            time: Date.now() - capturedStartTime,
            x: upEvent.clientX,
            y: upEvent.clientY,
            html: iframeDoc.body.innerHTML
          });
          
          console.log('  üìä Drag captured:', capturedSnapshot.frames.length, 'frames');
          console.log('    Start:', capturedSnapshot.frames[0].x, capturedSnapshot.frames[0].y);
          console.log('    End:', capturedSnapshot.frames[capturedSnapshot.frames.length - 1].x, 
                                 capturedSnapshot.frames[capturedSnapshot.frames.length - 1].y);
          
          const selector = generateSelector(capturedDragElement);
          const dragDuration = Date.now() - capturedStartTime;
          
          alwaysRecordedEvents.push({
            type: 'drag',
            timestamp: getTimestamp() - dragDuration,
            target: selector,
            detail: {
              duration: dragDuration,
              animationFrames: capturedSnapshot.frames
            }
          });
          
          console.log('‚úì Drag recorded:', selector, 'with', capturedSnapshot.frames.length, 'frames, duration:', dragDuration, 'ms');
          
        } catch (e) {
          console.warn('Error recording drag:', e);
        }
      };
      
      // Add mouseup listener to BOTH iframe document AND main document
      // This ensures we catch the mouseup even if D3 prevents bubbling
      iframeDoc.addEventListener('mouseup', mouseUpHandler, true); // Use capture phase
      document.addEventListener('mouseup', mouseUpHandler, true); // Backup listener
      
    } catch (e) {
      console.warn('Cannot handle mousedown:', e);
    }
  }
  
  function generateSelector(element) {
    if (!element) return null;
    
    if (element.id) {
      return '#' + element.id;
    }
    
    // For buttons with data attributes (like data-curve, data-power), use those for identification
    if (element.tagName === 'BUTTON') {
      const dataAttrs = Array.from(element.attributes)
        .filter(attr => attr.name.startsWith('data-'))
        .map(attr => `[${attr.name}="${attr.value}"]`);
      
      if (dataAttrs.length > 0) {
        return 'button' + dataAttrs.join('');
      }
    }
    
    // For elements with specific classes, use class selector
    if (element.className && typeof element.className === 'string') {
      const classes = element.className.trim().split(/\s+/).filter(c => c);
      if (classes.length > 0) {
        // For SVG elements with meaningful class names, use tag + class
        return element.tagName.toLowerCase() + '.' + classes.join('.');
      }
    } else if (element.className && element.className.baseVal) {
      // SVG elements have className as an object
      const classes = element.className.baseVal.trim().split(/\s+/).filter(c => c);
      if (classes.length > 0) {
        return element.tagName.toLowerCase() + '.' + classes.join('.');
      }
    }
    
    if (element.tagName === 'BUTTON' && element.textContent) {
      return {
        type: 'button-text',
        tagName: 'button',
        text: element.textContent.trim()
      };
    }
    
    let path = [];
    let current = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.className) {
        let classes;
        if (typeof current.className === 'string') {
          classes = current.className.split(' ').filter(c => c);
        } else if (current.className.baseVal) {
          classes = current.className.baseVal.split(' ').filter(c => c);
        }
        if (classes && classes.length > 0) {
          selector += '.' + classes.join('.');
        }
      }
      
      let parent = current.parentElement;
      if (parent) {
        let siblings = Array.from(parent.children).filter(e => e.tagName === current.tagName);
        if (siblings.length > 1) {
          let index = siblings.indexOf(current);
          selector += ':nth-of-type(' + (index + 1) + ')';
        }
      }
      
      path.unshift(selector);
      current = parent;
    }
    
    return path.join(' > ');
  }
  
  // Export controls
  copyExport.addEventListener('click', () => {
    exportTextarea.select();
    document.execCommand('copy');
    copyExport.textContent = '‚úì Copied!';
    setTimeout(() => {
      copyExport.textContent = 'üìã Copy to Clipboard';
    }, 2000);
  });
  
  closeExportModal.addEventListener('click', () => {
    exportModal.classList.remove('visible');
  });
  
  // Load tutorial
  loadTutorialBtn.addEventListener('click', () => {
    loadModal.classList.add('visible');
    loadError.style.display = 'none';
  });
  
  loadTutorialSubmit.addEventListener('click', () => {
    const jsonText = loadTextarea.value.trim();
    if (!jsonText) {
      loadError.textContent = 'Please paste tutorial JSON!';
      loadError.style.display = 'block';
      return;
    }
    
    try {
      currentTutorial = JSON.parse(jsonText);
      
      if (!currentTutorial.appUrl) {
        throw new Error('Missing "appUrl" field');
      }
      if (!currentTutorial.events) {
        throw new Error('Missing "events" field');
      }
      if (currentTutorial.duration === undefined) {
        throw new Error('Missing "duration" field');
      }
      
      appFrame.src = currentTutorial.appUrl;
      
      const duration = currentTutorial.duration / 1000;
      totalTimeEl.textContent = formatTime(duration);
      timelineSlider.max = duration;
      timelineSlider.value = 0;
      currentTimeEl.textContent = '0:00';
      playbackPausedAt = 0;
      playbackStartTime = 0;
      
      // Show playback controls
      loadTutorialBtn.style.display = 'none';
      playBtn.style.display = 'inline-block';
      restartBtn.style.display = 'inline-block';
      document.querySelector('.playback-timeline').style.display = 'flex';
      document.querySelector('label[style*="display:none"]').style.display = 'flex';
      
      loadModal.classList.remove('visible');
      loadTextarea.value = '';
      
      alert('‚úì Tutorial loaded! Click Play (‚ñ∂) to start.');
      
    } catch (e) {
      loadError.textContent = 'Invalid JSON! Error: ' + e.message + '\n\nMake sure you copied the entire JSON correctly.';
      loadError.style.display = 'block';
      console.error('JSON parse error:', e);
    }
  });
  
  closeLoadModal.addEventListener('click', () => {
    loadModal.classList.remove('visible');
  });
  
  // Playback
  playBtn.addEventListener('click', () => {
    if (!currentTutorial) {
      alert('Please load a tutorial first!');
      return;
    }
    
    isPlaying = true;
    playBtn.style.display = 'none';
    pauseBtn.style.display = 'inline-block';
    
    if (playbackPausedAt > 0) {
      playbackStartTime = Date.now() - playbackPausedAt * 1000;
    } else {
      playbackStartTime = Date.now();
      eventQueue = [...currentTutorial.events];
      console.log('‚úì Starting playback with', eventQueue.length, 'events');
    }
    
    requestAnimationFrame(playbackLoop);
  });
  
  pauseBtn.addEventListener('click', () => {
    isPlaying = false;
    playBtn.style.display = 'inline-block';
    pauseBtn.style.display = 'none';
    playbackPausedAt = (Date.now() - playbackStartTime) / 1000;
  });
  
  restartBtn.addEventListener('click', () => {
    isPlaying = false;
    playBtn.style.display = 'inline-block';
    pauseBtn.style.display = 'none';
    playbackPausedAt = 0;
    playbackStartTime = 0;
    timelineSlider.value = 0;
    currentTimeEl.textContent = '0:00';
    currentAnnotationIndex = -1;
    annotationBox.classList.remove('visible');
    eventQueue = [];
    
    const url = appFrame.src;
    appFrame.src = '';
    setTimeout(() => { appFrame.src = url; }, 100);
  });
  
  playbackSpeedSelect.addEventListener('change', () => {
    playbackSpeed = parseFloat(playbackSpeedSelect.value);
  });
  
  timelineSlider.addEventListener('input', () => {
    if (isPlaying) return;
    playbackPausedAt = parseFloat(timelineSlider.value);
    currentTimeEl.textContent = formatTime(playbackPausedAt);
  });
  
  let fastForwardComplete = false;
  let activeDragAnimation = null; // Track if a drag animation is in progress
  
  function playbackLoop() {
    if (!isPlaying) return;
    
    const realElapsed = (Date.now() - playbackStartTime) / 1000;
    
    // Calculate tutorial start point and total duration
    const tutorialStartSec = (currentTutorial.tutorialStartOffset || 0) / 1000;
    const tutorialDurationSec = currentTutorial.duration / 1000;
    const totalDuration = tutorialDurationSec; // Only count tutorial duration, not setup time
    
    // Adjusted elapsed time: skip the tutorial start offset
    // This makes the tutorial portion start immediately after fast-forward
    const elapsed = realElapsed + tutorialStartSec;
    
    // Update timeline only if in full playback mode (not preview)
    if (playbackControls.style.display !== 'none') {
      timelineSlider.value = realElapsed; // Show only tutorial time on timeline
      currentTimeEl.textContent = formatTime(realElapsed);
    }
    
    // Process events with fast-forward logic:
    // - Events before tutorial start: replay immediately (no waiting)
    // - Events after tutorial start: replay at normal speed
    let justCompletedFastForward = false;
    while (eventQueue.length > 0) {
      const event = eventQueue[0];
      const eventTimeSec = event.timestamp / 1000;
      
      // If event is before tutorial start, replay it immediately (fast-forward)
      if (eventTimeSec < tutorialStartSec) {
        eventQueue.shift();
        replayEvent(event);
        
        // Check if this was the last fast-forward event
        if (eventQueue.length > 0 && eventQueue[0].timestamp / 1000 >= tutorialStartSec) {
          justCompletedFastForward = true;
          fastForwardComplete = true;
          console.log('‚è© Fast-forward complete - pausing 100ms for app to settle...');
          // Pause briefly to let the app's state settle
          setTimeout(() => {
            playbackStartTime = Date.now(); // Reset start time so tutorial plays from now
            requestAnimationFrame(playbackLoop);
          }, 100);
          return;
        }
        continue; // Process next event immediately
      }
      
      // If event is after tutorial start, check if it's time to replay it
      if (eventTimeSec <= elapsed) {
        eventQueue.shift();
        replayEvent(event);
      } else {
        // Event is in the future, wait for it
        break;
      }
    }
    
    // Handle annotations - only show after tutorial start offset
    if (realElapsed >= 0) { // Tutorial time (since we've already fast-forwarded setup)
      currentTutorial.annotations.forEach((ann, idx) => {
        const annStart = ann.timestamp / 1000;
        const annEnd = annStart + (ann.duration || 5000) / 1000;
        
        if (realElapsed >= annStart && realElapsed < annEnd && currentAnnotationIndex !== idx) {
          currentAnnotationIndex = idx;
          showAnnotation(ann);
        } else if (realElapsed >= annEnd && currentAnnotationIndex === idx) {
          annotationBox.classList.remove('visible');
          currentAnnotationIndex = -1;
        }
      });
    }
    
    if (realElapsed >= totalDuration) {
      // Don't end yet if there's an active drag animation
      if (activeDragAnimation) {
        console.log('‚è≥ Waiting for drag animation to complete...');
        requestAnimationFrame(playbackLoop);
        return;
      }
      
      isPlaying = false;
      
      // Hide any visible annotations
      annotationBox.classList.remove('visible');
      currentAnnotationIndex = -1;
      
      // If this was a preview (playPausePreview visible), just stop - leave final state visible
      if (playPausePreview.style.display !== 'none') {
        playPausePreview.style.display = 'none';
        playPausePreview.textContent = '‚è∏ Pause Preview';
        previewRecording.style.display = 'inline-block';
        recordAgain.style.display = 'inline-block';
        exportRecording.style.display = 'inline-block';
        
        console.log('‚úì Preview finished - final state visible');
      } else {
        // Normal playback mode
        playBtn.style.display = 'inline-block';
        pauseBtn.style.display = 'none';
      }
      
      return;
    }
    
    requestAnimationFrame(playbackLoop);
  }
  
  function replayEvent(event) {
    try {
      const iframeDoc = appFrame.contentDocument || appFrame.contentWindow.document;
      const element = findElement(iframeDoc, event.target);
      
      if (!element) {
        console.warn('‚ùå Element not found for replay:', event.target);
        return;
      }
      
      console.log('‚ñ∂ Replaying', event.type, 'on:', element.tagName, element.id || element.className);
      
      // Replay clicks without visual feedback - let the app's actual changes be visible
      if (event.type === 'click') {
        // Dispatch a proper MouseEvent to trigger all event listeners
        const clickEvent = new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          view: iframeDoc.defaultView
        });
        const dispatched = element.dispatchEvent(clickEvent);
        console.log('  ‚úì Click dispatched on:', element.tagName, element.id || element.className || element.getAttribute('data-curve'));
        
        // If this is a button with data-curve, log which one
        if (element.tagName === 'BUTTON' && element.hasAttribute('data-curve')) {
          console.log('    Curve button clicked:', element.getAttribute('data-curve'));
        }
      } else if (event.type === 'input' || event.type === 'change') {
        if (event.detail.value !== undefined) {
          element.value = event.detail.value;
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
        }
      } else if (event.type === 'drag') {
        replayDrag(element, event.detail, iframeDoc);
      }
      
    } catch (e) {
      console.warn('Cannot replay event:', e, event);
    }
  }
  
  function replayDrag(element, detail, iframeDoc) {
    if (!detail.animationFrames || detail.animationFrames.length === 0) {
      console.warn('Cannot replay drag - no animation data available');
      return;
    }
    
    try {
      // Get start and end positions from RECORDED coordinates
      const firstFrame = detail.animationFrames[0];
      const lastFrame = detail.animationFrames[detail.animationFrames.length - 1];
      
      const startX = firstFrame.x;
      const startY = firstFrame.y;
      const endX = lastFrame.x;
      const endY = lastFrame.y;
      const deltaX = endX - startX;
      const deltaY = endY - startY;
      
      console.log('  Replaying drag from (', startX, ',', startY, ') to (', endX, ',', endY, ')');
      
      // Dispatch mousedown at recorded start position
      const mousedownEvent = new MouseEvent('mousedown', {
        bubbles: true,
        cancelable: true,
        view: iframeDoc.defaultView,
        clientX: startX,
        clientY: startY,
        button: 0
      });
      element.dispatchEvent(mousedownEvent);
      
      // For fast-forward (events before tutorial start), do instant drag
      const tutorialStartSec = (currentTutorial.tutorialStartOffset || 0) / 1000;
      const dragStartTime = detail.animationFrames[0].timestamp || 0;
      
      // Check if this drag is in fast-forward region
      // We need to look at the drag event's timestamp, not the frame time
      let isFastForward = false;
      if (currentTutorial && currentTutorial.events) {
        // Find this drag event in the events list
        const dragEvent = currentTutorial.events.find(e => 
          e.type === 'drag' && e.detail === detail
        );
        if (dragEvent) {
          isFastForward = (dragEvent.timestamp / 1000) < tutorialStartSec;
        }
      }
      
      if (isFastForward) {
        // Instant drag for fast-forward: mousedown ‚Üí mousemove to end ‚Üí mouseup
        console.log('  Fast-forward drag');
        
        const mousemoveEvent = new MouseEvent('mousemove', {
          bubbles: true,
          cancelable: true,
          view: iframeDoc.defaultView,
          clientX: endX,
          clientY: endY,
          button: 0
        });
        iframeDoc.dispatchEvent(mousemoveEvent);
        
        const mouseupEvent = new MouseEvent('mouseup', {
          bubbles: true,
          cancelable: true,
          view: iframeDoc.defaultView,
          clientX: endX,
          clientY: endY,
          button: 0
        });
        iframeDoc.dispatchEvent(mouseupEvent);
        console.log('  ‚úì Drag complete (fast-forward)');
        return;
      }
      
      // For normal playback, animate the drag smoothly
      console.log('  Animated drag');
      // Use the original recorded duration
      const originalDuration = detail.duration || (lastFrame.time - firstFrame.time);
      const numSteps = 60; // Fixed number of steps for consistent smoothness
      
      console.log('  Original duration:', originalDuration, 'ms');
      
      // Mark that we have an active drag animation
      activeDragAnimation = true;
      
      for (let i = 0; i <= numSteps; i++) {
        const progress = i / numSteps;
        const delay = (originalDuration / numSteps) * i / playbackSpeed;
        
        setTimeout(() => {
          const currentX = startX + (deltaX * progress);
          const currentY = startY + (deltaY * progress);
          
          const mousemoveEvent = new MouseEvent('mousemove', {
            bubbles: true,
            cancelable: true,
            view: iframeDoc.defaultView,
            clientX: currentX,
            clientY: currentY,
            button: 0
          });
          iframeDoc.dispatchEvent(mousemoveEvent);
          
          // If this is the last step, dispatch mouseup and clear flag
          if (i === numSteps) {
            const mouseupEvent = new MouseEvent('mouseup', {
              bubbles: true,
              cancelable: true,
              view: iframeDoc.defaultView,
              clientX: endX,
              clientY: endY,
              button: 0
            });
            iframeDoc.dispatchEvent(mouseupEvent);
            activeDragAnimation = null; // Clear the flag
            console.log('  ‚úì Drag complete at (', endX, ',', endY, ')');
          }
        }, delay);
      }
      
    } catch (e) {
      console.warn('Drag replay failed:', e);
      // Emergency cleanup: dispatch mouseup to unstick any drag
      try {
        const mouseupEvent = new MouseEvent('mouseup', {
          bubbles: true,
          cancelable: true,
          view: iframeDoc.defaultView,
          button: 0
        });
        iframeDoc.dispatchEvent(mouseupEvent);
      } catch (cleanup) {
        console.warn('Cleanup mouseup failed:', cleanup);
      }
    }
  }
  
  function findElement(doc, selector) {
    if (!selector) return null;
    
    if (typeof selector === 'object') {
      if (selector.type === 'button-text') {
        const buttons = doc.querySelectorAll(selector.tagName || 'button');
        for (let btn of buttons) {
          if (btn.textContent.trim() === selector.text) {
            return btn;
          }
        }
      }
      return null;
    }
    
    if (selector.startsWith('#')) {
      return doc.getElementById(selector.substring(1));
    }
    
    try {
      const element = doc.querySelector(selector);
      if (element) return element;
      
      const svg = doc.querySelector('svg');
      if (svg) {
        return svg.querySelector(selector);
      }
      
      return null;
    } catch (e) {
      console.warn('Invalid selector:', selector, e);
      return null;
    }
  }
  
  function showAnnotation(ann) {
    // All annotations now use custom position with left/top coordinates
    annotationBox.className = 'annotation-box visible custom-position';
    annotationBox.style.left = ann.position.left + 'px';
    annotationBox.style.top = ann.position.top + 'px';
    annotationBox.style.transform = 'none';
    
    // Use innerHTML to allow LaTeX rendering
    annotationTitle.innerHTML = ann.title;
    annotationText.innerHTML = ann.text;
    
    // Trigger MathJax to process the new content
    if (typeof MathJax !== 'undefined') {
      if (MathJax.typesetPromise) {
        MathJax.typesetPromise([annotationBox]).catch((err) => console.warn('MathJax error:', err));
      } else if (MathJax.typeset) {
        MathJax.typeset([annotationBox]);
      }
    }
  }
  
  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return mins + ':' + (secs < 10 ? '0' : '') + secs;
  }
  
  // Help
  helpBtn.addEventListener('click', () => {
    helpModal.classList.add('visible');
  });
  
  closeHelpModal.addEventListener('click', () => {
    helpModal.classList.remove('visible');
  });
  
  // Close modals on outside click
  [exportModal, loadModal, helpModal, annotationEditorModal].forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.remove('visible');
        if (modal === annotationEditorModal) {
          // If closing annotation editor, also cancel positioning if active
          if (positionEditorOverlay.style.display !== 'none') {
            positionEditorOverlay.style.display = 'none';
            annotationBox.classList.remove('visible', 'draggable');
            pendingAnnotation = null;
          }
        }
      }
    });
  });
  
  // Also allow clicking the overlay to cancel positioning
  positionEditorOverlay.addEventListener('click', (e) => {
    if (e.target === positionEditorOverlay) {
      positionEditorOverlay.style.display = 'none';
      annotationBox.classList.remove('visible', 'draggable');
      pendingAnnotation = null;
    }
  });
})();
</script>
</body>
</html>
