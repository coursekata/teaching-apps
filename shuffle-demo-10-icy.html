<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>R Shuffle Function: Understanding Randomization - Updated</title>
  <style>
    :root {
      --bg: #ffffff;
      --fg: #111111;
      --muted: #666666;
      --accent: #2563eb;
      --a-row: #e3f2fd;
      --b-row: #fff3e0;
      --a-card-stroke: #1e88e5;
      --b-card-stroke: #ef6c00;
      --lift-shadow: 0 10px 18px rgba(0,0,0,.18);
      --neutral-bg: #f3f4f6;
      --neutral-border: #9ca3af;
      --axis: #9ca3af;
      --dot: #3b82f6;
      --dot-recent: #f59e0b;
      --original-dot: #dc2626;
      --group-a-dot: #3b82f6;
      --group-b-dot: #f59e0b;
    }

    html, body { height: 100%; }
    body { 
      margin: 0; padding: 24px; background: var(--bg); color: var(--fg);
      font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
    }

    .wrap { max-width: 900px; margin: 0 auto; }
    
    .main-layout {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    
    .top-section {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 24px;
      align-items: start;
    }
    
    .right-column {
      display: flex;
      flex-direction: column;
      gap: 0;
    }
    
    .tabs-container {
      display: flex;
      border-bottom: 2px solid #e5e7eb;
      margin-bottom: 16px;
      margin-top: 16px;
    }
    
    .tab {
      flex: 1;
      padding: 6px 16px;
      text-align: center;
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-bottom: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      color: #6b7280;
      transition: all 0.2s ease;
    }
    
    .tab:first-child {
      border-radius: 8px 0 0 0;
    }
    
    .tab:last-child {
      border-radius: 0 8px 0 0;
    }
    
    .tab.active {
      background: white;
      color: #000000;
      border-bottom: 2px solid white;
      margin-bottom: -2px;
    }
    
    .tab:hover:not(.active) {
      background: #f1f5f9;
      color: #374151;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .tab-title {
      background: white;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 8px 16px;
      margin: 0 20px 8px 20px;
      font-size: 18px;
      font-weight: 600;
      color: #1e293b;
      text-align: center;
    }
    
    .tab-title .math {
      font-family: 'Times New Roman', serif;
      font-style: italic;
      font-size: 20px;
      color: #000000;
    }
    
    .section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #374151;
      cursor: pointer;
      user-select: none;
    }
    
    .section-header:hover {
      color: #1f2937;
    }
    
    .caret {
      font-size: 12px;
      transition: transform 0.2s ease;
      color: #6b7280;
    }
    
    .caret.expanded {
      transform: rotate(90deg);
    }
    
    .section-content {
      display: block;
    }
    
    .section-content.collapsed {
      display: none;
    }
    
    .r-command-section {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 16px;
      font-family: 'Courier New', monospace;
    }
    
    .r-output {
      background: white;
      border: 1px solid #cbd5e1;
      padding: 12px;
      border-radius: 6px;
      margin-top: 8px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #111827;
      font-weight: 600;
      white-space: pre-wrap;
      border-left: 3px solid #2563eb;
    }
    
    button:disabled, button.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    button:disabled:hover, button.disabled:hover {
      background: var(--accent);
    }
    
    .animation-canvas {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none; z-index: 10;
    }

    h1 { font-size: 1.3rem; margin: 0 0 8px; }
    .subtitle { color: var(--muted); margin: 0 0 20px; line-height: 1.5; }

    .controls { 
      display: flex; gap: 12px; align-items: flex-start; margin: 16px 0; 
      flex-direction: row;
    }
    
    .controls .code-line {
      flex: 1;
    }
    
    .button-stack {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-self: flex-start;
      min-width: 70px;
    }
    
    .button-stack button {
      padding: 6px 10px;
      font-size: 0.8rem;
      min-height: 0;
      margin: 0;
    }
    
    button.clear {
      background: white;
      color: var(--accent);
      border-color: var(--accent);
      padding: 6px 10px;
      font-size: 0.8rem;
      min-height: 0;
      margin: 0;
    }
    
    button.clear:hover {
      background: #f8fafc;
      border-color: #1d4ed8;
    }
    
    button { 
      appearance: none; border: 1px solid #d1d5db; background: #fff; color: #111; 
      cursor: pointer; padding: 10px 16px; border-radius: 10px; font-weight: 600;
      font-size: 0.95rem; transition: all 0.2s ease;
    }
    button:hover { background: #f9fafb; border-color: #9ca3af; }
    button:active { transform: translateY(1px); }
    button.primary { background: var(--accent); color: white; border-color: var(--accent); }
    button.primary:hover { background: #1d4ed8; }

    .code-line {
      display: flex; align-items: flex-start; gap: 12px;
      background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;
      padding: 12px 16px; margin-bottom: 8px;
    }
    
    .code-block {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px; color: #1e293b; font-weight: 500;
      background: white; padding: 12px 16px; border-radius: 6px;
      border: 1px solid #cbd5e1; flex-grow: 1;
      line-height: 1.6;
      white-space: pre-line;
    }
    
    .run-btn {
      white-space: nowrap; min-width: 80px; align-self: flex-start;
    }

    .table-container {
      background: white; border: 1px solid #e5e7eb; border-radius: 12px;
      overflow: hidden; margin: 16px 0;
    }
    .table-wrap { position: relative; }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    thead th { 
      text-align: center; background: #f8fafc; color: #111; font-weight: 700; 
      padding: 10px 4px; border-bottom: 2px solid #e5e7eb; font-size: 0.9rem;
    }
    tbody td { 
      padding: 0; border-bottom: 2px solid white; border-right: 2px solid white;
      position: relative; height: 32px;
    }
    tbody tr:last-child td { border-bottom: 2px solid white; }
    tbody td:last-child { border-right: none; }
    tbody tr.a { background: var(--a-row); }
    tbody tr.b { background: var(--b-row); }

    .cell-content {
      display: flex; align-items: center; padding: 4px;
      height: 100%; box-sizing: border-box; font-size: 0.9rem;
    }
    .cell-content.center { justify-content: center; }

    .cards-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
    .card { 
      position: absolute; pointer-events: none; user-select: none;
      border-radius: 6px; color: #111; font-weight: 600; 
      text-align: center; 
      transition: all .8s cubic-bezier(.2,.8,.2,1);
      border: 1px solid transparent;
      display: flex; align-items: center; justify-content: center;
      font-size: 14px;
    }
    .card.jiggle { animation: jiggle 0.3s ease-in-out infinite alternate; }
    @keyframes jiggle {
      0% { transform: translate(0, 0) rotate(-1deg); }
      25% { transform: translate(-1px, -1px) rotate(1deg); }
      50% { transform: translate(1px, 0) rotate(-1deg); }
      75% { transform: translate(0, 1px) rotate(1deg); }
      100% { transform: translate(1px, -1px) rotate(-1deg); }
    }
    .card.hover { 
      transform: translateZ(50px) scale(1.05); 
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
      z-index: 100;
    }
    .card.a { background: var(--a-row); }
    .card.b { background: var(--b-row); }
    .card.show-border { 
      border-style: dashed; border-color: #6b7280; border-width: 2px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .card.show-border.hover { box-shadow: 0 12px 30px rgba(0,0,0,0.4); }

    .graph-section {
      position: relative;
      padding: 0;
    }
    .dist-panel {
      margin-top: 4px;
    }
    .dist-meta { font-size: .9rem; color: var(--muted); }
    #histSvg {
      width: 100%;
      height: 260px;
      display: block;
      background: white;
    }

    @media (max-width: 600px) {
      .top-section {
        grid-template-columns: 1fr;
        gap: 16px;
      }
      .tab {
        font-size: 0.8rem;
        padding: 6px 8px;
      }
      .controls { 
        flex-direction: column; 
        align-items: stretch; 
      }
      thead th { padding: 8px 4px; font-size: 0.8rem; }
    }
  
.lit-dollar{font-family:inherit}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Understanding R's <span class="code">shuffle()</span> Function</h1>

    <div class="main-layout">
      <div class="top-section">
        <div class="table-section">
          <div class="table-container">
            <div class="table-wrap" id="tableWrap">
              <table>
                <thead>
                  <tr>
                    <th style="width: 33.33%;" id="groupHeader">Group</th>
                    <th style="width: 33.33%;" id="outcomeHeader">Outcome</th>
                    <th style="width: 33.33%;" id="shuffledHeader">Score_shuf</th>
                  </tr>
                </thead>
                <tbody id="tbody"></tbody>
              </table>
              <div class="cards-layer" id="cardsLayer" aria-hidden="true"></div>
            </div>
          </div>
          <div id="initialDifference" style="font-weight: bold; margin-top: 12px; font-size: 15px; color: #1f2937; text-align: center;">
            Initial b<sub>1</sub> (group difference) = —
          </div>
        </div>

        <div class="right-column">
          <div class="tabs-container">
            <div class="tab active" data-tab="graphing">Shuffle 1</div>
            <div class="tab" data-tab="model">Model</div>
            <div class="tab" data-tab="shuffle">Shuffle 2</div>
            <div class="tab" data-tab="sampling">Dist of b<sub>1</sub></div>
          </div>

          <div class="tab-content active" id="graphing-content">
            <div class="tab-title">Graphing Shuffles</div>
            <div style="padding: 8px 20px;">
              <div class="code-section">
                <div class="controls">
                  <div class="code-line">
                    <div class="code-block" id="graphingPlotCodeBlock">df$Score_shuf &lt;- shuffle(df$Score)
gf_point(Score_shuf ~ Condition, data=df)</div>
<button id="runGraphingPlotBtn" class="primary run-btn">Run</button>
                  </div>
                </div>
              </div>
              
              <div id="smallGraphsContainer" style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 20px;"></div>
              
			  <div style="text-align: center; margin-top: 20px; display: flex; gap: 12px; justify-content: center;">
                <button id="toggleGraphingMeansBtn" style="padding: 8px 16px; font-size: 0.9rem; background: #3b82f6; color: white; border: 1px solid #3b82f6; font-weight: 600; border-radius: 10px; cursor: pointer;">
                  Show Means
                </button>
                <button id="clearGraphingPlotsBtn" class="clear" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
              </div>
            </div>
          </div>

          <div class="tab-content" id="model-content">
            <div class="tab-title">
              A Two-Group Model: <span class="math">Y<sub>i</sub> = b<sub>0</sub> + b<sub>1</sub>X<sub>i</sub> + e<sub>i</sub></span>
            </div>
            <div style="padding: 8px 20px;">
              <div style="margin-bottom: 16px;">
                <div class="section-header" data-target="graph-content">
                  <span class="caret">▶</span>
                  <span>Graph the data</span>
                </div>
                <div class="section-content collapsed" id="graph-content">
                  <div class="code-section">
                    <div class="controls">
                      <div class="code-line">
                        <div class="code-block" id="plotCodeBlock">gf_point(Score ~ Condition, data=df)</div>
                        <button id="runPlotBtn" class="primary run-btn">Run</button>
                      </div>
                    </div>
<div id="plotOutput" style="display: none; margin-top: 8px;">
                      <svg id="scatterSvg" width="100%" height="240" style="background: transparent; display: block;"></svg>
                      <div style="display: flex; gap: 12px; justify-content: center; margin-top: 12px; margin-left: -65px;">
                        <button id="toggleMeansBtn" style="padding: 8px 16px; font-size: 0.9rem; background: #3b82f6; color: white; border: 1px solid #3b82f6; font-weight: 600; border-radius: 10px; cursor: pointer;">
                          Show Means
                        </button>
                        <button id="clearPlotBtn" class="clear" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div style="margin-bottom: 16px;">
                <div class="section-header" data-target="specify-content">
                  <span class="caret">▶</span>
                  <span>Fit the model</span>
                </div>
                <div class="section-content collapsed" id="specify-content">
                  <div style="margin: 12px 0;">
                    <div class="equation-formula" style="margin-left: 0; font-size: 24px;">
                      <em>Y</em><sub>i</sub> = <em>b</em><sub>0</sub> + <em>b</em><sub>1</sub><em>X</em><sub>i</sub> + <em>e</em><sub>i</sub>
                    </div>
                  </div>
                  
                  <div class="code-section" style="margin-top: 20px;">
                    <div class="controls">
                      <div class="code-line">
                        <div class="code-block" id="modelCodeBlock">lm(outcome ~ group, data=df)</div>
                        <div class="button-stack">
                          <button id="runModelBtn" class="primary run-btn">Run</button>
                          <button id="clearModelBtn" class="clear">Clear</button>
                        </div>
                      </div>
                    </div>
                    <div id="rOutput" class="r-output" style="display: none; margin-top: 16px;"></div>
                  </div>
                </div>
              </div>
              
              <div style="margin-bottom: 16px;">
                <div class="section-header" data-target="fit-content">
                  <span class="caret">▶</span>
                  <span>Generate b<sub>1</sub></span>
                </div>
                <div class="section-content collapsed" id="fit-content">
                  <div class="code-section">
                    <div class="controls">
                      <div class="code-line">
                        <div class="code-block" id="b1CodeBlock">b1(outcome ~ group, data=df)</div>
                        <div class="button-stack">
                          <button id="runB1Btn" class="primary run-btn">Run</button>
                          <button id="clearB1Btn" class="clear">Clear</button>
                        </div>
                      </div>
                    </div>
                    <div id="b1Output" class="r-output" style="display: none; margin-top: 16px;"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="tab-content" id="shuffle-content">
            <div class="tab-title">
              Simulating a World Where <span class="math">β<sub>1</sub></span> is 0
            </div>
            <div style="padding: 8px 20px;">
              <div style="margin-bottom: 16px;">
                <div class="section-header" data-target="graph-shuffles-content">
                  <span class="caret">▶</span>
                  <span>Graph shuffles</span>
                </div>
                <div class="section-content collapsed" id="graph-shuffles-content">
                  <div class="code-section">
                    <div class="controls">
                      <div class="code-line">
                        <div class="code-block" id="shufflePlotCodeBlock">df$Score_shuf &lt;- shuffle(df$Score)
gf_point(Score_shuf ~ Condition, data=df)</div>
                        <button id="runShufflePlotBtn" class="primary run-btn">Run</button>
                      </div>
                    </div>
                    <div id="shufflePlotOutput" style="display: none; margin-top: 8px;">
                      <svg id="shuffleScatterSvg" width="100%" height="240" style="background: transparent; display: block;"></svg>
                      <div style="display: flex; gap: 12px; justify-content: center; margin-top: 12px; margin-left: -65px;">
                        <button id="toggleShuffleMeansBtn" style="padding: 8px 16px; font-size: 0.9rem; background: #3b82f6; color: white; border: 1px solid #3b82f6; font-weight: 600; border-radius: 10px; cursor: pointer;">
                          Show Means
                        </button>
                        <button id="clearShufflePlotBtn" class="clear" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div style="margin-bottom: 16px;">
                <div class="section-header" data-target="shuffle-data-content">
                  <span class="caret">▶</span>
                  <span>Model shuffles</span>
                </div>
                <div class="section-content collapsed" id="shuffle-data-content">
                  <div class="code-section">
                    <div class="controls">
                      <div class="code-line">
                        <div class="code-block" id="codeBlock">df$Score_shuf &lt;- shuffle(df$Score)
b1(Score_shuf~Condition, data=df)</div>
                        <div class="button-stack">
                          <button id="shuffleBtn" class="primary run-btn">Run</button>
                          <button id="shuffleRun5xBtn" class="clear">Run 5x</button>
                        </div>
                      </div>
                    </div>
                    
                    <div id="shuffleOutput" class="r-output" style="display: none; margin-top: 16px;">
                      Waiting for shuffle...
                    </div>
                    
                    <div style="display: flex; justify-content: center; margin-top: 12px;">
                      <button id="clearShuffleBtn" class="clear" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="tab-content" id="sampling-content">
            <div class="tab-title">
              A Sampling Distribution of <span class="math">b<sub>1</sub></span> Assuming <span class="math">β<sub>1</sub></span>=0
            </div>
            <div style="padding: 8px 20px;">
              <div class="code-section">
                <div class="controls">
                  <div class="code-line">
                    <div class="code-block" id="samplingCodeBlock">df$Score_shuf &lt;- shuffle(df$Score)
b1(Score_shuf~Condition, data=df)</div>
                    <div class="button-stack">
                      <button id="samplingShuffleBtn" class="primary run-btn">Run</button>
                      <button id="run5xBtn" class="clear">Run 5x</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="graph-section" id="graphSection">
              <div class="animation-canvas" id="animationCanvas"></div>
              
              <div class="dist-panel">
                <div style="margin-left: 30px; margin-right: 40px;">
                  <div style="font-size: 20px; font-weight: bold; color: #333; text-align: center; margin-left: 18px;">Sampling Distribution of b<sub>1</sub></div>
                </div>
                <div style="margin-left: 30px; margin-right: 40px; position: relative;">
                  <svg id="histSvg" viewBox="0 0 500 280" preserveAspectRatio="none" style="width: 100%; height: 260px; display: block; background: white;"></svg>
                  <div class="dist-meta" style="position: absolute; top: 20px; right: 0px; font-size: 0.8rem; text-align: right;"><span id="distCount">0</span> shuffles</div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 6px; flex-wrap: wrap; margin-left: 30px; margin-right: 40px;">
                  <div class="dist-meta" style="line-height: 1.4;">
                    <div style="margin-bottom: 4px;">
                      <span style="display:inline-block;width:8px;height:8px;background:var(--original-dot);border-radius:50%;margin-right:6px;"></span>
                      Original difference
                      <span style="display:inline-block;width:8px;height:8px;background:var(--dot);border-radius:50%;margin-left:12px;margin-right:6px;"></span>
                      Shuffles
                      <span style="display:inline-block;width:8px;height:8px;background:var(--dot-recent);border-radius:50%;margin-left:8px;margin-right:6px;"></span>
                      Most recent
                    </div>
                    <div>
                      <span style="display:inline-block;width:12px;height:2px;background:#2563eb;margin-right:6px;border-top:2px dashed #2563eb;background:none;"></span>
                      Mean of Sampling Distribution
                    </div>
                  </div>
                  <div class="dist-meta" id="distSummary" style="text-align: right; font-weight: bold; color: #1f2937;"></div>
                </div>
                <div style="display: flex; justify-content: center; margin-top: 12px; margin-left: 30px; margin-right: 40px;">
                  <button id="clearSamplingBtn" class="clear" style="padding: 8px 16px; font-size: 0.9rem;">Clear</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // ============================================================================
      // CONSTANTS AND CONFIGURATION
      // ============================================================================

      /** Animation timing constants (in milliseconds) */
      const ANIMATION_TIMING = {
        CARD_TRANSITION: 800,
        JIGGLE_DURATION: 800,
        GATHER_DELAY: 50,
        GATHER_TO_SHUFFLE: 800,
        HAND_MOVEMENT: 150,
        CARD_LIFT: 70,
        SWAP_DURATION: 150,
        SWAP_PAUSE: 100,
        SHUFFLE_TO_DEAL: 500,
        DEAL_INTERVAL: 120,
        DEAL_CARD_DELAY: 100,
        HAND_FADE: 400,
        RETURN_TO_ORIGIN: 700,
        RESET_TRANSITION: 600
      };

      /** Faster animation timing when hands are disabled (in milliseconds) */
      const ANIMATION_TIMING_NO_HANDS = {
        CARD_TRANSITION: 800,
        JIGGLE_DURATION: 400,
        GATHER_DELAY: 30,
        GATHER_TO_SHUFFLE: 400,
        HAND_MOVEMENT: 60,
        CARD_LIFT: 35,
        SWAP_DURATION: 75,
        SWAP_PAUSE: 40,
        SHUFFLE_TO_DEAL: 200,
        DEAL_INTERVAL: 50,
        DEAL_CARD_DELAY: 40,
        HAND_FADE: 0,
        RETURN_TO_ORIGIN: 700,
        RESET_TRANSITION: 600
      };

      /** Visual constants */
      const VISUAL_CONSTANTS = {
        CARD_WIDTH: 50,
        CARD_HEIGHT: 20,
        HAND_EMOJI_SIZE: 55,
        HAND_OPACITY_VISIBLE: 1.0,
        HAND_OPACITY_DEALING: 0.7,
        HAND_OPACITY_HIDDEN: 0,
        CARD_HOVER_SCALE: 1.05,
        CARD_LIFT_SCALE: 1.15,
        MAX_SMALL_GRAPHS: 8
      };

      /** Histogram configuration */
      const HISTOGRAM_CONFIG = {
        BINS: 12,
        Y_STEPS: [12, 20, 40, 60, 100],
        PADDING_RATIO: 0.1,
        AXIS_PADDING_RATIO: 0.15
      };

      /** SVG dimensions and margins */
      const SVG_DIMENSIONS = {
        SMALL_GRAPH: {
          width: 180,
          height: 150,
          margin: { top: 20, right: 10, bottom: 25, left: 25 }
        },
        LARGE_GRAPH: {
          width: 245,
          height: 240,
          margin: { top: 30, right: 30, bottom: 40, left: -65 }
        },
        HISTOGRAM: {
          width: 500,
          height: 280,
          margin: { left: 48, right: 12, top: 16, bottom: 40 }
        }
      };

      /** Default configuration with URL parameter overrides */
      const CONFIG = {
        data: [72, 68, 75, 71, 74, 58, 62, 55, 60, 59],
        groupAName: 'Treatment',
        groupBName: 'Control', 
        outcomeName: 'Score',
        groupName: 'Condition'
      };

      const urlParams = new URLSearchParams(window.location.search);
      
      const dataParam = urlParams.get('data');
      if (dataParam) {
        const dataValues = dataParam.split(',').map(val => parseFloat(val.trim())).filter(val => !isNaN(val));
        if (dataValues.length >= 4) {
          CONFIG.data = dataValues;
        }
      }
      
      if (urlParams.get('groupA')) CONFIG.groupAName = urlParams.get('groupA');
      if (urlParams.get('groupB')) CONFIG.groupBName = urlParams.get('groupB');
      if (urlParams.get('outcome')) CONFIG.outcomeName = urlParams.get('outcome');
      if (urlParams.get('group')) CONFIG.groupName = urlParams.get('group');

      // Hand animation control (default is true/on)
      const handsParam = urlParams.get('hands');
      const SHOW_HANDS = handsParam === null || handsParam === 'true' || handsParam === '1' || handsParam === 'on';

      const tabsParam = urlParams.get('tabs');
      let visibleTabs = [1, 2, 3, 4];
      
      if (tabsParam) {
        const tabNumbers = tabsParam.split(',').map(num => parseInt(num.trim())).filter(num => [1, 2, 3, 4].includes(num));
        if (tabNumbers.length > 0) {
          visibleTabs = tabNumbers;
        }
      }

      // ============================================================================
      // STATE MANAGEMENT
      // ============================================================================

      /**
       * Application state container
       * Manages all mutable state in one place for easier tracking and debugging
       */
      const AppState = {
        // Data state
        initialData: [],
        currentData: [],
        shuffledOutcomes: [],
        outcomeOrigins: new Map(),
        
        // Statistics state
        originalDiff: null,
        diffHistory: [],
        shuffleResults: [],
        histConfig: null,
        lastBatchSize: 1,
        
        // UI state
        showMeans: false,
        showShuffleMeans: false,
        showGraphingMeans: false,
        currentPlotData: null,
        smallGraphCount: 0,
        graphingShuffleHistory: [],
        
        // DOM references (cached for performance)
        dom: {
          tbody: null,
          cardsLayer: null,
          tableWrap: null
        }
      };

      // ============================================================================
      // UTILITY FUNCTIONS
      // ============================================================================

      /**
       * Formats a number to one decimal place, removing trailing .0
       * @param {number} n - Number to format
       * @returns {string} Formatted number string
       */
      function formatNumber(n) {
        return Number(n).toFixed(1).replace(/\.0$/, '');
      }

      /**
       * Formats a number as an integer
       * @param {number} n - Number to format
       * @returns {string} Formatted integer string
       */
      function formatInt(n) { 
        return String(Math.round(n)); 
      }

      /**
       * Calculates the mean of an array of numbers
       * @param {number[]} arr - Array of numbers
       * @returns {number} Mean value
       */
      function mean(arr) { 
        return arr.reduce((a, b) => a + b, 0) / arr.length; 
      }

      /**
       * Fisher-Yates shuffle algorithm
       * @param {Array} arr - Array to shuffle
       * @returns {Array} New shuffled array
       */
      function shuffleArray(arr) {
        const result = [...arr];
        for (let i = result.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
      }

      /**
       * Gets the appropriate timing constants based on hands setting
       * @returns {Object} Timing constants object
       */
      function getTiming() {
        return SHOW_HANDS ? ANIMATION_TIMING : ANIMATION_TIMING_NO_HANDS;
      }

      /**
       * Creates an SVG element with attributes
       * @param {string} tag - SVG element tag name
       * @param {Object} attrs - Attributes to set
       * @param {SVGElement} parent - Parent element to append to
       * @returns {SVGElement} Created element
       */
      function createSVGElement(tag, attrs = {}, parent = null) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const k in attrs) el.setAttribute(k, attrs[k]);
        if (parent) parent.appendChild(el);
        return el;
      }

      /**
       * Safely gets a DOM element by ID with error checking
       * @param {string} id - Element ID
       * @returns {HTMLElement|null} DOM element or null
       */
      function getElement(id) {
        const el = document.getElementById(id);
        if (!el) console.warn(`Element with id "${id}" not found`);
        return el;
      }

      /**
       * Updates cached DOM references
       */
      function updateDOMRefs() {
        AppState.dom.tbody = getElement('tbody');
        AppState.dom.cardsLayer = getElement('cardsLayer');
        AppState.dom.tableWrap = getElement('tableWrap');
      }

      // ============================================================================
      // DATA INITIALIZATION AND STATISTICS
      // ============================================================================

      /**
       * Initializes the data structure from configuration
       */
      function initializeData() {
        const half = Math.floor(CONFIG.data.length / 2);
        for (let i = 0; i < CONFIG.data.length; i++) {
          const group = i < half ? CONFIG.groupAName : CONFIG.groupBName;
          const outcome = CONFIG.data[i];
          AppState.initialData.push({ group, outcome, originalIndex: i });
          AppState.outcomeOrigins.set(i, group);
        }
        AppState.currentData = JSON.parse(JSON.stringify(AppState.initialData));
      }

      /**
       * Computes fixed histogram axis boundaries to prevent rescaling
       * @param {number[]} values - All possible outcome values
       * @param {number} nA - Number of items in group A
       * @param {number} nB - Number of items in group B
       * @returns {Object} Histogram configuration
       */
      function computeFixedXAxis(values, nA, nB) {
        const sorted = [...values].sort((a, b) => a - b);
        const smallestA = sorted.slice(0, nA);
        const largestA = sorted.slice(sorted.length - nA);
        const smallestB = sorted.slice(0, nB);
        const largestB = sorted.slice(sorted.length - nB);

        const minDiff = mean(smallestA) - mean(largestB);
        const maxDiff = mean(largestA) - mean(smallestB);

        const range = maxDiff - minDiff;
        const pad = range * HISTOGRAM_CONFIG.PADDING_RATIO || 1;
        
        const bins = HISTOGRAM_CONFIG.BINS;
        const prelimBinW = (range + 2 * pad) / bins;
        const halfBins = Math.floor(bins / 2);
        const binW = prelimBinW;
        
        const xMin = -halfBins * binW - binW / 2;
        const xMax = xMin + bins * binW;
        
        return { 
          xMin, 
          xMax, 
          bins, 
          yMax: HISTOGRAM_CONFIG.Y_STEPS[0], 
          binW, 
          yStepIdx: 0 
        };
      }

      /**
       * Calculates statistics for current data state
       * @returns {Object} Statistics including means and difference
       */
      function calculateStats() {
        const dataToUse = AppState.shuffledOutcomes.length > 0 
          ? AppState.shuffledOutcomes.map(obj => obj.outcome) 
          : AppState.currentData.map(r => r.outcome);
        
        const groupData = AppState.currentData.map((row, index) => ({
          group: row.group,
          outcome: dataToUse[index]
        }));
        
        const groupA = groupData.filter(r => r.group === CONFIG.groupAName).map(r => r.outcome);
        const groupB = groupData.filter(r => r.group === CONFIG.groupBName).map(r => r.outcome);
        
        const meanA = mean(groupA);
        const meanB = mean(groupB);
        
        const sortedGroups = [
          { name: CONFIG.groupAName, mean: meanA },
          { name: CONFIG.groupBName, mean: meanB }
        ].sort((a, b) => a.name.localeCompare(b.name));
        
        const diff = sortedGroups[1].mean - sortedGroups[0].mean;
        
        if (AppState.originalDiff === null) {
          AppState.originalDiff = diff;
          updateInitialDifferenceDisplay(diff, sortedGroups);
        }
        
        return { meanA, meanB, diff };
      }

      /**
       * Updates the initial difference display in the UI
       * @param {number} diff - The calculated difference
       * @param {Array} sortedGroups - Sorted groups with means
       */
      function updateInitialDifferenceDisplay(diff, sortedGroups) {
        const element = getElement('initialDifference');
        if (element) {
          element.innerHTML = 
            `Initial b<sub>1</sub> (${sortedGroups[1].name} - ${sortedGroups[0].name}) = ${formatNumber(diff)}`;
        }
      }

      // ============================================================================
      // DOM RENDERING FUNCTIONS
      // ============================================================================

      /**
       * Renders the main data table
       */
      function drawTable() {
        if (!AppState.dom.tbody) updateDOMRefs();
        AppState.dom.tbody.innerHTML = '';
        
        AppState.currentData.forEach((row, index) => {
          const tr = document.createElement('tr');
          tr.className = row.group === CONFIG.groupAName ? 'a' : 'b';
          
          // Group cell
          const tdGroup = document.createElement('td');
          const groupDiv = document.createElement('div');
          groupDiv.className = 'cell-content center';
          groupDiv.textContent = row.group;
          tdGroup.appendChild(groupDiv);
          
          // Outcome cell
          const tdOutcome = document.createElement('td');
          const outcomeDiv = document.createElement('div');
          outcomeDiv.className = 'cell-content center';
          outcomeDiv.textContent = row.outcome;
          tdOutcome.appendChild(outcomeDiv);
          
          // Shuffled cell (initially empty)
          const tdShuffled = document.createElement('td');
          const shuffledDiv = document.createElement('div');
          shuffledDiv.className = 'cell-content center';
          shuffledDiv.textContent = '';
          tdShuffled.appendChild(shuffledDiv);
          
          tr.appendChild(tdGroup);
          tr.appendChild(tdOutcome);
          tr.appendChild(tdShuffled);
          AppState.dom.tbody.appendChild(tr);
        });
      }

      /**
       * Creates visual cards for shuffle animation
       */
      function createCards() {
        const outcomeCells = document.querySelectorAll('tbody td:nth-child(2)');
        const layerRect = AppState.dom.cardsLayer.getBoundingClientRect();
        AppState.dom.cardsLayer.innerHTML = '';
        
        AppState.currentData.forEach((data, i) => {
          const cell = outcomeCells[i];
          const cellRect = cell.getBoundingClientRect();
          const card = document.createElement('div');
          
          const originalGroup = AppState.outcomeOrigins.get(data.originalIndex);
          card.className = 'card ' + (originalGroup === CONFIG.groupAName ? 'a' : 'b');
          card.textContent = data.outcome;
          card.dataset.outcomeValue = data.outcome;
          
          const centerX = cellRect.left - layerRect.left + (cellRect.width - VISUAL_CONSTANTS.CARD_WIDTH) / 2;
          const centerY = cellRect.top - layerRect.top + (cellRect.height - VISUAL_CONSTANTS.CARD_HEIGHT) / 2;
          
          card.style.left = centerX + 'px';
          card.style.top = centerY + 'px';
          card.style.width = VISUAL_CONSTANTS.CARD_WIDTH + 'px';
          card.style.height = VISUAL_CONSTANTS.CARD_HEIGHT + 'px';
          
          AppState.dom.cardsLayer.appendChild(card);
        });
      }

      /**
       * Repositions cards based on current state
       * Cards move to shuffled column if shuffle is active, otherwise to outcome column
       */
      function repositionCards() {
        const cards = AppState.dom.cardsLayer.querySelectorAll('.card');
        
        if (AppState.shuffledOutcomes.length > 0) {
          repositionCardsToShuffledColumn(cards);
        } else {
          repositionCardsToOutcomeColumn(cards);
        }
      }

      /**
       * Positions cards in the shuffled column
       * @param {NodeList} cards - Card elements to position
       */
      function repositionCardsToShuffledColumn(cards) {
        const shuffledColumnCells = document.querySelectorAll('tbody td:nth-child(3)');
        const layerRect = AppState.dom.cardsLayer.getBoundingClientRect();
        
        const shuffledPositions = AppState.shuffledOutcomes.map((obj, index) => ({ 
          outcome: obj.outcome, 
          position: index 
        }));
        
        cards.forEach((card) => {
          const outcomeValue = parseFloat(card.dataset.outcomeValue);
          const positionInfo = findAndRemovePosition(shuffledPositions, outcomeValue);
          
          if (positionInfo !== null) {
            positionCardInCell(card, shuffledColumnCells[positionInfo.position], layerRect);
          }
        });
      }

      /**
       * Positions cards in the outcome column
       * @param {NodeList} cards - Card elements to position
       */
      function repositionCardsToOutcomeColumn(cards) {
        const outcomeCells = document.querySelectorAll('tbody td:nth-child(2)');
        const layerRect = AppState.dom.cardsLayer.getBoundingClientRect();
        
        const availablePositions = AppState.currentData.map((data, index) => ({ 
          outcome: data.outcome, 
          position: index 
        }));
        
        cards.forEach((card) => {
          const outcomeValue = parseFloat(card.dataset.outcomeValue);
          const positionInfo = findAndRemovePosition(availablePositions, outcomeValue);
          
          if (positionInfo !== null) {
            positionCardInCell(card, outcomeCells[positionInfo.position], layerRect);
          }
        });
      }

      /**
       * Finds a position for an outcome value and removes it from the available positions
       * @param {Array} positions - Available positions
       * @param {number} outcomeValue - Value to find
       * @returns {Object|null} Position info or null
       */
      function findAndRemovePosition(positions, outcomeValue) {
        for (let i = 0; i < positions.length; i++) {
          if (positions[i].outcome === outcomeValue) {
            const positionInfo = positions[i];
            positions.splice(i, 1);
            return positionInfo;
          }
        }
        return null;
      }

      /**
       * Positions a card within a specific cell
       * @param {HTMLElement} card - Card element
       * @param {HTMLElement} targetCell - Target cell element
       * @param {DOMRect} layerRect - Cards layer bounding rectangle
       */
      function positionCardInCell(card, targetCell, layerRect) {
        const cellRect = targetCell.getBoundingClientRect();
        
        card.style.transition = 'none';
        card.style.transform = 'translate(0,0)';
        
        const centerX = cellRect.left - layerRect.left + (cellRect.width - VISUAL_CONSTANTS.CARD_WIDTH) / 2;
        const centerY = cellRect.top - layerRect.top + (cellRect.height - VISUAL_CONSTANTS.CARD_HEIGHT) / 2;
        
        card.style.left = centerX + 'px';
        card.style.top = centerY + 'px';
        card.style.width = VISUAL_CONSTANTS.CARD_WIDTH + 'px';
        card.style.height = VISUAL_CONSTANTS.CARD_HEIGHT + 'px';
        
        requestAnimationFrame(() => {
          card.style.transition = `all ${ANIMATION_TIMING.CARD_TRANSITION}ms cubic-bezier(.2,.8,.2,1)`;
        });
      }

      // ============================================================================
      // SHUFFLE ANIMATION LOGIC
      // ============================================================================

      /**
       * Creates a hand emoji element for shuffle animation
       * @param {HTMLElement} parent - Parent element to append to
       * @returns {HTMLElement} Hand element
       */
      function createHandElement(parent) {
        const timing = getTiming();
        const hand = document.createElement('div');
        hand.innerHTML = '🖐️';
        hand.style.position = 'absolute';
        hand.style.fontSize = VISUAL_CONSTANTS.HAND_EMOJI_SIZE + 'px';
        hand.style.pointerEvents = 'none';
        hand.style.zIndex = '1000';
        hand.style.transition = `all ${timing.HAND_MOVEMENT}ms ease`;
        hand.style.opacity = '0';
        parent.appendChild(hand);
        return hand;
      }

      /**
       * Main shuffle animation orchestrator
       * Coordinates: jiggle -> gather -> visible swaps -> deal to new positions
       * @param {NodeList} cards - Card elements to animate
       * @param {DOMRect} layerRect - Cards layer bounding rectangle
       * @param {Array} newShuffledOutcomes - New shuffle arrangement
       * @param {Function} callback - Callback after animation completes
       */
      function doShuffleAnimation(cards, layerRect, newShuffledOutcomes, callback) {
        const timing = getTiming();
        
        // Phase 1: Jiggle cards to show they're about to be shuffled
        cards.forEach(card => card.classList.add('show-border', 'jiggle'));

        setTimeout(() => {
          cards.forEach(card => card.classList.remove('jiggle'));
          const tableCenter = { 
            x: layerRect.width / 2, 
            y: layerRect.height / 2 
          };
          
          // Phase 2: Gather cards to center
          setTimeout(() => gatherCardsToCenter(cards, tableCenter), timing.GATHER_DELAY);

          // Phase 3: Create hands (if enabled) and perform visible swaps
          const hand1 = SHOW_HANDS ? createHandElement(AppState.dom.cardsLayer) : null;
          const hand2 = SHOW_HANDS ? createHandElement(AppState.dom.cardsLayer) : null;

          setTimeout(() => {
            performVisibleSwaps(cards, hand1, hand2, 8, () => {
              // Phase 4: Deal cards to new positions
              dealCardsToNewPositions(cards, hand1, hand2, newShuffledOutcomes, callback);
            });
          }, timing.GATHER_TO_SHUFFLE);
        }, timing.JIGGLE_DURATION);
      }

      /**
       * Gathers cards to center with random wobble
       * @param {NodeList} cards - Card elements
       * @param {Object} tableCenter - Center coordinates
       */
      function gatherCardsToCenter(cards, tableCenter) {
        cards.forEach((card) => {
          card.classList.add('hover');
          const wobbleX = (Math.random() - 0.5) * 100;
          const wobbleY = (Math.random() - 0.5) * 100;
          card.style.left = (tableCenter.x - VISUAL_CONSTANTS.CARD_WIDTH / 2 + wobbleX) + 'px';
          card.style.top = (tableCenter.y - VISUAL_CONSTANTS.CARD_HEIGHT / 2 + wobbleY) + 'px';
          card.style.transform = `translateZ(50px) scale(${VISUAL_CONSTANTS.CARD_HOVER_SCALE}) rotate(${(Math.random() - 0.5) * 30}deg)`;
        });
      }

      /**
       * Performs visible card swaps with hands
       * @param {NodeList} cards - Card elements
       * @param {HTMLElement} hand1 - First hand element (or null if hands disabled)
       * @param {HTMLElement} hand2 - Second hand element (or null if hands disabled)
       * @param {number} totalSwaps - Number of swaps to perform
       * @param {Function} onComplete - Completion callback
       */
      function performVisibleSwaps(cards, hand1, hand2, totalSwaps, onComplete) {
        const timing = getTiming();
        let swapCount = 0;
        
        function performSwap() {
          if (swapCount >= totalSwaps) {
            if (SHOW_HANDS && hand1 && hand2) {
              hand1.style.opacity = String(VISUAL_CONSTANTS.HAND_OPACITY_VISIBLE);
              hand2.style.opacity = String(VISUAL_CONSTANTS.HAND_OPACITY_VISIBLE);
            }
            setTimeout(onComplete, timing.SHUFFLE_TO_DEAL);
            return;
          }
          
          // Select two random cards
          const idx1 = Math.floor(Math.random() * cards.length);
          let idx2 = Math.floor(Math.random() * cards.length);
          while (idx2 === idx1) {
            idx2 = Math.floor(Math.random() * cards.length);
          }
          
          const card1 = cards[idx1];
          const card2 = cards[idx2];
          const pos1 = { left: parseFloat(card1.style.left), top: parseFloat(card1.style.top) };
          const pos2 = { left: parseFloat(card2.style.left), top: parseFloat(card2.style.top) };
          
          // Show hands moving to cards (if enabled)
          if (SHOW_HANDS && hand1 && hand2) {
            hand1.style.opacity = String(VISUAL_CONSTANTS.HAND_OPACITY_VISIBLE);
            hand2.style.opacity = String(VISUAL_CONSTANTS.HAND_OPACITY_VISIBLE);
            hand1.style.left = (pos1.left + 10) + 'px';
            hand1.style.top = (pos1.top - 35) + 'px';
            hand2.style.left = (pos2.left + 10) + 'px';
            hand2.style.top = (pos2.top - 35) + 'px';
          }
          
          setTimeout(() => {
            // Lift cards
            card1.style.transform = `translateZ(80px) scale(${VISUAL_CONSTANTS.CARD_LIFT_SCALE}) rotate(${(Math.random() - 0.5) * 40}deg)`;
            card2.style.transform = `translateZ(80px) scale(${VISUAL_CONSTANTS.CARD_LIFT_SCALE}) rotate(${(Math.random() - 0.5) * 40}deg)`;
            
            setTimeout(() => {
              // Swap positions
              card1.style.left = pos2.left + 'px';
              card1.style.top = pos2.top + 'px';
              card2.style.left = pos1.left + 'px';
              card2.style.top = pos1.top + 'px';
              
              // Move hands with cards (if enabled)
              if (SHOW_HANDS && hand1 && hand2) {
                hand1.style.left = (pos2.left + 10) + 'px';
                hand1.style.top = (pos2.top - 35) + 'px';
                hand2.style.left = (pos1.left + 10) + 'px';
                hand2.style.top = (pos1.top - 35) + 'px';
              }
              
              setTimeout(() => {
                // Set cards down
                card1.style.transform = `translateZ(50px) scale(${VISUAL_CONSTANTS.CARD_HOVER_SCALE}) rotate(${(Math.random() - 0.5) * 30}deg)`;
                card2.style.transform = `translateZ(50px) scale(${VISUAL_CONSTANTS.CARD_HOVER_SCALE}) rotate(${(Math.random() - 0.5) * 30}deg)`;
                
                // Hide hands briefly (if enabled)
                if (SHOW_HANDS && hand1 && hand2) {
                  hand1.style.opacity = '0';
                  hand2.style.opacity = '0';
                }
                
                swapCount++;
                setTimeout(performSwap, timing.SWAP_PAUSE);
              }, timing.SWAP_DURATION);
            }, timing.CARD_LIFT);
          }, timing.HAND_MOVEMENT);
        }
        
        performSwap();
      }

      /**
       * Deals cards to their new shuffled positions
       * @param {NodeList} cards - Card elements
       * @param {HTMLElement} hand1 - First hand element (or null if hands disabled)
       * @param {HTMLElement} hand2 - Second hand element (or null if hands disabled)
       * @param {Array} newShuffledOutcomes - New shuffle arrangement
       * @param {Function} callback - Completion callback
       */
      function dealCardsToNewPositions(cards, hand1, hand2, newShuffledOutcomes, callback) {
        const timing = getTiming();
        AppState.shuffledOutcomes = newShuffledOutcomes;
        
        const shuffledColumnCells = document.querySelectorAll('tbody td:nth-child(3)');
        const layerRect = AppState.dom.cardsLayer.getBoundingClientRect();
        
        const shuffledPositions = newShuffledOutcomes.map((obj, index) => ({ 
          outcome: obj.outcome, 
          position: index 
        }));
        
        if (SHOW_HANDS && hand1 && hand2) {
          hand1.style.opacity = String(VISUAL_CONSTANTS.HAND_OPACITY_DEALING);
          hand2.style.opacity = String(VISUAL_CONSTANTS.HAND_OPACITY_DEALING);
        }
        
        let dealIndex = 0;
        
        function dealNextCard() {
          if (dealIndex >= cards.length) {
            // Animation complete - clean up hands (if they exist)
            if (SHOW_HANDS && hand1 && hand2) {
              hand1.style.opacity = '0';
              hand2.style.opacity = '0';
              
              setTimeout(() => {
                if (hand1.parentNode) AppState.dom.cardsLayer.removeChild(hand1);
                if (hand2.parentNode) AppState.dom.cardsLayer.removeChild(hand2);
              }, timing.HAND_FADE);
            }
            
            setTimeout(() => {
              cards.forEach(card => { 
                card.style.transition = `all ${ANIMATION_TIMING.CARD_TRANSITION}ms cubic-bezier(.2,.8,.2,1)`;
                card.classList.remove('jiggle', 'hover');
              });
              
              if (callback) callback();
            }, ANIMATION_TIMING.CARD_TRANSITION);
            return;
          }
          
          const card = cards[dealIndex];
          const hand = SHOW_HANDS ? (dealIndex % 2 === 0 ? hand1 : hand2) : null;
          const outcomeValue = parseFloat(card.dataset.outcomeValue);
          const positionInfo = findAndRemovePosition(shuffledPositions, outcomeValue);
          
          if (positionInfo !== null) {
            const targetCell = shuffledColumnCells[positionInfo.position];
            const cellRect = targetCell.getBoundingClientRect();
            
            const centerX = cellRect.left - layerRect.left + (cellRect.width - VISUAL_CONSTANTS.CARD_WIDTH) / 2;
            const centerY = cellRect.top - layerRect.top + (cellRect.height - VISUAL_CONSTANTS.CARD_HEIGHT) / 2;
            
            // Position hand on card (if enabled)
            if (SHOW_HANDS && hand) {
              const currentCardLeft = parseFloat(card.style.left);
              const currentCardTop = parseFloat(card.style.top);
              hand.style.left = (currentCardLeft + 5) + 'px';
              hand.style.top = (currentCardTop - 30) + 'px';
            }
            
            setTimeout(() => {
              // Push card (and hand if enabled) together
              card.style.transition = 'all 0.35s cubic-bezier(.4,.0,.2,1)';
              if (SHOW_HANDS && hand) {
                hand.style.transition = 'all 0.35s cubic-bezier(.4,.0,.2,1)';
              }
              
              card.style.transform = 'none';
              card.classList.remove('hover');
              card.style.left = centerX + 'px';
              card.style.top = centerY + 'px';
              card.style.width = VISUAL_CONSTANTS.CARD_WIDTH + 'px';
              card.style.height = VISUAL_CONSTANTS.CARD_HEIGHT + 'px';
              
              if (SHOW_HANDS && hand) {
                hand.style.left = (centerX + 5) + 'px';
                hand.style.top = (centerY - 30) + 'px';
              }
              
              dealIndex++;
              setTimeout(dealNextCard, timing.DEAL_INTERVAL);
            }, timing.DEAL_CARD_DELAY);
          } else {
            dealIndex++;
            dealNextCard();
          }
        }
        
        dealNextCard();
      }

      // ============================================================================
      // SHUFFLE ORCHESTRATION
      // ============================================================================

      /**
       * Performs shuffle for graphing (with animation)
       * @param {Function} callback - Completion callback
       */
      function performShuffleForGraph(callback = null) {
        const outcomeObjects = AppState.currentData.map(r => ({ 
          outcome: r.outcome, 
          originalIndex: r.originalIndex 
        }));
        const newShuffledOutcomes = shuffleArray(outcomeObjects);
        
        const cards = AppState.dom.cardsLayer.querySelectorAll('.card');
        const layerRect = AppState.dom.cardsLayer.getBoundingClientRect();
        
        // If there's a previous shuffle, return cards to origin first
        if (AppState.shuffledOutcomes.length > 0) {
          returnCardsToOrigin(cards, layerRect, () => {
            doShuffleAnimation(cards, layerRect, newShuffledOutcomes, callback);
          });
        } else {
          doShuffleAnimation(cards, layerRect, newShuffledOutcomes, callback);
        }
      }

      /**
       * Performs shuffle with statistics tracking (with animation)
       * @param {Function} callback - Completion callback
       */
      function performShuffle(callback = null) {
        const outcomeObjects = AppState.currentData.map(r => ({ 
          outcome: r.outcome, 
          originalIndex: r.originalIndex 
        }));
        const newShuffledOutcomes = shuffleArray(outcomeObjects);
        
        const cards = AppState.dom.cardsLayer.querySelectorAll('.card');
        const layerRect = AppState.dom.cardsLayer.getBoundingClientRect();
        
        // If there's a previous shuffle, return cards to origin first
        if (AppState.shuffledOutcomes.length > 0) {
          returnCardsToOrigin(cards, layerRect, () => {
            doShuffleAnimation(cards, layerRect, newShuffledOutcomes, () => {
              finishShuffle(callback);
            });
          });
        } else {
          doShuffleAnimation(cards, layerRect, newShuffledOutcomes, () => {
            finishShuffle(callback);
          });
        }
      }

      /**
       * Returns cards to their original outcome column positions
       * @param {NodeList} cards - Card elements
       * @param {DOMRect} layerRect - Cards layer bounding rectangle
       * @param {Function} callback - Completion callback
       */
      function returnCardsToOrigin(cards, layerRect, callback) {
        const originalCells = document.querySelectorAll('tbody td:nth-child(2)');
        const availablePositions = AppState.currentData.map((data, index) => ({ 
          outcome: data.outcome, 
          position: index 
        }));
        
        cards.forEach((card) => {
          const outcomeValue = parseFloat(card.dataset.outcomeValue);
          const positionInfo = findAndRemovePosition(availablePositions, outcomeValue);
          
          if (positionInfo !== null) {
            const targetCell = originalCells[positionInfo.position];
            const cellRect = targetCell.getBoundingClientRect();
            
            const centerX = cellRect.left - layerRect.left + (cellRect.width - VISUAL_CONSTANTS.CARD_WIDTH) / 2;
            const centerY = cellRect.top - layerRect.top + (cellRect.height - VISUAL_CONSTANTS.CARD_HEIGHT) / 2;
            
            card.style.transition = `all ${ANIMATION_TIMING.RESET_TRANSITION}ms cubic-bezier(.25,.46,.45,.94)`;
            card.style.left = centerX + 'px';
            card.style.top = centerY + 'px';
            card.style.width = VISUAL_CONSTANTS.CARD_WIDTH + 'px';
            card.style.height = VISUAL_CONSTANTS.CARD_HEIGHT + 'px';
          }
        });
        
        setTimeout(callback, ANIMATION_TIMING.RETURN_TO_ORIGIN);
      }

      /**
       * Completes shuffle by updating statistics and UI
       * @param {Function} callback - Completion callback
       */
      function finishShuffle(callback) {
        const stats = calculateStats();
        AppState.lastBatchSize = 1;
        addSampleToHistogram(stats.diff);
        
        AppState.shuffleResults.push(stats.diff);
        updateShuffleOutput();
        
        if (callback) callback();
      }

      /**
       * Updates the shuffle output display
       */
      function updateShuffleOutput() {
        const shuffleOutput = getElement('shuffleOutput');
        const samplingShuffleOutput = getElement('samplingShuffleOutput');
        
        if (!shuffleOutput && !samplingShuffleOutput) return;
        
        const maxIntegerDigits = Math.max(...AppState.shuffleResults.map(result => {
          const formatted = formatNumber(result);
          const beforeDecimal = formatted.split('.')[0];
          return beforeDecimal.replace('-', '').length;
        }));
        
        const recentResults = AppState.shuffleResults.slice(-10);
        const outputText = formatShuffleResults(recentResults, maxIntegerDigits);
        
        if (shuffleOutput) {
          shuffleOutput.textContent = outputText;
          shuffleOutput.style.display = 'block';
        }
        if (samplingShuffleOutput) {
          samplingShuffleOutput.textContent = outputText;
          samplingShuffleOutput.style.display = 'block';
        }
      }

      /**
       * Formats shuffle results for display
       * @param {number[]} results - Results to format
       * @param {number} maxIntegerDigits - Maximum integer digits for alignment
       * @returns {string} Formatted output text
       */
      function formatShuffleResults(results, maxIntegerDigits) {
        let outputText = results.map((result, index) => {
          const globalIndex = AppState.shuffleResults.length - results.length + index;
          const isRecent = globalIndex === AppState.shuffleResults.length - 1;
          const pointer = isRecent ? '▶ ' : '  ';
          const formatted = formatNumber(result);
          const beforeDecimal = formatted.split('.')[0];
          const afterDecimal = formatted.split('.')[1] || '0';
          
          const integerPart = beforeDecimal.replace('-', '');
          const paddingNeeded = maxIntegerDigits - integerPart.length;
          const sign = beforeDecimal.startsWith('-') ? '-' : ' ';
          const padding = ' '.repeat(paddingNeeded);
          
          return `${pointer}${sign}${padding}${integerPart}.${afterDecimal}`;
        }).join('\n');
        
        if (AppState.shuffleResults.length > 10) {
          outputText = `... (showing last 10 of ${AppState.shuffleResults.length} results)\n` + outputText;
        }
        
        return outputText;
      }

      /**
       * Runs multiple shuffles without animation for sampling distribution
       * @param {number} count - Number of shuffles to run
       */
      function runMultipleShuffles(count) {
        const run5xBtn = getElement('run5xBtn');
        if (run5xBtn) {
          run5xBtn.disabled = true;
          run5xBtn.textContent = 'Running...';
        }
        
        AppState.lastBatchSize = 0;
        let completed = 0;
        
        function runBatch() {
          const batchSize = Math.min(10, count - completed);
          
          for (let i = 0; i < batchSize; i++) {
            const outcomeObjects = AppState.currentData.map(r => ({ 
              outcome: r.outcome, 
              originalIndex: r.originalIndex 
            }));
            const newShuffledOutcomes = shuffleArray(outcomeObjects);
            
            const tempGroupData = AppState.currentData.map((row, index) => ({
              group: row.group,
              outcome: newShuffledOutcomes[index].outcome
            }));
            
            const groupA = tempGroupData.filter(r => r.group === CONFIG.groupAName).map(r => r.outcome);
            const groupB = tempGroupData.filter(r => r.group === CONFIG.groupBName).map(r => r.outcome);
            const meanA = mean(groupA);
            const meanB = mean(groupB);
            
            const sortedGroups = [
              { name: CONFIG.groupAName, mean: meanA },
              { name: CONFIG.groupBName, mean: meanB }
            ].sort((a, b) => a.name.localeCompare(b.name));
            
            const diff = sortedGroups[1].mean - sortedGroups[0].mean;
            
            addSampleToHistogram(diff);
            AppState.shuffleResults.push(diff);
          }
          
          completed += batchSize;
          
          if (completed < count) {
            setTimeout(runBatch, 10);
          } else {
            if (run5xBtn) {
              run5xBtn.disabled = false;
              run5xBtn.textContent = 'Run 5x';
            }
            updateShuffleOutput();
          }
        }
        
        runBatch();
      }

      // ============================================================================
      // HISTOGRAM RENDERING
      // ============================================================================

      /**
       * Adds a sample to the histogram
       * @param {number} diff - Difference value to add
       */
      function addSampleToHistogram(diff) {
        AppState.diffHistory.push(diff);
        renderHistogram();
      }

      /**
       * Renders the sampling distribution histogram
       */
      function renderHistogram() {
        const svg = getElement('histSvg');
        const countEl = getElement('distCount');
        const summaryEl = getElement('distSummary');
        
        if (!svg || !countEl || !summaryEl || !AppState.histConfig) return;
        
        countEl.textContent = String(AppState.diffHistory.length);

        // Update summary statistics
        if (AppState.diffHistory.length >= 3) {
          const distMean = mean(AppState.diffHistory);
          const distSD = Math.sqrt(
            AppState.diffHistory.reduce((s, x) => s + (x - distMean) * (x - distMean), 0) / 
            (AppState.diffHistory.length - 1)
          );
          summaryEl.innerHTML = `Mean: ${formatNumber(distMean)} | SE: ${formatNumber(distSD)}`;
        } else {
          summaryEl.innerHTML = '';
        }

        // Clear and redraw
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        const dims = SVG_DIMENSIONS.HISTOGRAM;
        const chartW = dims.width - dims.margin.left - dims.margin.right;
        const chartH = dims.height - dims.margin.top - dims.margin.bottom;

        const { xMin, xMax, bins, binW } = AppState.histConfig;
        const binDots = Array.from({ length: bins }, () => []);
        
        // Distribute samples into bins
        AppState.diffHistory.forEach((v, historyIndex) => {
          let binIdx = Math.floor((v - xMin) / binW);
          if (binIdx < 0) binIdx = 0;
          if (binIdx >= bins) binIdx = bins - 1;
          binDots[binIdx].push(historyIndex);
        });
        
        // Auto-scale Y axis if needed
        const maxCount = Math.max(0, ...binDots.map(bin => bin.length));
        while (AppState.histConfig.yStepIdx < HISTOGRAM_CONFIG.Y_STEPS.length - 1 && 
               maxCount > HISTOGRAM_CONFIG.Y_STEPS[AppState.histConfig.yStepIdx]) {
          AppState.histConfig.yStepIdx++;
          AppState.histConfig.yMax = HISTOGRAM_CONFIG.Y_STEPS[AppState.histConfig.yStepIdx];
        }
        const yMax = AppState.histConfig.yMax;

        // Draw X axis
        createSVGElement('line', {
          x1: dims.margin.left,
          x2: dims.margin.left + chartW,
          y1: dims.margin.top + chartH,
          y2: dims.margin.top + chartH,
          stroke: 'var(--axis)'
        }, svg);

        // Draw Y axis ticks
        const yTicks = [0, yMax / 2, yMax];
        yTicks.forEach(v => {
          const y = dims.margin.top + chartH - (v / yMax) * chartH;
          createSVGElement('line', {
            x1: dims.margin.left - 4,
            x2: dims.margin.left,
            y1: y,
            y2: y,
            stroke: 'var(--axis)'
          }, svg);
          
          const t = createSVGElement('text', {
            x: dims.margin.left - 8,
            y: y + 4,
            'text-anchor': 'end',
            'font-size': '14',
            fill: '#333'
          }, svg);
          t.textContent = String(Math.round(v));
        });

        // Draw histogram bars
        const rectHeight = chartH / yMax;
        const binWidthPixels = chartW / bins;
        const rectWidth = binWidthPixels - 1;
        
        let mostRecentBinX = null;
        let mostRecentValue = null;
        let mostRecentY = null;
        
        binDots.forEach((dots, binIdx) => {
          const binLeftX = dims.margin.left + (binIdx * chartW) / bins;
          
          dots.forEach((historyIndex, dotIdx) => {
            const y = dims.margin.top + chartH - (dotIdx + 1) * rectHeight;
            const isRecent = AppState.lastBatchSize === 1 && 
                           historyIndex === AppState.diffHistory.length - 1;
            
            if (isRecent) {
              mostRecentBinX = binLeftX + rectWidth / 2;
              mostRecentValue = AppState.diffHistory[historyIndex];
              mostRecentY = y;
            }
            
            createSVGElement('rect', {
              x: binLeftX + 0.5,
              y: y,
              width: rectWidth,
              height: rectHeight,
              fill: isRecent ? 'var(--dot-recent)' : 'var(--dot)',
              stroke: 'white',
              'stroke-width': 1
            }, svg);
          });
        });
        
        // Label most recent value
        if (mostRecentBinX !== null && mostRecentValue !== null) {
          const labelText = createSVGElement('text', {
            x: mostRecentBinX,
            y: mostRecentY - 8,
            'text-anchor': 'middle',
            'font-size': '12',
            'font-weight': 'bold',
            fill: '#d97706'
          }, svg);
          labelText.textContent = formatNumber(mostRecentValue);
        }

        // Draw X axis labels
        for (let i = 0; i < bins; i++) {
          const binCenter = xMin + (i + 0.5) * binW;
          const x = dims.margin.left + ((i + 0.5) * chartW) / bins;
          
          createSVGElement('line', {
            x1: x,
            x2: x,
            y1: dims.margin.top + chartH,
            y2: dims.margin.top + chartH + 4,
            stroke: 'var(--axis)'
          }, svg);
          
          const t = createSVGElement('text', {
            x: x,
            y: dims.margin.top + chartH + 20,
            'text-anchor': 'middle',
            'font-size': '12',
            fill: '#333'
          }, svg);
          
          t.textContent = Math.abs(binCenter) < 0.0001 ? "0" : formatNumber(binCenter);
        }

        // Draw original difference marker
        if (AppState.originalDiff !== null && isFinite(AppState.originalDiff)) {
          const span = xMax - xMin;
          const x0 = dims.margin.left + ((AppState.originalDiff - xMin) / span) * chartW;
          const y0 = dims.margin.top + chartH;
          createSVGElement('circle', {
            cx: x0,
            cy: y0,
            r: 6,
            fill: 'var(--original-dot)',
            stroke: 'white',
            'stroke-width': 1.5
          }, svg);
        }

        // Draw mean line
        if (AppState.diffHistory.length >= 3) {
          const distMean = mean(AppState.diffHistory);
          const span = xMax - xMin;
          const x0 = dims.margin.left + ((distMean - xMin) / span) * chartW;
          
          createSVGElement('line', {
            x1: x0,
            x2: x0,
            y1: dims.margin.top,
            y2: dims.margin.top + chartH,
            stroke: '#2563eb',
            'stroke-width': 2,
            'stroke-dasharray': '4,2'
          }, svg);
        }

        // Y axis label
        const yLabel = createSVGElement('text', {
          x: 15,
          y: dims.margin.top + chartH / 2,
          'text-anchor': 'middle',
          'font-size': '18',
          'font-weight': 'bold',
          fill: '#666',
          transform: `rotate(-90, 15, ${dims.margin.top + chartH / 2})`
        }, svg);
        yLabel.textContent = 'Number of b₁s';
      }

      // ============================================================================
      // GRAPH GENERATION UTILITIES
      // ============================================================================

      /**
       * Creates Y-scale function for graphs
       * @param {number} minY - Minimum Y value
       * @param {number} maxY - Maximum Y value
       * @param {number} plotHeight - Plot height in pixels
       * @returns {Function} Scale function
       */
      function createYScale(minY, maxY, plotHeight) {
        return (value) => plotHeight - ((value - minY) / (maxY - minY)) * plotHeight;
      }

      /**
       * Calculates Y-axis range with padding
       * @param {number[]} outcomes - All outcome values
       * @returns {Object} Min and max Y values
       */
      function calculateYRange(outcomes) {
        const dataMin = Math.min(...outcomes);
        const dataMax = Math.max(...outcomes);
        const range = dataMax - dataMin;
        const padding = range * HISTOGRAM_CONFIG.AXIS_PADDING_RATIO;
        return {
          minY: dataMin - padding,
          maxY: dataMax + padding
        };
      }

      /**
       * Draws axes for scatter plots
       * @param {SVGElement} g - Group element
       * @param {Object} dims - Dimensions object
       * @param {number} plotWidth - Plot width
       * @param {number} plotHeight - Plot height
       */
      function drawAxes(g, dims, plotWidth, plotHeight) {
        // Y axis
        createSVGElement('line', {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: plotHeight,
          stroke: '#666',
          'stroke-width': 2
        }, g);
        
        // X axis
        createSVGElement('line', {
          x1: 0,
          y1: plotHeight,
          x2: plotWidth,
          y2: plotHeight,
          stroke: '#666',
          'stroke-width': 2
        }, g);
      }

      /**
       * Draws Y-axis ticks and labels
       * @param {SVGElement} g - Group element
       * @param {number} minY - Minimum Y value
       * @param {number} maxY - Maximum Y value
       * @param {Function} yScale - Y scale function
       * @param {number} plotHeight - Plot height
       */
      function drawYTicks(g, minY, maxY, yScale, plotHeight) {
        const yRange = maxY - minY;
        const yStep = Math.ceil(yRange / 4);
        const yTicks = [];
        const startTick = Math.ceil(minY / yStep) * yStep;
        for (let i = startTick; i <= maxY; i += yStep) {
          yTicks.push(i);
        }
        
        yTicks.forEach(tick => {
          const y = yScale(tick);
          createSVGElement('line', {
            x1: -5,
            y1: y,
            x2: 0,
            y2: y,
            stroke: '#666'
          }, g);
          
          const label = createSVGElement('text', {
            x: -10,
            y: y + 4,
            'text-anchor': 'end',
            'font-size': '14',
            'font-weight': 'normal',
            fill: '#333'
          }, g);
          label.textContent = String(tick);
        });
      }

      /**
       * Draws group labels on X axis
       * @param {SVGElement} g - Group element
       * @param {number} plotWidth - Plot width
       * @param {number} plotHeight - Plot height
       */
      function drawGroupLabels(g, plotWidth, plotHeight, fontSize = '18') {
        const groupAX = plotWidth * 0.25;
        const groupBX = plotWidth * 0.75;
        
        const labelA = createSVGElement('text', {
          x: groupAX,
          y: plotHeight + 25,
          'text-anchor': 'middle',
          'font-size': fontSize,
          'font-weight': 'bold',
          fill: '#333'
        }, g);
        labelA.textContent = CONFIG.groupAName;
        
        const labelB = createSVGElement('text', {
          x: groupBX,
          y: plotHeight + 25,
          'text-anchor': 'middle',
          'font-size': fontSize,
          'font-weight': 'bold',
          fill: '#333'
        }, g);
        labelB.textContent = CONFIG.groupBName;
      }

      /**
       * Draws data points on scatter plot
       * @param {SVGElement} g - Group element
       * @param {Array} groupA - Group A data
       * @param {Array} groupB - Group B data
       * @param {Function} yScale - Y scale function
       * @param {number} plotWidth - Plot width
       * @param {number} radius - Point radius
       */
      function drawDataPoints(g, groupA, groupB, yScale, plotWidth, radius = 5) {
        const groupAX = plotWidth * 0.25;
        const groupBX = plotWidth * 0.75;
        
        groupA.forEach((point) => {
          const originalGroup = AppState.outcomeOrigins.get(point.originalIndex);
          const isOriginalGroupA = originalGroup === CONFIG.groupAName;
          
          createSVGElement('circle', {
            cx: groupAX,
            cy: yScale(point.outcome),
            r: radius,
            fill: isOriginalGroupA ? 'var(--group-a-dot)' : 'var(--group-b-dot)',
            stroke: isOriginalGroupA ? '#1e40af' : '#d97706',
            'stroke-width': 1,
            opacity: 0.8
          }, g);
        });
        
        groupB.forEach((point) => {
          const originalGroup = AppState.outcomeOrigins.get(point.originalIndex);
          const isOriginalGroupA = originalGroup === CONFIG.groupAName;
          
          createSVGElement('circle', {
            cx: groupBX,
            cy: yScale(point.outcome),
            r: radius,
            fill: isOriginalGroupA ? 'var(--group-a-dot)' : 'var(--group-b-dot)',
            stroke: isOriginalGroupA ? '#1e40af' : '#d97706',
            'stroke-width': 1,
            opacity: 0.8
          }, g);
        });
      }

      /**
       * Draws mean lines on scatter plot
       * @param {SVGElement} g - Group element
       * @param {number} meanA - Group A mean
       * @param {number} meanB - Group B mean
       * @param {Function} yScale - Y scale function
       * @param {number} plotWidth - Plot width
       * @param {number} lineWidth - Line width
       */
      function drawMeanLines(g, meanA, meanB, yScale, plotWidth, lineWidth = 30) {
        const groupAX = plotWidth * 0.25;
        const groupBX = plotWidth * 0.75;
        
        createSVGElement('line', {
          x1: groupAX - lineWidth,
          y1: yScale(meanA),
          x2: groupAX + lineWidth,
          y2: yScale(meanA),
          stroke: '#000',
          'stroke-width': 3
        }, g);
        
        createSVGElement('line', {
          x1: groupBX - lineWidth,
          y1: yScale(meanB),
          x2: groupBX + lineWidth,
          y2: yScale(meanB),
          stroke: '#000',
          'stroke-width': 3
        }, g);
      }

      /**
       * Calculates b1 value from group data
       * @param {Array} groupA - Group A data
       * @param {Array} groupB - Group B data
       * @returns {number} b1 value
       */
      function calculateB1(groupA, groupB) {
        const meanA = mean(groupA.map(d => d.outcome));
        const meanB = mean(groupB.map(d => d.outcome));
        
        const sortedGroups = [
          { name: CONFIG.groupAName, mean: meanA },
          { name: CONFIG.groupBName, mean: meanB }
        ].sort((a, b) => a.name.localeCompare(b.name));
        
        return sortedGroups[1].mean - sortedGroups[0].mean;
      }

      // ============================================================================
      // SMALL GRAPH GENERATION (for Shuffle 1 tab)
      // ============================================================================

      /**
       * Regenerates all graphing graphs when show/hide means is toggled
       */
      function regenerateAllGraphingGraphs() {
        const container = getElement('smallGraphsContainer');
        if (!container) return;
        
        container.innerHTML = '';
        generateOriginalDataGraph();
        
        AppState.graphingShuffleHistory.forEach((graphInfo) => {
          generateSmallShuffleGraphWithStoredData(graphInfo);
        });
      }

      /**
       * Generates the original data graph (before any shuffles)
       */
      function generateOriginalDataGraph() {
        const container = getElement('smallGraphsContainer');
        if (!container) return;
        
        const graphDiv = document.createElement('div');
        graphDiv.style.cssText = 'border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; background: white;';
        graphDiv.id = 'originalDataGraph';
        
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '180');
        svg.setAttribute('viewBox', '0 0 180 150');
        svg.style.display = 'block';
        
        const groupA = AppState.currentData.filter(r => r.group === CONFIG.groupAName);
        const groupB = AppState.currentData.filter(r => r.group === CONFIG.groupBName);
        
        renderSmallGraph(svg, groupA, groupB, 'Data', AppState.showGraphingMeans);
        
        graphDiv.appendChild(svg);
        container.appendChild(graphDiv);
      }

      /**
       * Generates a small shuffle graph
       */
      function generateSmallShuffleGraph() {
        if (AppState.smallGraphCount >= VISUAL_CONSTANTS.MAX_SMALL_GRAPHS) {
          clearGraphingPlots();
        }
        
        const dataToPlot = getShuffledDataForPlot();
        const groupA = dataToPlot.filter(r => r.group === CONFIG.groupAName);
        const groupB = dataToPlot.filter(r => r.group === CONFIG.groupBName);
        
        const meanA = mean(groupA.map(d => d.outcome));
        const meanB = mean(groupB.map(d => d.outcome));
        const shuffleNumber = AppState.graphingShuffleHistory.length + 1;
        
        AppState.graphingShuffleHistory.push({
          data: dataToPlot,
          meanA: meanA,
          meanB: meanB,
          shuffleNumber: shuffleNumber
        });
        
        const container = getElement('smallGraphsContainer');
        if (!container) return;
        
        const graphDiv = document.createElement('div');
        graphDiv.style.cssText = 'border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; background: white;';
        
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '180');
        svg.setAttribute('viewBox', '0 0 180 150');
        svg.style.display = 'block';
        
        renderSmallGraph(svg, groupA, groupB, `Shuffle ${shuffleNumber}`, AppState.showGraphingMeans, meanA, meanB);
        
        graphDiv.appendChild(svg);
        container.appendChild(graphDiv);
      }

      /**
       * Gets shuffled data for plotting
       * @returns {Array} Data to plot
       */
      function getShuffledDataForPlot() {
        if (AppState.shuffledOutcomes.length > 0) {
          return AppState.currentData.map((row, index) => ({
            group: row.group,
            outcome: AppState.shuffledOutcomes[index].outcome,
            originalIndex: AppState.shuffledOutcomes[index].originalIndex
          }));
        } else {
          const outcomeObjects = AppState.currentData.map(r => ({ 
            outcome: r.outcome, 
            originalIndex: r.originalIndex 
          }));
          const newShuffledOutcomes = shuffleArray(outcomeObjects);
          return AppState.currentData.map((row, index) => ({
            group: row.group,
            outcome: newShuffledOutcomes[index].outcome,
            originalIndex: newShuffledOutcomes[index].originalIndex
          }));
        }
      }

      /**
       * Generates a small shuffle graph with stored data
       * @param {Object} graphInfo - Graph information object
       */
      function generateSmallShuffleGraphWithStoredData(graphInfo) {
        const container = getElement('smallGraphsContainer');
        if (!container) return;
        
        const graphDiv = document.createElement('div');
        graphDiv.style.cssText = 'border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; background: white;';
        
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '180');
        svg.setAttribute('viewBox', '0 0 180 150');
        svg.style.display = 'block';
        
        const groupA = graphInfo.data.filter(r => r.group === CONFIG.groupAName);
        const groupB = graphInfo.data.filter(r => r.group === CONFIG.groupBName);
        
        renderSmallGraph(
          svg, 
          groupA, 
          groupB, 
          `Shuffle ${graphInfo.shuffleNumber}`, 
          AppState.showGraphingMeans,
          graphInfo.meanA,
          graphInfo.meanB
        );
        
        graphDiv.appendChild(svg);
        container.appendChild(graphDiv);
      }

      /**
       * Renders a small graph (utility function to reduce duplication)
       * @param {SVGElement} svg - SVG element
       * @param {Array} groupA - Group A data
       * @param {Array} groupB - Group B data
       * @param {string} title - Graph title
       * @param {boolean} showMeans - Whether to show mean lines
       * @param {number} storedMeanA - Stored mean for group A (optional)
       * @param {number} storedMeanB - Stored mean for group B (optional)
       */
      function renderSmallGraph(svg, groupA, groupB, title, showMeans, storedMeanA = null, storedMeanB = null) {
        const dims = SVG_DIMENSIONS.SMALL_GRAPH;
        const plotWidth = dims.width - dims.margin.left - dims.margin.right;
        const plotHeight = dims.height - dims.margin.top - dims.margin.bottom;
        
        const g = createSVGElement('g', {
          transform: `translate(${dims.margin.left},${dims.margin.top})`
        }, svg);
        
        const allOutcomes = [...groupA, ...groupB].map(d => d.outcome);
        const { minY, maxY } = calculateYRange(allOutcomes);
        const yScale = createYScale(minY, maxY, plotHeight);
        
        drawAxes(g, dims, plotWidth, plotHeight);
        drawGroupLabels(g, plotWidth, plotHeight, '10');
        drawDataPoints(g, groupA, groupB, yScale, plotWidth, 3);
        
        if (showMeans) {
          const meanA = storedMeanA !== null ? storedMeanA : mean(groupA.map(d => d.outcome));
          const meanB = storedMeanB !== null ? storedMeanB : mean(groupB.map(d => d.outcome));
          drawMeanLines(g, meanA, meanB, yScale, plotWidth, 20);
        }
        
        // Title
        const titleEl = createSVGElement('text', {
          x: plotWidth / 2,
          y: -5,
          'text-anchor': 'middle',
          'font-size': '12',
          'font-weight': 'bold',
          fill: '#333'
        }, g);
        titleEl.textContent = title;
        
        // b1 label
        const meanA = storedMeanA !== null ? storedMeanA : mean(groupA.map(d => d.outcome));
        const meanB = storedMeanB !== null ? storedMeanB : mean(groupB.map(d => d.outcome));
        const currentB1 = calculateB1(
          groupA.map(d => ({ outcome: d.outcome })), 
          groupB.map(d => ({ outcome: d.outcome }))
        );
        
        const b1Label = createSVGElement('text', {
          x: plotWidth / 2,
          y: plotHeight + 22,
          'text-anchor': 'middle',
          'font-size': '10',
          'font-weight': 'bold',
          fill: '#666'
        }, g);
        b1Label.textContent = `b₁ = ${formatNumber(currentB1)}`;
      }

      /**
       * Clears all graphing plots
       */
      function clearGraphingPlots() {
        const container = getElement('smallGraphsContainer');
        if (!container) return;
        
        container.innerHTML = '';
        AppState.smallGraphCount = 0;
        AppState.graphingShuffleHistory = [];
        
        AppState.shuffledOutcomes = [];
        
        const cards = AppState.dom.cardsLayer.querySelectorAll('.card');
        cards.forEach(card => {
          card.classList.remove('show-border', 'jiggle', 'hover');
          card.style.transition = `all ${ANIMATION_TIMING.CARD_TRANSITION}ms cubic-bezier(.2,.8,.2,1)`;
        });
        
        setTimeout(() => repositionCards(), 50);
        generateOriginalDataGraph();
      }

      // ============================================================================
      // LARGE SCATTER PLOT GENERATION
      // ============================================================================

      /**
       * Generates the main scatter plot
       */
      function generateScatterPlot() {
        const output = getElement('plotOutput');
        const svg = getElement('scatterSvg');
        if (!output || !svg) return;
        
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        
        const groupA = AppState.currentData.filter(r => r.group === CONFIG.groupAName);
        const groupB = AppState.currentData.filter(r => r.group === CONFIG.groupBName);
        
        AppState.currentPlotData = { groupA, groupB };
        
        renderLargeScatterPlot(svg, groupA, groupB, AppState.showMeans, 
          `${CONFIG.outcomeName} by ${CONFIG.groupName}`);
        
        output.style.display = 'block';
      }

      /**
       * Generates the shuffle scatter plot
       */
      function generateShuffleScatterPlot() {
        const output = getElement('shufflePlotOutput');
        const svg = getElement('shuffleScatterSvg');
        if (!output || !svg) return;
        
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        
        const dataToPlot = getShuffledDataForPlot();
        const groupA = dataToPlot.filter(r => r.group === CONFIG.groupAName);
        const groupB = dataToPlot.filter(r => r.group === CONFIG.groupBName);
        
        renderLargeScatterPlot(svg, groupA, groupB, AppState.showShuffleMeans, 
          `${CONFIG.outcomeName}_shuf by ${CONFIG.groupName}`);
        
        output.style.display = 'block';
      }

      /**
       * Renders a large scatter plot (utility function to reduce duplication)
       * @param {SVGElement} svg - SVG element
       * @param {Array} groupA - Group A data
       * @param {Array} groupB - Group B data
       * @param {boolean} showMeans - Whether to show mean lines
       * @param {string} title - Plot title
       */
      function renderLargeScatterPlot(svg, groupA, groupB, showMeans, title) {
        const dims = SVG_DIMENSIONS.LARGE_GRAPH;
        const svgWidth = dims.width;
        const svgHeight = dims.height;
        const plotWidth = svgWidth - dims.margin.left - dims.margin.right;
        const plotHeight = svgHeight - dims.margin.top - dims.margin.bottom;
        
        svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
        
        const g = createSVGElement('g', {
          transform: `translate(${dims.margin.left},${dims.margin.top})`
        }, svg);
        
        const allOutcomes = [...groupA, ...groupB].map(d => d.outcome);
        const { minY, maxY } = calculateYRange(allOutcomes);
        const yScale = createYScale(minY, maxY, plotHeight);
        
        drawAxes(g, dims, plotWidth, plotHeight);
        drawYTicks(g, minY, maxY, yScale, plotHeight);
        drawGroupLabels(g, plotWidth, plotHeight);
        drawDataPoints(g, groupA, groupB, yScale, plotWidth);
        
        if (showMeans) {
          const meanA = mean(groupA.map(d => d.outcome));
          const meanB = mean(groupB.map(d => d.outcome));
          drawMeanLines(g, meanA, meanB, yScale, plotWidth);
        }
        
        // Title
        const titleEl = createSVGElement('text', {
          x: plotWidth / 2,
          y: -10,
          'text-anchor': 'middle',
          'font-size': '20',
          'font-weight': 'bold',
          fill: '#333'
        }, g);
        titleEl.textContent = title;
        
        // Y-axis label
        const yLabel = createSVGElement('text', {
          x: -35,
          y: plotHeight / 2,
          'text-anchor': 'middle',
          'font-size': '18',
          'font-weight': 'bold',
          fill: '#666',
          transform: `rotate(-90, -35, ${plotHeight / 2})`
        }, g);
        yLabel.textContent = CONFIG.outcomeName;
      }

      // ============================================================================
      // R OUTPUT DISPLAY
      // ============================================================================

      /**
       * Shows R model output
       * @param {string} command - R command string
       */
      function showROutput(command) {
        const output = getElement('rOutput');
        if (!output) return;
        
        const groupA = AppState.currentData.filter(r => r.group === CONFIG.groupAName).map(r => r.outcome);
        const groupB = AppState.currentData.filter(r => r.group === CONFIG.groupBName).map(r => r.outcome);
        const meanA = mean(groupA);
        const meanB = mean(groupB);
        
        const sortedGroups = [
          { name: CONFIG.groupAName, mean: meanA },
          { name: CONFIG.groupBName, mean: meanB }
        ].sort((a, b) => a.name.localeCompare(b.name));
        
        const b0 = sortedGroups[0].mean;
        const b1 = sortedGroups[1].mean - sortedGroups[0].mean;
        
        let outputText;
        if (command.toLowerCase().startsWith('lm(')) {
          outputText = `Call:
lm(formula = ${CONFIG.outcomeName} ~ ${CONFIG.groupName})

Coefficients:
            Estimate
(Intercept)   ${formatNumber(b0)}
${sortedGroups[1].name.padEnd(11)} ${formatNumber(b1)}`;
        } else {
          outputText = `${formatNumber(b1)}`;
        }
        
        output.textContent = outputText;
        output.style.display = 'block';
      }

      /**
       * Shows b1 value
       */
      function showB1Output() {
        const output = getElement('b1Output');
        if (!output) return;
        
        const groupA = AppState.currentData.filter(r => r.group === CONFIG.groupAName);
        const groupB = AppState.currentData.filter(r => r.group === CONFIG.groupBName);
        const b1 = calculateB1(groupA, groupB);
        
        output.textContent = formatNumber(b1);
        output.style.display = 'block';
      }

      /**
       * Clears shuffle data and resets UI
       */
      function clearShuffleData() {
        const shuffleOutput = getElement('shuffleOutput');
        const samplingShuffleOutput = getElement('samplingShuffleOutput');
        if (shuffleOutput) shuffleOutput.style.display = 'none';
        if (samplingShuffleOutput) samplingShuffleOutput.style.display = 'none';
        
        AppState.shuffleResults = [];
        AppState.diffHistory = [];
        AppState.shuffledOutcomes = [];
        
        const cards = AppState.dom.cardsLayer.querySelectorAll('.card');
        cards.forEach(card => {
          card.classList.remove('show-border', 'jiggle', 'hover');
          card.style.transition = `all ${ANIMATION_TIMING.CARD_TRANSITION}ms cubic-bezier(.2,.8,.2,1)`;
        });
        
        repositionCards();
        renderHistogram();
      }

      // ============================================================================
      // EVENT HANDLERS
      // ============================================================================

      /**
       * Sets up all event handlers for the application
       */
      function setupEventHandlers() {
        // Collapsible section handlers
        setupCollapsibleSections();
        
        // Tab navigation
        setupTabs();
        
        // Shuffle buttons
        setupShuffleButtons();
        
        // Clear buttons
        setupClearButtons();
        
        // Plot generation buttons
        setupPlotButtons();
        
        // Model output buttons
        setupModelButtons();
        
        // Multiple shuffle buttons
        setupMultipleShuffleButtons();
        
        // Window resize handler
        window.addEventListener('resize', () => {
          if (AppState.dom.cardsLayer && AppState.dom.cardsLayer.childElementCount > 0) {
            repositionCards();
          }
        });
      }

      /**
       * Sets up collapsible section handlers
       */
      function setupCollapsibleSections() {
        const sectionHeaders = document.querySelectorAll('.section-header');
        sectionHeaders.forEach(header => {
          header.addEventListener('click', () => {
            const targetId = header.dataset.target;
            const content = getElement(targetId);
            const caret = header.querySelector('.caret');
            
            if (!content) return;
            
            if (content.classList.contains('collapsed')) {
              content.classList.remove('collapsed');
              caret.classList.add('expanded');
            } else {
              content.classList.add('collapsed');
              caret.classList.remove('expanded');
            }
          });
        });
      }

      /**
       * Sets up tab navigation
       */
      function setupTabs() {
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            
            tab.classList.add('active');
            
            const tabName = tab.dataset.tab;
            const content = getElement(tabName + '-content');
            if (content) content.classList.add('active');
          });
        });
      }

      /**
       * Sets up shuffle button handlers
       */
      function setupShuffleButtons() {
        const shuffleBtn = getElement('shuffleBtn');
        const samplingShuffleBtn = getElement('samplingShuffleBtn');
        
        if (shuffleBtn) {
          shuffleBtn.addEventListener('click', () => performShuffle());
        }
        
        if (samplingShuffleBtn) {
          samplingShuffleBtn.addEventListener('click', () => performShuffle());
        }
      }

      /**
       * Sets up clear button handlers
       */
      function setupClearButtons() {
        const clearPlotBtn = getElement('clearPlotBtn');
        const clearModelBtn = getElement('clearModelBtn');
        const clearB1Btn = getElement('clearB1Btn');
        const clearShuffleBtn = getElement('clearShuffleBtn');
        const clearShufflePlotBtn = getElement('clearShufflePlotBtn');
        const clearSamplingBtn = getElement('clearSamplingBtn');
        const clearGraphingPlotsBtn = getElement('clearGraphingPlotsBtn');
        
        if (clearPlotBtn) {
          clearPlotBtn.addEventListener('click', () => {
            const output = getElement('plotOutput');
            if (output) output.style.display = 'none';
            
            AppState.shuffledOutcomes = [];
            const shuffledCells = document.querySelectorAll('tbody td:nth-child(3) .cell-content');
            shuffledCells.forEach(cell => cell.textContent = '');
            
            const cards = AppState.dom.cardsLayer.querySelectorAll('.card');
            cards.forEach(card => {
              card.classList.remove('show-border', 'jiggle', 'hover');
              card.style.transition = `all ${ANIMATION_TIMING.CARD_TRANSITION}ms cubic-bezier(.2,.8,.2,1)`;
            });
            
            repositionCards();
          });
        }
        
        if (clearModelBtn) {
          clearModelBtn.addEventListener('click', () => {
            const output = getElement('rOutput');
            if (output) output.style.display = 'none';
          });
        }
        
        if (clearB1Btn) {
          clearB1Btn.addEventListener('click', () => {
            const output = getElement('b1Output');
            if (output) output.style.display = 'none';
          });
        }
        
        if (clearShuffleBtn) {
          clearShuffleBtn.addEventListener('click', clearShuffleData);
        }
        
        if (clearShufflePlotBtn) {
          clearShufflePlotBtn.addEventListener('click', () => {
            const output = getElement('shufflePlotOutput');
            if (output) output.style.display = 'none';
            clearShuffleData();
          });
        }
        
        if (clearSamplingBtn) {
          clearSamplingBtn.addEventListener('click', clearShuffleData);
        }
        
        if (clearGraphingPlotsBtn) {
          clearGraphingPlotsBtn.addEventListener('click', clearGraphingPlots);
        }
      }

      /**
       * Sets up plot generation button handlers
       */
      function setupPlotButtons() {
        const runPlotBtn = getElement('runPlotBtn');
        const runShufflePlotBtn = getElement('runShufflePlotBtn');
        const runGraphingPlotBtn = getElement('runGraphingPlotBtn');
        const toggleMeansBtn = getElement('toggleMeansBtn');
        const toggleShuffleMeansBtn = getElement('toggleShuffleMeansBtn');
        const toggleGraphingMeansBtn = getElement('toggleGraphingMeansBtn');
        
        if (runPlotBtn) {
          runPlotBtn.addEventListener('click', generateScatterPlot);
        }
        
        if (runShufflePlotBtn) {
          runShufflePlotBtn.addEventListener('click', () => {
            performShuffleForGraph(generateShuffleScatterPlot);
          });
        }
        
        if (runGraphingPlotBtn) {
          runGraphingPlotBtn.addEventListener('click', () => {
            if (AppState.graphingShuffleHistory.length >= 7) {
              clearGraphingPlots();
              return;
            }
            
            performShuffleForGraph(() => {
              generateSmallShuffleGraph();
            });
          });
        }
        
        if (toggleMeansBtn) {
          toggleMeansBtn.addEventListener('click', () => {
            AppState.showMeans = !AppState.showMeans;
            toggleMeansBtn.textContent = AppState.showMeans ? 'Hide Means' : 'Show Means';
            generateScatterPlot();
          });
        }
        
        if (toggleShuffleMeansBtn) {
          toggleShuffleMeansBtn.addEventListener('click', () => {
            AppState.showShuffleMeans = !AppState.showShuffleMeans;
            toggleShuffleMeansBtn.textContent = AppState.showShuffleMeans ? 'Hide Means' : 'Show Means';
            generateShuffleScatterPlot();
          });
        }
        
        if (toggleGraphingMeansBtn) {
          toggleGraphingMeansBtn.addEventListener('click', () => {
            AppState.showGraphingMeans = !AppState.showGraphingMeans;
            toggleGraphingMeansBtn.textContent = AppState.showGraphingMeans ? 'Hide Means' : 'Show Means';
            regenerateAllGraphingGraphs();
          });
        }
      }

      /**
       * Sets up model output button handlers
       */
      function setupModelButtons() {
        const runModelBtn = getElement('runModelBtn');
        const runB1Btn = getElement('runB1Btn');
        
        if (runModelBtn) {
          runModelBtn.addEventListener('click', () => {
            showROutput(`lm(${CONFIG.outcomeName}~${CONFIG.groupName}, data=df)`);
          });
        }
        
        if (runB1Btn) {
          runB1Btn.addEventListener('click', showB1Output);
        }
      }

      /**
       * Sets up multiple shuffle button handlers
       */
      function setupMultipleShuffleButtons() {
        const run5xBtn = getElement('run5xBtn');
        const shuffleRun5xBtn = getElement('shuffleRun5xBtn');
        
        if (run5xBtn) {
          run5xBtn.addEventListener('click', () => runMultipleShuffles(5));
        }
        
        if (shuffleRun5xBtn) {
          shuffleRun5xBtn.addEventListener('click', () => runMultipleShuffles(5));
        }
      }

      // ============================================================================
      // TAB VISIBILITY CONFIGURATION
      // ============================================================================

      /**
       * Configures which tabs are visible based on URL parameters
       */
      function configureTabVisibility() {
        const tabMapping = {
          1: { tab: 'graphing', content: 'graphing-content', title: 'Graphing Shuffles' },
          2: { tab: 'model', content: 'model-content', title: 'A Two-Group Model: <span class="math">Y<sub>i</sub> = b<sub>0</sub> + b<sub>1</sub>X<sub>i</sub> + e<sub>i</sub></span>' },
          3: { tab: 'shuffle', content: 'shuffle-content', title: 'Simulating a World Where <span class="math">β<sub>1</sub></span> is 0' },
          4: { tab: 'sampling', content: 'sampling-content', title: 'A Sampling Distribution of <span class="math">b<sub>1</sub></span> Assuming <span class="math">β<sub>1</sub></span>=0' }
        };
        
        // Hide tabs not in visibleTabs
        Object.keys(tabMapping).forEach(tabNum => {
          const tabNumber = parseInt(tabNum);
          const { tab, content } = tabMapping[tabNum];
          
          const tabElement = document.querySelector(`[data-tab="${tab}"]`);
          const contentElement = getElement(content);
          
          if (!visibleTabs.includes(tabNumber)) {
            if (tabElement) tabElement.style.display = 'none';
            if (contentElement) contentElement.style.display = 'none';
          } else {
            if (tabElement) tabElement.style.display = '';
            if (contentElement) contentElement.style.display = '';
          }
        });
        
        // Single tab configuration
        if (visibleTabs.length === 1) {
          const tabsContainer = document.querySelector('.tabs-container');
          if (tabsContainer) tabsContainer.style.display = 'none';
          
          const singleTabNumber = visibleTabs[0];
          const singleTabInfo = tabMapping[singleTabNumber];
          
          if (singleTabInfo) {
            const contentElement = getElement(singleTabInfo.content);
            if (contentElement) {
              const internalTitle = contentElement.querySelector('.tab-title');
              if (internalTitle) internalTitle.style.display = 'none';
              
              const topTitle = document.createElement('div');
              topTitle.className = 'tab-title';
              topTitle.style.margin = '16px 0 20px 0';
              topTitle.innerHTML = singleTabInfo.title;
              
              const rightColumn = document.querySelector('.right-column');
              if (rightColumn) {
                rightColumn.insertBefore(topTitle, rightColumn.firstChild);
              }
            }
          }
        }
        
        // Set first visible tab as active
        const firstVisibleTab = Math.min(...visibleTabs);
        const firstTabInfo = tabMapping[firstVisibleTab];
        
        if (firstTabInfo && visibleTabs.length > 1) {
          document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
          
          const firstTabElement = document.querySelector(`[data-tab="${firstTabInfo.tab}"]`);
          const firstContentElement = getElement(firstTabInfo.content);
          
          if (firstTabElement) firstTabElement.classList.add('active');
          if (firstContentElement) firstContentElement.classList.add('active');
        } else if (visibleTabs.length === 1) {
          const singleTabInfo = tabMapping[visibleTabs[0]];
          const singleContentElement = getElement(singleTabInfo.content);
          if (singleContentElement) {
            singleContentElement.classList.add('active');
            singleContentElement.style.display = 'block';
          }
        }
      }

      /**
       * Updates dynamic text content based on configuration
       */
      function updateDynamicContent() {
        const updates = [
          { id: 'groupHeader', text: CONFIG.groupName },
          { id: 'outcomeHeader', text: CONFIG.outcomeName },
          { id: 'shuffledHeader', text: CONFIG.outcomeName + '_shuf' }
        ];
        
        updates.forEach(({ id, text }) => {
          const el = getElement(id);
          if (el) el.textContent = text;
        });
        
        // Update code blocks
        const codeBlocks = {
          graphingPlotCodeBlock: `df<span class="lit-dollar">$</span>${CONFIG.outcomeName}_shuf &lt;- shuffle(df<span class="lit-dollar">$</span>${CONFIG.outcomeName})\ngf_point(${CONFIG.outcomeName}_shuf ~ ${CONFIG.groupName}, data=df)`,
          codeBlock: `df<span class="lit-dollar">$</span>${CONFIG.outcomeName}_shuf &lt;- shuffle(df<span class="lit-dollar">$</span>${CONFIG.outcomeName})\nb1(${CONFIG.outcomeName}_shuf ~ ${CONFIG.groupName}, data=df)`,
          samplingCodeBlock: `df<span class="lit-dollar">$</span>${CONFIG.outcomeName}_shuf &lt;- shuffle(df<span class="lit-dollar">$</span>${CONFIG.outcomeName})\nb1(${CONFIG.outcomeName}_shuf ~ ${CONFIG.groupName}, data=df)`,
          modelCodeBlock: `lm(${CONFIG.outcomeName} ~ ${CONFIG.groupName}, data=df)`,
          shufflePlotCodeBlock: `df<span class="lit-dollar">$</span>${CONFIG.outcomeName}_shuf &lt;- shuffle(df<span class="lit-dollar">$</span>${CONFIG.outcomeName})\ngf_point(${CONFIG.outcomeName}_shuf ~ ${CONFIG.groupName}, data=df)`,
          b1CodeBlock: `b1(${CONFIG.outcomeName} ~ ${CONFIG.groupName}, data=df)`,
          plotCodeBlock: `gf_point(${CONFIG.outcomeName} ~ ${CONFIG.groupName}, data=df)`
        };
        
        Object.entries(codeBlocks).forEach(([id, html]) => {
          const el = getElement(id);
          if (el) el.innerHTML = html;
        });
      }

      // ============================================================================
      // INITIALIZATION
      // ============================================================================

      /**
       * Main initialization function
       * Called when DOM is ready
       */
      function initialize() {
        // Initialize data structures
        initializeData();
        
        // Cache DOM references
        updateDOMRefs();
        
        // Configure UI
        configureTabVisibility();
        updateDynamicContent();
        
        // Render initial state
        drawTable();
        calculateStats();
        createCards();
        
        // Set up event handlers
        setupEventHandlers();

        // Generate initial graph for graphing tab
        generateOriginalDataGraph();

        // Initialize histogram configuration
        const nA = AppState.currentData.filter(r => r.group === CONFIG.groupAName).length;
        const nB = AppState.currentData.filter(r => r.group === CONFIG.groupBName).length;
        const allVals = AppState.currentData.map(r => r.outcome);
        AppState.histConfig = computeFixedXAxis(allVals, nA, nB);

        renderHistogram();
      }

      // Start the application when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
      } else {
        initialize();
      }
    })();
  </script>
</body>
</html>
